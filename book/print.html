<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="mermaid.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="what_is_chalk.html"><strong aria-hidden="true">1.</strong> What is Chalk?</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="what_is_chalk/walkthrough.html"><strong aria-hidden="true">1.1.</strong> Walkthrough</a></li><li class="chapter-item expanded "><a href="what_is_chalk/crates.html"><strong aria-hidden="true">1.2.</strong> Crates</a></li><li class="chapter-item expanded "><a href="what_is_chalk/repl.html"><strong aria-hidden="true">1.3.</strong> REPL</a></li></ol></li><li class="chapter-item expanded "><a href="contribution_guide.html"><strong aria-hidden="true">2.</strong> Contribution guide</a></li><li class="chapter-item expanded "><a href="types.html"><strong aria-hidden="true">3.</strong> Representing and manipulating types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="types/role_of_interner.html"><strong aria-hidden="true">3.1.</strong> The Interner</a></li><li class="chapter-item expanded "><a href="types/rust_types.html"><strong aria-hidden="true">3.2.</strong> Rust types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="types/rust_types/alias.html"><strong aria-hidden="true">3.2.1.</strong> Alias types</a></li><li class="chapter-item expanded "><a href="types/rust_types/application_ty.html"><strong aria-hidden="true">3.2.2.</strong> Application types</a></li></ol></li><li class="chapter-item expanded "><a href="types/rust_lifetimes.html"><strong aria-hidden="true">3.3.</strong> Rust lifetimes</a></li><li class="chapter-item expanded "><a href="types/operations.html"><strong aria-hidden="true">3.4.</strong> Operations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="types/operations/fold.html"><strong aria-hidden="true">3.4.1.</strong> TypeFoldable and the TypeFolder trait</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="clauses.html"><strong aria-hidden="true">4.</strong> Lowering Rust IR to logic</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="clauses/goals_and_clauses.html"><strong aria-hidden="true">4.1.</strong> Goals and clauses</a></li><li class="chapter-item expanded "><a href="clauses/type_equality.html"><strong aria-hidden="true">4.2.</strong> Type equality and unification</a></li><li class="chapter-item expanded "><a href="clauses/implied_bounds.html"><strong aria-hidden="true">4.3.</strong> Implied bounds</a></li><li class="chapter-item expanded "><a href="clauses/lowering_rules.html"><strong aria-hidden="true">4.4.</strong> Lowering rules</a></li><li class="chapter-item expanded "><a href="clauses/opaque_types.html"><strong aria-hidden="true">4.5.</strong> Opaque types (impl Trait)</a></li><li class="chapter-item expanded "><a href="clauses/well_known_traits.html"><strong aria-hidden="true">4.6.</strong> Well known traits</a></li><li class="chapter-item expanded "><a href="clauses/wf.html"><strong aria-hidden="true">4.7.</strong> Well-formedness checking</a></li><li class="chapter-item expanded "><a href="clauses/coherence.html"><strong aria-hidden="true">4.8.</strong> Coherence</a></li></ol></li><li class="chapter-item expanded "><a href="canonical_queries.html"><strong aria-hidden="true">5.</strong> Canonical queries</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="canonical_queries/canonicalization.html"><strong aria-hidden="true">5.1.</strong> Canonicalization</a></li></ol></li><li class="chapter-item expanded "><a href="engine.html"><strong aria-hidden="true">6.</strong> Chalk engine</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="engine/major_concepts.html"><strong aria-hidden="true">6.1.</strong> Major concepts</a></li><li class="chapter-item expanded "><a href="engine/logic.html"><strong aria-hidden="true">6.2.</strong> Logic</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="engine/logic/coinduction.html"><strong aria-hidden="true">6.2.1.</strong> Coinduction</a></li></ol></li><li class="chapter-item expanded "><a href="engine/slg.html"><strong aria-hidden="true">6.3.</strong> SLG Solver</a></li></ol></li><li class="chapter-item expanded "><a href="recursive.html"><strong aria-hidden="true">7.</strong> Chalk recursive solver</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="recursive/stack.html"><strong aria-hidden="true">7.1.</strong> The stack</a></li><li class="chapter-item expanded "><a href="recursive/inductive_cycles.html"><strong aria-hidden="true">7.2.</strong> Inductive cycles</a></li><li class="chapter-item expanded "><a href="recursive/search_graph.html"><strong aria-hidden="true">7.3.</strong> The search graph and caching</a></li><li class="chapter-item expanded "><a href="recursive/coinduction.html"><strong aria-hidden="true">7.4.</strong> Coinduction</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="glossary.html">Appendix A: Glossary and terminology</a></li><li class="chapter-item expanded affix "><a href="bibliography.html">Appendix B: Bibliography</a></li><li class="chapter-item expanded affix "><a href="todo.html">Appendix C: Incomplete chapters</a></li><li class="chapter-item expanded affix "><a href="publishing.html">Appendix D: Publishing Chalk</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#what-is-chalk" id="what-is-chalk">What is Chalk?</a></h1>
<blockquote>
<p>Chalk is under heavy development, so if any of these links are broken or if
any of the information is inconsistent with the code or outdated, please
<a href="https://github.com/rust-lang/chalk/issues">open an issue</a> so we can fix it. If you are able to fix the
issue yourself, we would love your contribution!</p>
</blockquote>
<p>Chalk is a library that implements the Rust trait system. The implementation is
meant to be practical and usable, but also high-level enough to map easily to a
full specification. It is also meant to be an independent library that can be
integrated both into the main rustc compiler and also other programs and
contexts.</p>
<h2><a class="header" href="#high-level-view-of-how-chalk-works" id="high-level-view-of-how-chalk-works">High-level view of how chalk works</a></h2>
<pre class="mermaid">graph TD
    Query[&quot;Does `Vec&amp;lt;u8&gt;` implement `Debug`?&quot;]
    HighLevelInfo[&quot;How is the trait `Debug` declared?&quot;]
    Response[&quot;Yes, `Vec&amp;lt;u8&gt;` implements `Debug`.&quot;]
    Chalk
    Query --&gt; Chalk
    HighLevelInfo --&gt; Chalk
    Chalk --&gt; Response
</pre>
<p>Chalk is designed to answer queries about traits, such as &quot;Does the type <code>Vec&lt;u8&gt;</code> implement <code>Debug</code>&quot;? (Yes!). It can in some cases give inference feedback, such as &quot;Is there a unique type <code>T</code> such that <code>str: AsRef&lt;T&gt;</code>&quot;? In that case, the answer might be &quot;Yes, <code>T = str</code>.&quot;</p>
<p>To do this, it takes as input key information about a Rust program, such as:</p>
<ul>
<li>For a given trait, what are its type parameters, where clauses, and associated items</li>
<li>For a given impl, what are the types that appear in the impl header</li>
<li>For a given struct, what are the types of its fields</li>
</ul>
<h2><a class="header" href="#chalk-works-by-converting-rust-goals-into-logical-inference-rules" id="chalk-works-by-converting-rust-goals-into-logical-inference-rules">Chalk works by converting Rust goals into logical inference rules</a></h2>
<p>Internally, Chalk works by converting the Rust-specific information, like traits
and impls, into <em>logical predicates</em>. This process is called &quot;lowering&quot;, and you
can learn more about it in the <a href="./clauses.html"><em>Lowering to Logic</em></a> and
<a href="./clauses/lowering_rules.html"><em>Lowering Rules</em></a>) sections.</p>
<p>After lowering to logical predicates, Chalk then deploys a <em>logical solver</em> to
find the answer to the original query; this solver is similar to a Prolog
engine, though different in its particulars.</p>
<p>The following sequence diagram helps to illustrate the flow of information that occurs
when Chalk is solving a particular goal. It involves three participants:</p>
<ul>
<li>The <strong>host program</strong>, which might be rustc, rust-analyzer, or chalk's internal
testing harness. The host program, importantly, only thinks about things in
<strong>Rust terms</strong>, like traits and impls.</li>
<li>The <strong>chalk-solve</strong> crate, which converts between Rust terms and logical clauses.</li>
<li>The <strong>logic engine</strong> layer, which knows how to solve logical clauses but knows nothing specific to Rust.</li>
</ul>
<pre class="mermaid">sequenceDiagram
  participant rustc as host program
  participant chalkSolve as chalk-solve
  participant chalkEngine as logic engine
  rustc-&gt;&gt;chalkSolve: Does Vec[u32] implement Debug?
  chalkSolve-&gt;&gt;chalkEngine: (Vec[u32]: Debug)?
  chalkEngine-&gt;&gt;chalkSolve: What clauses can I use?
  chalkSolve-&gt;&gt;rustc: What is the definition of `Debug`?&lt;br&gt;(via RustIrDatabase)
  rustc--&gt;&gt;chalkSolve: `trait Debug { .. }`&lt;br&gt;(a TraitDatum)
  chalkSolve-&gt;&gt;rustc: What impls are there for Vec?
  rustc--&gt;&gt;chalkSolve: `impl[T]: Debug] Debug for Vec[T]`&lt;br&gt;(an ImplDatum)
  Note right of chalkSolve: &quot;lowers&quot; rust &lt;br&gt;declarations to logic
  chalkSolve--&gt;&gt;chalkEngine: (Vec[T]: Debug) :- (T: Debug)
  chalkSolve--&gt;&gt;chalkEngine: ... and other clauses ...
  activate chalkEngine
  Note right of chalkEngine: explores each clause&lt;br&gt;to see if it works
  chalkEngine--&gt;&gt;chalkSolve: (Vec[u32]: Debug) is provable
  deactivate chalkEngine
  chalkSolve--&gt;&gt;rustc: Yes, Vec[u32] implements Debug
</pre>
<h2><a class="header" href="#chalk-repl" id="chalk-repl">Chalk repl</a></h2>
<p>In addition to being embedded into host programs, chalk also has its own testing
harness along with an associated REPL. This allows us to write unit tests that
use a &quot;Rust-like&quot; syntax. The REPL then makes it easy to experiment and get a
better feel for how chalk works. See the <a href="what_is_chalk/walkthrough.html">walkthrough</a> for more details.</p>
<h1><a class="header" href="#walkthrough" id="walkthrough">Walkthrough</a></h1>
<p>This section shows a sample session in the chalk repl, and then gives a tour
through the code to give you an idea of the phases involved.</p>
<pre><code class="language-rust ignore">?- program
Enter a program; press Ctrl-D when finished
| struct Foo { }
| struct Bar { }
| struct Vec&lt;T&gt; { }
| trait Clone { }
| impl&lt;T&gt; Clone for Vec&lt;T&gt; where T: Clone { }
| impl Clone for Foo { }

?- Vec&lt;Foo&gt;: Clone
Unique; substitution [], lifetime constraints []

?- Vec&lt;Bar&gt;: Clone
No possible solution.

?- exists&lt;T&gt; { Vec&lt;T&gt;: Clone }
Ambiguous; no inference guidance
</code></pre>
<p>You can see more examples of programs and queries in the <a href="https://github.com/rust-lang/chalk/blob/4bce000801de31bf45c02f742a5fce335c9f035f/src/test.rs#L115">unit
tests</a>.</p>
<p>Next we'll go through each stage required to produce the output above.</p>
<h3><a class="header" href="#parsing-a-hrefhttpsrust-langgithubiochalkchalk_parseindexhtmlchalk_parsea" id="parsing-a-hrefhttpsrust-langgithubiochalkchalk_parseindexhtmlchalk_parsea">Parsing (<a href="https://rust-lang.github.io/chalk/chalk_parse/index.html">chalk_parse</a>)</a></h3>
<p>Chalk is designed to be incorporated with the Rust compiler, so the syntax and
concepts it deals with heavily borrow from Rust. It is convenient for the sake
of testing to be able to run chalk on its own, so chalk includes a parser for a
Rust-like syntax. This syntax is orthogonal to the Rust AST and grammar. It is
not intended to look exactly like it or support the exact same syntax.</p>
<p>The parser takes that syntax and produces an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">Abstract Syntax Tree (AST)</a>.
You can find the <a href="https://rust-lang.github.io/chalk/chalk_parse/ast/index.html">complete definition of the AST</a> in the source code.</p>
<p>The syntax contains things from Rust that we know and love, for example: traits,
impls, and struct definitions. Parsing is often the first &quot;phase&quot; of
transformation that a program goes through in order to become a format that
chalk can understand.</p>
<h3><a class="header" href="#rust-intermediate-representation-a-hrefhttpsrust-langgithubiochalkchalk_solverust_irindexhtmlchalk_solverust_ira" id="rust-intermediate-representation-a-hrefhttpsrust-langgithubiochalkchalk_solverust_irindexhtmlchalk_solverust_ira">Rust Intermediate Representation (<a href="https://rust-lang.github.io/chalk/chalk_solve/rust_ir/index.html">chalk_solve::rust_ir</a>)</a></h3>
<p>After getting the AST we convert it to a more convenient intermediate
representation called <code>chalk_rust_ir</code>. This is sort of
analogous to the <a href="https://rustc-dev-guide.rust-lang.org/hir.html">HIR</a> in Rust. The process of converting to IR is called
<em>lowering</em>.</p>
<p>The <a href="https://rust-lang.github.io/chalk/chalk_integration/program/struct.Program.html"><code>chalk::program::Program</code></a> struct contains some &quot;rust things&quot;
but indexed and accessible in a different way. For example, if you have a
type like <code>Foo&lt;Bar&gt;</code>, we would represent <code>Foo</code> as a string in the AST but in
<code>chalk::program::Program</code>, we use numeric indices (<code>ItemId</code>).</p>
<p>The <a href="https://rust-lang.github.io/chalk/chalk_solve/rust_ir/">IR source code</a> contains the complete definition.</p>
<h3><a class="header" href="#chalk-intermediate-representation-a-hrefhttpsrust-langgithubiochalkchalk_irindexhtmlchalk_ira" id="chalk-intermediate-representation-a-hrefhttpsrust-langgithubiochalkchalk_irindexhtmlchalk_ira">Chalk Intermediate Representation (<a href="https://rust-lang.github.io/chalk/chalk_ir/index.html">chalk_ir</a>)</a></h3>
<p>Once we have Rust IR it is time to convert it to &quot;program clauses&quot;. A
<a href="https://rust-lang.github.io/chalk/chalk_ir/struct.ProgramClause.html"><code>ProgramClause</code></a> is essentially one of the following:</p>
<ul>
<li>A <a href="https://github.com/rust-lang/chalk/blob/master/GLOSSARY.md#clause">clause</a> of the form <code>consequence :- conditions</code> where <code>:-</code> is read as
&quot;if&quot; and <code>conditions = cond1 &amp;&amp; cond2 &amp;&amp; ...</code></li>
<li>A universally quantified clause of the form
<code>forall&lt;T&gt; { consequence :- conditions }</code>
<ul>
<li><code>forall&lt;T&gt; { ... }</code> is used to represent <a href="https://en.wikipedia.org/wiki/Universal_quantification">universal quantification</a>. See the
section on <a href="what_is_chalk/../clauses.html#type-checking-generic-functions-beyond-horn-clauses">Lowering to logic</a> for more information.</li>
<li>A key thing to note about <code>forall</code> is that we don't allow you to &quot;quantify&quot;
over traits, only types and regions (lifetimes). That is, you can't make a
rule like <code>forall&lt;Trait&gt; { u32: Trait }</code> which would say &quot;<code>u32</code> implements
all traits&quot;. You can however say <code>forall&lt;T&gt; { T: Trait }</code> meaning &quot;<code>Trait</code>
is implemented by all types&quot;.</li>
<li><code>forall&lt;T&gt; { ... }</code> is represented in the code using the <a href="https://rust-lang.github.io/chalk/chalk_ir/struct.Binders.html"><code>Binders&lt;T&gt;</code>
struct</a>.</li>
</ul>
</li>
</ul>
<p><em>See also: <a href="what_is_chalk/../clauses/goals_and_clauses.html">Goals and Clauses</a></em></p>
<p>This is where we encode the rules of the trait system into logic. For
example, if we have the following Rust:</p>
<pre><code class="language-rust ignore">impl&lt;T: Clone&gt; Clone for Vec&lt;T&gt; {}
</code></pre>
<p>We generate the following program clause:</p>
<pre><code class="language-rust ignore">forall&lt;T&gt; { (Vec&lt;T&gt;: Clone) :- (T: Clone) }
</code></pre>
<p>This rule dictates that <code>Vec&lt;T&gt;: Clone</code> is only satisfied if <code>T: Clone</code> is also
satisfied (i.e. &quot;provable&quot;).</p>
<p>Similar to <a href="https://rust-lang.github.io/chalk/chalk_integration/program/struct.Program.html"><code>chalk::program::Program</code></a> which has &quot;rust-like
things&quot;, chalk_ir defines <a href="https://rust-lang.github.io/chalk/chalk_integration/program_environment/struct.ProgramEnvironment.html"><code>ProgramEnvironment</code></a> which is &quot;pure logic&quot;.
The main field in that struct is <code>program_clauses</code>, which contains the
<a href="https://rust-lang.github.io/chalk/chalk_ir/struct.ProgramClause.html"><code>ProgramClause</code></a>s generated by the rules module.</p>
<h3><a class="header" href="#rules-a-hrefhttpsrust-langgithubiochalkchalk_solveindexhtmlchalk_solvea" id="rules-a-hrefhttpsrust-langgithubiochalkchalk_solveindexhtmlchalk_solvea">Rules (<a href="https://rust-lang.github.io/chalk/chalk_solve/index.html">chalk_solve</a>)</a></h3>
<p>The <code>chalk_solve</code> crate (<a href="https://rust-lang.github.io/chalk/chalk_solve/index.html">source code</a>) defines the logic rules we
use for each item in the Rust IR. It works by iterating over every trait, impl,
etc. and emitting the rules that come from each one.</p>
<p><em>See also: <a href="what_is_chalk/../clauses/lowering_rules.html">Lowering Rules</a></em></p>
<h4><a class="header" href="#well-formedness-checks" id="well-formedness-checks">Well-formedness checks</a></h4>
<p>As part of lowering to logic, we also do some &quot;well formedness&quot; checks. See
the <a href="https://rust-lang.github.io/chalk/chalk_solve/wf/index.html"><code>chalk_solve::wf</code> source code</a> for where those are done.</p>
<p><em>See also: <a href="what_is_chalk/../clauses/wf.html">Well-formedness checking</a></em></p>
<h4><a class="header" href="#coherence" id="coherence">Coherence</a></h4>
<p>The method <code>CoherenceSolver::specialization_priorities</code> in the <code>coherence</code> module
(<a href="https://rust-lang.github.io/chalk/chalk_solve/coherence/index.html">source code</a>) checks &quot;coherence&quot;, which means that it
ensures that two impls of the same trait for the same type cannot exist.</p>
<h3><a class="header" href="#solver-a-hrefhttpsrust-langgithubiochalkchalk_solveindexhtmlchalk_solvea" id="solver-a-hrefhttpsrust-langgithubiochalkchalk_solveindexhtmlchalk_solvea">Solver (<a href="https://rust-lang.github.io/chalk/chalk_solve/index.html">chalk_solve</a>)</a></h3>
<p>Finally, when we've collected all the program clauses we care about, we want
to perform queries on it. The component that finds the answer to these
queries is called the <em>solver</em>.</p>
<p><em>See also: <a href="what_is_chalk/../engine/slg.html">The SLG Solver</a></em></p>
<h2><a class="header" href="#crates" id="crates">Crates</a></h2>
<p>Chalk's functionality is broken up into the following crates:</p>
<ul>
<li><a href="https://rust-lang.github.io/chalk/chalk_engine"><strong>chalk_engine</strong></a>: Defines the core <a href="what_is_chalk/../engine/slg.html">SLG solver</a>.</li>
<li><a href="https://rust-lang.github.io/chalk/chalk_ir/index.html"><strong>chalk_ir</strong></a>: Defines chalk's internal representation of
types, lifetimes, and goals.</li>
<li><a href="https://rust-lang.github.io/chalk/chalk_solve/index.html"><strong>chalk_solve</strong></a>: Combines <code>chalk_ir</code> and <code>chalk_engine</code>,
effectively, which implements logic rules converting <code>chalk_rust_ir</code> to
<code>chalk_ir</code>
<ul>
<li>Contains the <code>rust_ir</code> module, which defines the &quot;HIR-like&quot; Rust IR</li>
<li>Defines the <code>coherence</code> module, which implements coherence rules</li>
<li><a href="https://rust-lang.github.io/chalk/chalk_engine/context/index.html"><code>chalk_engine::context</code></a> provides the necessary hooks.</li>
</ul>
</li>
<li><a href="https://rust-lang.github.io/chalk/chalk_parse/index.html"><strong>chalk_parse</strong></a>: Defines the raw AST and a parser.</li>
<li><a href="https://rust-lang.github.io/chalk/chalk/index.html"><strong>chalk</strong></a>: Brings everything together. Defines the following
modules:
<ul>
<li><code>chalk::lowering</code>, which converts AST to <code>chalk_rust_ir</code></li>
<li>Also includes <a href="https://github.com/rust-lang/chalk/blob/master/src/main.rs">chalki</a>, chalk's REPL.</li>
</ul>
</li>
</ul>
<p><a href="https://github.com/rust-lang/chalk">Browse source code on GitHub</a></p>
<h2><a class="header" href="#testing" id="testing">Testing</a></h2>
<p>chalk has a test framework for lowering programs to logic, checking the
lowered logic, and performing queries on it. This is how we test the
implementation of chalk itself, and the viability of the <a href="what_is_chalk/../clauses/lowering_rules.html">lowering
rules</a>.</p>
<p>The main kind of tests in chalk are <strong>goal tests</strong>. They contain a program,
which is expected to lower to logic successfully, and a set of queries
(goals) along with the expected output. Here's an
<a href="https://github.com/rust-lang/chalk/blob/4bce000801de31bf45c02f742a5fce335c9f035f/src/test.rs#L115">example</a>. Since chalk's output can be quite long, goal
tests support specifying only a prefix of the output.</p>
<p><strong>Lowering tests</strong> check the stages that occur before we can issue queries
to the solver: the <a href="https://github.com/rust-lang/chalk/blob/4bce000801de31bf45c02f742a5fce335c9f035f/src/rust_ir/lowering/test.rs">lowering to chalk_rust_ir</a>, and the
<a href="https://github.com/rust-lang/chalk/blob/4bce000801de31bf45c02f742a5fce335c9f035f/src/rules/wf/test.rs#L1">well-formedness checks</a> that occur after that.</p>
<h3><a class="header" href="#testing-internals" id="testing-internals">Testing internals</a></h3>
<p>Goal tests use a <a href="https://github.com/rust-lang/chalk/blob/4bce000801de31bf45c02f742a5fce335c9f035f/src/test.rs#L33"><code>test!</code> macro</a> that takes chalk's Rust-like
syntax and runs it through the full pipeline described above. The macro
ultimately calls the <a href="https://github.com/rust-lang/chalk/blob/4bce000801de31bf45c02f742a5fce335c9f035f/src/test.rs#L85"><code>solve_goal</code> function</a>.</p>
<p>Likewise, lowering tests use the <a href="https://github.com/rust-lang/chalk/blob/4bce000801de31bf45c02f742a5fce335c9f035f/src/test_util.rs#L21-L54"><code>lowering_success!</code> and
<code>lowering_error!</code> macros</a>.</p>
<h2><a class="header" href="#more-resources" id="more-resources">More Resources</a></h2>
<ul>
<li><a href="https://github.com/rust-lang/chalk">Chalk Source Code</a></li>
<li><a href="what_is_chalk/../glossary.html">Chalk Glossary</a></li>
</ul>
<h1><a class="header" href="#crate-breakdown" id="crate-breakdown">Crate breakdown</a></h1>
<p>Chalk is broken up into a number of crates. This chapter explains the
role of each crate. This crate structure helps to serve Chalk's two goals:</p>
<ul>
<li>To serve as the trait engine for compilers and tools like rustc and rust-analyzer</li>
<li>To be usable as a standalone REPL and testing harness</li>
</ul>
<h2><a class="header" href="#crates-for-embedding-chalk-into-other-programs" id="crates-for-embedding-chalk-into-other-programs">Crates for embedding chalk into other programs</a></h2>
<p>The following crates are &quot;public facing&quot; crates that you may use when embedding chalk into
other programs:</p>
<ul>
<li>The <code>chalk-solve</code> crate, which defines the IR representing Rust concepts like
traits and impls and the rules that translate Rust IR into logical predicates.</li>
<li>The <code>chalk-ir</code> crate, which defines the IR representing types and logical predicates.</li>
</ul>
<p>The following crate is an implementation detail, used internally by <code>chalk-solve</code>:</p>
<ul>
<li>The <code>chalk-engine</code> crate, which defines the actual engine that solves logical predicate. This
engine is quite general and not really specific to Rust.</li>
<li>The <code>chalk-derive</code> crate defines custom derives for the <code>chalk_ir::fold::TypeFoldable</code> trait and other
such things.</li>
</ul>
<h2><a class="header" href="#crates-for-standalone-repl-and-testing" id="crates-for-standalone-repl-and-testing">Crates for standalone REPL and testing</a></h2>
<p>The following crates are used to define the REPL and internal testing
harness. These crates build on the crates above. Essentially, they
define a kind of &quot;minimal embedding&quot; of chalk.</p>
<ul>
<li>The <code>chalk-parser</code> crate can parse Rust syntax to produce an AST.</li>
<li>The <code>chalk-integration</code> crate can take that AST and use it to drive the
<code>chalk-solve</code> crate above. The AST is converted into Rust IR by a process
called &quot;lowering&quot;.</li>
<li>Finally, the main <code>chalk</code> crate, along with the testing crate in the
<code>tests</code> directory, define the actual entry points.</li>
</ul>
<h2><a class="header" href="#the-chalk-solve-crate" id="the-chalk-solve-crate">The chalk-solve crate</a></h2>
<table><thead><tr><th>The <code>chalk-solve</code> crate</th><th></th></tr></thead><tbody>
<tr><td>Purpose:</td><td>to solve a given goal</td></tr>
<tr><td>Depends on IR:</td><td>chalk-ir and rust-ir</td></tr>
<tr><td>Context required:</td><td><code>RustIrDatabase</code></td></tr>
</tbody></table>
<p>The <code>chalk-solve</code> crate exposes a key type called <code>Solver</code>.  This is a
solver that, given a goal (expressed in chalk-ir) will solve the goal
and yield up a <code>Solution</code>. The solver caches intermediate data between
invocations, so solving the same goal twice in a row (or solving goals
with common subgoals) is faster.</p>
<p>The solver is configured by a type that implements the
<code>RustIrDatabase</code> trait. This trait contains some callbacks that
provide needed context for the solver -- notably, the solver can ask:</p>
<ul>
<li><strong>What are the program clauses that might solve given rule?</strong> This
is answered by the code in the chalk-solve crate.</li>
<li><strong>Is this trait coinductive?</strong> This is answered by the chalk-ir.</li>
</ul>
<h2><a class="header" href="#the-chalk-engine-crate" id="the-chalk-engine-crate">The chalk-engine crate</a></h2>
<table><thead><tr><th>The <code>chalk-engine</code> crate</th><th></th></tr></thead><tbody>
<tr><td>Purpose:</td><td>define the base solving strategy</td></tr>
<tr><td>IR:</td><td>none</td></tr>
<tr><td>Context required:</td><td><code>Context</code> trait</td></tr>
</tbody></table>
<p>For the purposes of chalk, the <code>chalk-engine</code> crate is effectively
encapsulated by <code>chalk-solve</code>.  It defines the base SLG engine. It is
written in a very generic style that knows next to nothing about Rust
itself. The engine can be configured via the traits defined in
<code>chalk_engine::context::Context</code>, which contain (for example)
associated types that define what a goal or clause is, as well as
functions that operate on those things.</p>
<h1><a class="header" href="#repl" id="repl">REPL</a></h1>
<p>There is a repl mainly for debugging purposes which can be run by <code>cargo run</code>. Some basic examples are in <a href="https://github.com/rust-lang/chalk/blob/master/libstd.chalk">libstd.chalk</a>:</p>
<pre><code class="language-bash">$ cargo run
?- load libstd.chalk
?- Vec&lt;Box&lt;i32&gt;&gt;: Clone
Unique; substitution [], lifetime constraints []
</code></pre>
<h1><a class="header" href="#contribution-guide" id="contribution-guide">Contribution guide</a></h1>
<p>Thank you for your interest in contributing to chalk! There are many ways to
contribute, and we appreciate all of them.</p>
<ul>
<li><a href="contribution_guide.html#bug-reports">Bug Reports</a></li>
<li><a href="contribution_guide.html#running-and-debugging">Running and Debugging</a></li>
<li><a href="contribution_guide.html#pull-requests">Pull Requests</a></li>
<li><a href="contribution_guide.html#writing-documentation">Writing Documentation</a></li>
</ul>
<p>If you'd like to contribute, consider joining the <a href="https://rust-lang.github.io/compiler-team/working-groups/traits/">Traits Working Group</a>.
We hang out on the <a href="https://rust-lang.zulipchat.com">rust-lang zulip</a> in the <a href="https://rust-lang.zulipchat.com/#narrow/stream/144729-wg-traits">#wg-traits</a> stream.</p>
<p>As a reminder, all contributors are expected to follow our <a href="https://www.rust-lang.org/conduct.html">Code of Conduct</a>.</p>
<h2><a class="header" href="#bug-reports" id="bug-reports">Bug Reports</a></h2>
<p>While bugs are unfortunate, they're a reality in software. We can't fix what we
don't know about, so please report liberally. If you're not sure if something
is a bug or not, feel free to file a bug anyway.</p>
<p>If you have the chance, before reporting a bug, please search existing issues,
as it's possible that someone else has already reported your error. This doesn't
always work, and sometimes it's hard to know what to search for, so consider
this extra credit. We won't mind if you accidentally file a duplicate report.</p>
<p>Sometimes, a backtrace is helpful, and so including that is nice. To get
a backtrace, set the <code>RUST_BACKTRACE</code> environment variable to a value
other than <code>0</code>. The easiest way to do this is to invoke <code>chalk</code> like this:</p>
<pre><code class="language-bash">$ RUST_BACKTRACE=1 chalk ...
</code></pre>
<h2><a class="header" href="#running-and-debugging" id="running-and-debugging">Running and Debugging</a></h2>
<p>There is a repl mainly for debugging purposes which can be run by <code>cargo run</code>. Some basic examples are in <a href="https://github.com/rust-lang/chalk/blob/master/libstd.chalk">libstd.chalk</a>:</p>
<pre><code class="language-bash">$ cargo run
?- load libstd.chalk
?- Vec&lt;Box&lt;i32&gt;&gt;: Clone
Unique; substitution [], lifetime constraints []
</code></pre>
<p>More logging can be enabled by setting the <code>CHALK_DEBUG</code> environment variable. Set <code>CHALK_DEBUG=3</code> or <code>CHALK_DEBUG=info</code> to see <code>info!(...)</code> output, and <code>CHALK_DEBUG=4</code> or <code>CHALK_DEBUG=debug</code> to see <code>debug!(...)</code> output as well. In addition, logs may be filtered in a number of ways. The syntax for filtering logs is:</p>
<pre><code class="language-notrust"> target[span{field=value}]=level
</code></pre>
<p>(Note: all parts of the filter are optional )</p>
<p>In more detail, the filter may consist of:</p>
<ul>
<li>A target (location of origin)
<ul>
<li>For example setting <code>CHALK_DEBUG='chalk_solve::infer::unify'</code> will filter logs to show only output originating from <code>chalk_solve::infer::unify</code>.</li>
</ul>
</li>
<li>A span (name provided to the logging macros, for instance <code>unify_var_ty</code> in <code>debug_span!(&quot;unify_var_ty&quot;)</code>)
<ul>
<li>For example setting <code>CHALK_DEBUG='[unify_ty_ty]'</code> will show only logs where the span contains <code>unify_ty_ty</code>.</li>
</ul>
</li>
<li>A list of fields (variables recorded in the logs), for instance <code>ty</code> in <code>debug!(&quot;unify_var_ty&quot;, ?ty)</code> with values optionally specified
<ul>
<li>For example setting <code>CHALK_DEBUG='[{ty}]'</code> will show only logs which contain a variable <code>ty</code></li>
<li>Setting <code>CHALK_DEBUG='[{ty=Bar}]'</code> will show only logs which contain a variable <code>ty</code> with the value <code>Bar</code></li>
</ul>
</li>
<li>A maximum log level (one of <code>info</code>, <code>debug</code>, <code>trace</code>) which shows logs at or below the given level</li>
</ul>
<p>More documentation on the syntax and options can be found <a href="https://docs.rs/tracing-subscriber/latest/tracing_subscriber/filter/struct.EnvFilter.html#Directives">here</a>.</p>
<h2><a class="header" href="#pull-requests" id="pull-requests">Pull Requests</a></h2>
<p>Pull requests are the primary mechanism we use to change Rust. GitHub itself
has some <a href="https://help.github.com/articles/about-pull-requests/">great documentation</a> on using the Pull Request feature.
We use the &quot;fork and pull&quot; model <a href="https://help.github.com/articles/about-collaborative-development-models/">described here</a>, where
contributors push changes to their personal fork and create pull requests to
bring those changes into the source repository.</p>
<p>Please make pull requests against the <code>master</code> branch.</p>
<h2><a class="header" href="#writing-documentation" id="writing-documentation">Writing Documentation</a></h2>
<p>Documentation improvements are very welcome. Documentation pull requests
function in the same way as other pull requests.</p>
<p>You can find documentation style guidelines in <a href="https://github.com/rust-lang/rfcs/blob/master/text/1574-more-api-documentation-conventions.md#appendix-a-full-conventions-text">RFC 1574</a>.</p>
<h1><a class="header" href="#representing-and-manipulating-rust-types" id="representing-and-manipulating-rust-types">Representing and manipulating Rust types</a></h1>
<h2><a class="header" href="#intermediate-representations" id="intermediate-representations">Intermediate representations</a></h2>
<p>Intermediate representations (IR) are used to represent parts of Rust programs such as traits and impls.</p>
<p>Chalk contains three levels of IR:</p>
<ul>
<li>The <strong>AST</strong>. This is used purely for writing test cases
with a Rust-like syntax. This is consumed by <strong>lowering</strong> code, which
takes AST and produces <strong>Rust IR</strong> (the next bullet point).</li>
<li>The <strong>Rust IR</strong>. This is a &quot;HIR-like&quot; notation that defines the
interesting properties of things like traits, impls, and structs.
It is an input to the <strong>rules</strong> code, which produces <strong>Chalk IR</strong> (the next bullet point).</li>
<li>The <strong>Chalk IR</strong>. This is most &quot;Prolog-like&quot; of the various IRs. It
contains the definition of <strong>types</strong> as well as prolog-like concepts
such as goals (things that must be proven true) and clauses (things
that are assumed to be true).</li>
</ul>
<h2><a class="header" href="#goal-of-the-chalk-ir-crate" id="goal-of-the-chalk-ir-crate">Goal of the chalk-ir crate</a></h2>
<p>To have an ergonomic, flexible library that can abstractly represent
Rust types and logical predicates. The library should be expose a
&quot;minimal&quot; set of types that is nonetheless able to capture the full
range of Rust types. &quot;Minimal&quot; here means that some of the surface
differences in Rust types -- e.g., the distinction between built-in
types like <code>u32</code> and user-defined types like a struct -- ought to be
minimized, so that code that works with these types (e.g., trait
solving) can focus on the most important differences.</p>
<h2><a class="header" href="#goal-support-embedding-and-a-variety-of-contexts" id="goal-support-embedding-and-a-variety-of-contexts">Goal: support embedding and a variety of contexts</a></h2>
<p>One of our goals is to create a type representation that can be
readily embedded into a variety of contexts. Most specifically, we
would like to be able to embed into rustc and rust-analyzer, and
permit those two projects to use distinct memory management
strategies. This is primarily achieved via the <code>Interner</code> trait.</p>
<p>Initially, at least in rustc, the goal is to be able to easily and
&quot;reasonably efficiently&quot; convert back and forth between rustc's native
type representation and chalk's representation. Once chalk's design
has stabilized, however, the goal would be for rustc to adopt this
format as its &quot;native&quot; representation.</p>
<p>Note that even if the chalk type library were used everywhere,
however, it would still be useful for rustc to be able to control the
memory management strategy. (In other words, different consumers might
wish to use it in different ways.)</p>
<h2><a class="header" href="#note-on-status" id="note-on-status">Note on status</a></h2>
<p>At the moment, this documentation is a &quot;proposal&quot;. That means that it
diverges in some places from what is actually implemented. It has also
not been thoroughly discussed by the Rust compiler team as a whole.</p>
<p>Here is a (partial) list of some things that have to be adapted in
Chalk as of today to match this document:</p>
<ul>
<li>Extract <code>TypeName</code> into something opaque to chalk-ir.</li>
<li>Dyn type equality should probably be driven by entailment.</li>
<li>Projections need to be renamed to aliases.</li>
<li>The variant we use for impl traits should be removed and folded into type aliases.</li>
<li>Remove placeholders and projection placeholders from apply and create placeholder types.</li>
<li>Move <code>Error</code> from a <code>TypeName</code> to its own variant.</li>
<li>Introduce <code>GeneratorWitness</code> into chalk</li>
<li>Complete transition from <code>ForAll</code> to <code>Fn</code> in chalk</li>
</ul>
<h2><a class="header" href="#the-role-of-the-interner" id="the-role-of-the-interner">The role of the <code>Interner</code></a></h2>
<p>Most everything in the IR is parameterized by the <a href="https://rust-lang.github.io/chalk/chalk_ir/interner/trait.Interner.html"><code>Interner</code></a> trait:</p>
<pre><code class="language-rust ignore">trait Interner: Copy + Clone + Debug + Eq + Ord {
    ..
}
</code></pre>
<p>We'll go over the details later, but for now it suffices to say that
the interner is defined by the embedder and can be used to control
(to a certain extent) the actual representation of types, goals, and
other things in memory. For example, the <code>Interner</code> trait could be
used to intern all the types, as rustc does, or it could be used to
<code>Box</code> them instead, as the chalk testing harness currently does.</p>
<h3><a class="header" href="#controlling-representation-with-interner" id="controlling-representation-with-interner">Controlling representation with <code>Interner</code></a></h3>
<p>The purpose of the <a href="https://rust-lang.github.io/chalk/chalk_ir/interner/trait.Interner.html"><code>Interner</code></a> trait is to give control over how
types and other bits of chalk-ir are represented in memory. This is
done via an &quot;indirection&quot; strategy. We'll explain that strategy here
in terms of <a href="https://rust-lang.github.io/chalk/chalk_ir/struct.Ty.html"><code>Ty</code></a> and <a href="https://rust-lang.github.io/chalk/chalk_ir/enum.TyKind.html"><code>TyKind</code></a>, the two types used to represent
Rust types, but the same pattern is repeated for many other things.</p>
<p>Types are represented by a <a href="https://rust-lang.github.io/chalk/chalk_ir/struct.Ty.html"><code>Ty&lt;I&gt;</code></a> type and the <a href="https://rust-lang.github.io/chalk/chalk_ir/enum.TyKind.html"><code>TyKind&lt;I&gt;</code></a> enum.
There is no <em>direct</em> connection between them. The link is rather made
by the <a href="https://rust-lang.github.io/chalk/chalk_ir/interner/trait.Interner.html"><code>Interner</code></a> trait, via the <a href="https://rust-lang.github.io/chalk/chalk_ir/interner/trait.Interner.html#associatedtype.InternedType"><code>InternedTy</code></a> associated type:</p>
<pre><code class="language-rust ignore">struct Ty&lt;I: Interner&gt;(I::InternedTy);
enum TyKind&lt;I: Interner&gt; { .. }
</code></pre>
<p>The way this works is that the <a href="https://rust-lang.github.io/chalk/chalk_ir/interner/trait.Interner.html"><code>Interner</code></a> trait has an associated
type <a href="https://rust-lang.github.io/chalk/chalk_ir/interner/trait.Interner.html#associatedtype.InternedType"><code>InternedTy</code></a> and two related methods, <a href="https://rust-lang.github.io/chalk/chalk_ir/interner/trait.Interner.html#tymethod.intern_ty"><code>intern_ty</code></a> and <a href="https://rust-lang.github.io/chalk/chalk_ir/interner/trait.Interner.html#tymethod.ty_data"><code>ty_data</code></a>:</p>
<pre><code class="language-rust ignore">trait Interner {
    type InternedTy;

    fn intern_ty(&amp;self, data: &amp;TyKind&lt;Self&gt;) -&gt; Self::InternedTy;
    fn ty_data(data: &amp;Self::InternedTy) -&gt; &amp;TyData&lt;Self&gt;;
}
</code></pre>
<p>However, as a user you are not meant to use these directly. Rather,
they are encapsulated in methods on the <a href="https://rust-lang.github.io/chalk/chalk_ir/struct.Ty.html"><code>Ty</code></a> and <a href="https://rust-lang.github.io/chalk/chalk_ir/enum.TyKind.html"><code>TyKind</code></a> types:</p>
<pre><code class="language-rust ignore">impl&lt;I: Interner&gt; Ty&lt;I&gt; {
  fn data(&amp;self) -&gt; &amp;TyKind&lt;I&gt; {
    I::lookup_ty(self)
  }
}
</code></pre>
<p>and</p>
<pre><code class="language-rust ignore">impl&lt;I: Interner&gt; TyKind&lt;I&gt; {
  fn intern(&amp;self, i: &amp;I) -&gt; Ty&lt;I&gt; {
    Ty(i.intern_ty(self))
  }
}
</code></pre>
<p>Note that there is an assumption here that <a href="https://rust-lang.github.io/chalk/chalk_ir/interner/trait.Interner.html#tymethod.ty_data"><code>ty_data</code></a> needs no
context. This effectively constrains the <a href="https://rust-lang.github.io/chalk/chalk_ir/interner/trait.Interner.html#associatedtype.InternedType"><code>InternedTy</code></a> representation
to be a <code>Box</code> or <code>&amp;</code> type. To be more general, at the cost of some
convenience, we could make that a method as well, so that one would
invoke <code>ty.data(i)</code> instead of just <code>ty.data()</code>. This would permit us
to use (for example) integers to represent interned types, which might
be nice (e.g., to permit using generational indices).</p>
<h1><a class="header" href="#rust-types" id="rust-types">Rust types</a></h1>
<p>Rust types are represented by the <a href="https://rust-lang.github.io/chalk/chalk_ir/struct.Ty.html"><code>Ty</code></a> and <a href="https://rust-lang.github.io/chalk/chalk_ir/enum.TyKind.html"><code>TyKind</code></a> types.
You use <a href="https://rust-lang.github.io/chalk/chalk_ir/struct.Ty.html"><code>Ty</code></a> to represent &quot;some Rust type&quot;. But to actually inspect
what sort of type you have, you invoke the <a href="https://rust-lang.github.io/chalk/chalk_ir/struct.Ty.html#method.kind"><code>kind</code></a> method, which
returns a <a href="https://rust-lang.github.io/chalk/chalk_ir/enum.TyKind.html"><code>TyKind</code></a>. As described earlier, the actual in-memory
representation of types is controlled by the <a href="https://rust-lang.github.io/chalk/chalk_ir/interner/trait.Interner.html"><code>Interner</code></a> trait.</p>
<h2><a class="header" href="#the-tykind-variants-and-how-they-map-to-rust-syntax" id="the-tykind-variants-and-how-they-map-to-rust-syntax">The <code>TyKind</code> variants and how they map to Rust syntax</a></h2>
<p>This section covers the variants we use to categorize types. We have
endeavored to create a breakdown that simplifies the Rust &quot;surface
syntax&quot; of types to their &quot;essence&quot;. In particular, the goal is to
group together types that are largely treated identically by the
system and to separate types when there are important semantic
differences in how they are handled.</p>
<table><thead><tr><th>Chalk variant</th><th>Example Rust types</th></tr></thead><tbody>
<tr><td><code>Placeholder</code></td><td>how we represent <code>T</code> when type checking <code>fn foo&lt;T&gt;() { .. }</code></td></tr>
<tr><td><code>Dyn</code></td><td><code>dyn Trait</code></td></tr>
<tr><td><code>Fn</code></td><td><code>fn(&amp;u8)</code></td></tr>
<tr><td><code>Alias</code></td><td><code>&lt;T as Iterator&gt;::Item</code>, or the <code>Foo</code> in <code>type Foo = impl Trait</code> and <code>type Foo = u32</code></td></tr>
<tr><td><code>BoundVariable</code></td><td>an uninstantiated generic parameter like the <code>T</code> in <code>struct Foo&lt;T&gt;</code></td></tr>
<tr><td><code>Adt</code></td><td><code>struct Foo&lt;T&gt;</code></td></tr>
<tr><td>...</td><td>...</td></tr>
</tbody></table>
<h2><a class="header" href="#justification-for-each-variant" id="justification-for-each-variant">Justification for each variant</a></h2>
<p>Each variant of <code>TyKind</code> generally wraps a single struct, which
represents a type known to be of that particular variant. This section
goes through the variants in a bit more detail, and in particular
describes why each variant exists.</p>
<h3><a class="header" href="#application-types" id="application-types">Application types</a></h3>
<p>Most of &quot;normal rust types&quot; like <code>Vec&lt;u32&gt;</code> or <code>(f32, Vec&lt;isize&gt;)</code> are represented with 
<code>TyKind</code> variants containing some type-specific info (&quot;type name&quot;) and a substitution
that is &quot;applied&quot; to that type. In this case, type names are <code>Vec</code> and &quot;tuple of arity 2&quot;,
and substitutions are <code>[u32]</code> and <code>[f32, Vec&lt;isize&gt;]</code>.</p>
<p>They are equal to other types (modulo aliases, see below) iff they
have the same &quot;type name&quot; and the generic arguments are
recursively equal</p>
<h3><a class="header" href="#placeholders" id="placeholders">Placeholders</a></h3>
<p>The <code>Placeholder</code> variant contains a <code>PlaceholderIndex</code> type. It
represents a generic type that is being treated abstractly or -- more
generally -- the result of a &quot;type function&quot; that cannot be
evaluated. For example, when typing the body of a generic function
like <code>fn foo&lt;T: Iterator&gt;</code>, the type <code>T</code> would be represented with a
placeholder. Similarly, in that same function, the associated type
<code>T::Item</code> might be represented with a placeholder.</p>
<p>Like application types, placeholder <em>types</em> are only known to be
equal.</p>
<p>When proving negative goals, e.g., <code>not { Implemented(T: Trait) }</code>, placeholders are treated quite differently from application
types, since they do not (in fact) represent a known type. When
solving negative goals, placeholders are replaced with inference
variables -- the idea is that this goal is only true if there is <em>no
type</em> <code>T</code> that implements <code>Trait</code>. Therefore, if we can find no
answers for <code>exists&lt;T&gt; { Implemented(T: Trait) }</code>, then we know that
the negation is true. (Note that this means that e.g. <code>forall&lt;X&gt; { X = i32 }</code> is false but so is <code>forall&lt;X&gt; { not { X = i32 } }</code>.)</p>
<h3><a class="header" href="#inference-variables" id="inference-variables">Inference variables</a></h3>
<p>The <code>InferenceVar</code> variant wraps an <code>InferenceVar</code> type.  This
represents a type whose value is being inferred. The value of an
inference variables may be &quot;known&quot; or &quot;not known&quot;, but that state is
stored externally, in the inference context (see the section on
inference below).</p>
<p>When equating, inference variables are treated specially in that they
become bound (or, if they have already been bound, they are replaced
with their value).</p>
<p>Inference variables are also integral to canonicalization and
other types.</p>
<h3><a class="header" href="#dyn-types" id="dyn-types">Dyn types</a></h3>
<p>The <code>Dyn</code> variant wraps a <code>DynTy</code> and represents a <code>dyn Trait</code>
type. In chalk, these are represented as an existential type where we
store the predicates that are known to be true. So a type like <code>dyn Write</code> would be represented as, effectively, an <code>exists&lt;T&gt; { T: Write }</code> type.</p>
<p>When equating, two <code>dyn P</code> and <code>dyn Q</code> types are equal if <code>P = Q</code> --
i.e., they have the same bounds. Note that -- for this purpose --
ordering of bounds is significant. That means that if you create a
<code>dyn Foo + Send</code> and a <code>dyn Send + Foo</code>, chalk would consider them
distinct types. The assumption is that bounds are ordered in some
canonical fashion somewhere else. This may want to change.</p>
<p>There are &quot;automatic&quot; rules for proving that <code>dyn P: P</code> and so forth, but
that is outside the scope of the chalk-ir crate.</p>
<h3><a class="header" href="#function-pointer-types" id="function-pointer-types">Function pointer types</a></h3>
<p>The <code>Function</code> variant wraps a <code>FnPointer</code> struct and represents a <code>fn()</code> type
(in other words, a function pointer). In some ways, fn types are like
application types, but with one crucial difference: they also contain
a <code>forall</code> binder that for lifetimes whose value is determined when
the function is called. Consider e.g. a type like <code>fn(&amp;u32)</code> or --
more explicitly -- <code>for&lt;'a&gt; fn(&amp;'a u32)</code>.</p>
<p>Two <code>Function</code> types <code>A, B</code> are equal <code>A = B</code> if <code>A &lt;: B</code> and <code>B &lt;: A</code></p>
<p>Two <code>Function</code> types <code>A, B</code> are subtypes <code>A &lt;: B</code> if</p>
<ul>
<li>After instantiating the lifetime parameters on <code>B</code> universally...
<ul>
<li>You can instantiate the lifetime parameters on <code>A</code> existentially...
<ul>
<li>And then you find that <code>P_B &lt;: P_A</code> for every parameter type <code>P</code> on <code>A</code> and <code>B</code> and
<code>R_A &lt;: R_B</code> for the return type <code>R</code> of <code>A</code> and <code>B</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>We currently handle type inference with a bit of a hack (same as
rustc); when relating a <code>Fn</code> type <code>F</code> to an unbounded type
variable <code>V</code>, we instantiate <code>V</code> with <code>F</code>.  But in practice
because of the above subtyping rules there are actually a range of
values that <code>V</code> could have and still be equal with <code>F</code>. This may
or may not be something to consider revisiting.</p>
<h3><a class="header" href="#alias-types" id="alias-types">Alias types</a></h3>
<p>The <code>Alias</code> variant wraps an <code>AliasTy</code> and is used to represent some form of <em>type
alias</em>. They are used to represent a number of related Rust concepts, include
actual type aliases, associated types, and opaque types -- you can read about
them in the <a href="types/./rust_types/alias.html">aliases chapter</a>.</p>
<h3><a class="header" href="#bound-variables" id="bound-variables">Bound variables</a></h3>
<p>The <code>BoundVar</code> variant represents some variable that is bound in
an outer term. For example, given a term like <code>forall&lt;X&gt; { Implemented(X: Trait) }</code>, the <code>X</code> is bound. Bound variables in chalk
(like rustc) use De Bruijn indices (See below).</p>
<p>Bound variables are never directly equated, as any bound variables would have
been instantiated with either inference variables or placeholders.</p>
<p>They do appear in canonical forms and other terms that contain binders.</p>
<h3><a class="header" href="#error-types" id="error-types">Error types</a></h3>
<p>The <code>Error</code> variant represents a type that resulted from some
erroneous expression. Error types generally propagate eagerly in an
attempt to suppress nonsense errors that are derived by interactions
with buggy code.</p>
<p><code>Error</code> should be its own variant because most bits of code will want
to handle it somewhat specially -- e.g., maybe it can &quot;unify&quot; with any
other type without any effect, and so forth.</p>
<h2><a class="header" href="#mapping-to-rustc-types" id="mapping-to-rustc-types">Mapping to rustc types</a></h2>
<p>The rustc <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_type_ir/ty_kind/enum.TyKind.html"><code>TyKind</code></a> enum is almost equivalent to chalk's. This
section describes how the rustc types can be mapped to chalk
types. The intention is that, at least when transitioning, rustc would
implement the <code>Interner</code> trait and would map from the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_type_ir/ty_kind/enum.TyKind.html"><code>TyKind</code></a>
enum to chalk's <a href="https://rust-lang.github.io/chalk/chalk_ir/enum.TyKind.html"><code>TyKind</code></a> on the fly, when <code>data()</code> is invoked.</p>
<table><thead><tr><th>rustc type</th><th>chalk variant (and some notes)</th></tr></thead><tbody>
<tr><td><code>Bool</code></td><td><code>Scalar</code></td></tr>
<tr><td><code>Char</code></td><td><code>Scalar</code></td></tr>
<tr><td><code>Int</code></td><td><code>Scalar</code></td></tr>
<tr><td><code>Uint</code></td><td><code>Scalar</code></td></tr>
<tr><td><code>Float</code></td><td><code>Scalar</code></td></tr>
<tr><td><code>Adt</code></td><td><code>Adt</code></td></tr>
<tr><td><code>Foreign</code></td><td><code>Foreign</code></td></tr>
<tr><td><code>Str</code></td><td><code>Str</code></td></tr>
<tr><td><code>Array</code></td><td><code>Array</code></td></tr>
<tr><td><code>Slice</code></td><td><code>Slice</code></td></tr>
<tr><td><code>RawPtr</code></td><td><code>Raw</code></td></tr>
<tr><td><code>Ref</code></td><td><code>Ref</code></td></tr>
<tr><td><code>FnDef</code></td><td><code>FnDef</code></td></tr>
<tr><td><code>FnPtr</code></td><td><code>Function</code></td></tr>
<tr><td><code>Dynamic</code></td><td><code>Dyn</code></td></tr>
<tr><td><code>Closure</code></td><td><code>Closure</code></td></tr>
<tr><td><code>Coroutine</code></td><td><code>Coroutine</code></td></tr>
<tr><td><code>CoroutineWitness</code></td><td><code>CoroutineWitness</code></td></tr>
<tr><td><code>Never</code></td><td><code>Never</code></td></tr>
<tr><td><code>Tuple</code></td><td><code>Tuple</code></td></tr>
<tr><td><code>Projection</code></td><td><code>Alias</code></td></tr>
<tr><td><code>UnnormalizedProjection</code></td><td>(see below)</td></tr>
<tr><td><code>Opaque</code></td><td><code>Alias</code></td></tr>
<tr><td><code>Param</code></td><td>XXX Placeholder?</td></tr>
<tr><td><code>Bound</code></td><td><code>BoundVar</code></td></tr>
<tr><td><code>Placeholder</code></td><td><code>Placeholder</code></td></tr>
<tr><td><code>Infer</code></td><td><code>InferenceVar</code></td></tr>
<tr><td><code>Error</code></td><td><code>Error</code></td></tr>
</tbody></table>
<h1><a class="header" href="#alias-types-1" id="alias-types-1">Alias types</a></h1>
<p><strong>Alias types</strong> are used in chalk to handle a number of distinct Rust
concepts:</p>
<ul>
<li>Explicit type aliases like <code>type Foo = u32</code> (in theory)</li>
<li>Associated types like <code>impl Iterator for Foo { type Item = Bar }</code></li>
<li>Opaque types generated by impl Traits, like <code>type Foo = impl Iterator&lt;Item = u32&gt;</code>
or <code>fn foo() -&gt; impl Iterator&lt;Item = u32&gt;</code>.</li>
</ul>
<p>What all these aliases have in common is that they let the user write the name
of one type that turns out to be <em>equivalent</em> to another, although the
equivalent type is not always known:</p>
<ul>
<li>In an explicit type alias like <code>type Foo = u32</code>, the user writes <code>Foo</code>
but it is always known to be equivalent to <code>u32</code></li>
<li>In an associated type, the user might write <code>&lt;vec::IntoIter&lt;u32&gt; as Iterator&gt;::Item</code>, but the compiler knows that can be <em>normalized</em> (see below)
to <code>u32</code>. In generic functions, though, you might have a type like <code>T::Item</code>
where we <em>can't</em> normalize, because we don't know what <code>T</code> is. Even in that
case, though, we still know that <code>T::Item: Sized</code>, because that bound is
<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#associatedtype.Item">declared in the <code>Iterator</code> trait</a> (by default, as it
happens). We describe how both cases are handled in more detail in the <a href="types/rust_types/../../clauses/type_equality.html">section on associated types</a>.</li>
<li>In an opaque type like <code>type Foo = impl Iterator&lt;Item = u32&gt;</code>, the user might
write <code>Foo</code> (which indirectly references the opaque type) but they never get
to rely on the precise underlying type. However, when generating code, the
<em>compiler</em> does need to be able to normalize <code>Foo</code> to the precise underlying
type, so normalization still does occur. We describe this in more detail in the <a href="types/rust_types/../../clauses/opaque_types.html">opaque types</a> section.</li>
</ul>
<h2><a class="header" href="#how-aliases-work" id="how-aliases-work">How aliases work</a></h2>
<p>All aliases have a few parts:</p>
<ul>
<li>The <em>Alias</em> type, which represents what the user wrote directly, but where there is
some underlying type.</li>
<li><em>Normalization</em> rules, which indicate when the alias type can be converted
into its underlying type.</li>
<li>A corresponding <em>Placeholder</em> type, which is used in cases where the alias <strong>cannot</strong> be
converted into its underlying type.</li>
</ul>
<h2><a class="header" href="#equating-an-alias" id="equating-an-alias">Equating an alias</a></h2>
<p>Alias types are integrated specially into unification. Whenever there is an
attempt to unify an <em>Alias</em> type <code>A</code> with some other type <code>T</code>, we generate an
<code>AliasEq</code> that must be solved:</p>
<pre><code class="language-notrust">AliasEq(A = T)
</code></pre>
<p>The rules for how to solve an <code>AliasEq</code> goal will be generated by lowering the alias
definition, and depend a bit on the kind of alias. We describe that lowering in the
<a href="types/rust_types/../../clauses.html">clauses</a> section.</p>
<h2><a class="header" href="#alias-placeholders" id="alias-placeholders">Alias placeholders</a></h2>
<p>For each kind of alias (except for explicit type aliases), there is also a
corresponding <em>placeholder</em> variant in the <a href="https://rust-lang.github.io/chalk/chalk_ir/enum.TyKind.html"><code>TyKind</code></a> enum. In those cases
where we cannot normalize the alias to something specific, it can be equated to
the placeholder type (see e.g. <a href="https://rust-lang.github.io/chalk/chalk_ir/enum.TyKind.html#variant.AssociatedType"><code>AssociatedType</code></a>, which is the placeholder
variant for associated type projections). Note that placeholders are
<em>application types</em> -- unlike an alias, a placeholder is only known to be equal
with itself, just like an application type.</p>
<h1><a class="header" href="#application-types-1" id="application-types-1">Application types</a></h1>
<p><a href="https://rust-lang.github.io/chalk/chalk_ir/enum.TyKind.html"><code>TyKind</code></a> variants that consist of some type-specific info (&quot;type name&quot;)
and a substitution are usually referred to as application types. 
These include most of the &quot;normal Rust types&quot;, such as <code>Vec</code> and <code>(f32, u32)</code>.
Such types are only &quot;equal&quot; to themselves (modulo aliases, see below). 
Scalar types (and some others) also fall into this category, despite having no
substitutions: we treat them as having zero-length substitutions.
Note that we group together <em>both</em> user-defined structs/enums/unions (like <code>Vec</code>)
as well as built-in types like <code>f32</code>, which effectively behave the
same.</p>
<p>We used to have application types in chalk as a separate notion in the codebase,
but have since moved away from that; nevertheless, the term is still useful in discussions.</p>
<h2><a class="header" href="#notable-application-types" id="notable-application-types">Notable application types</a></h2>
<h3><a class="header" href="#coroutine" id="coroutine">Coroutine</a></h3>
<p>A <code>Coroutine</code> represents a Rust coroutine. There are three major components
to a coroutine:</p>
<ul>
<li>Upvars - similar to closure upvars, they reference values outside of the coroutine,
and are stored across all yield points.</li>
<li>Resume/yield/return types - the types produced/consumed by various coroutine methods.
These are not stored in the coroutine across yield points - they are only
used when the coroutine is running.</li>
<li>Coroutine witness - see the <code>Coroutine Witness</code> section below.</li>
</ul>
<p>Of these types, only upvars and resume/yield/return are stored directly in <code>CoroutineDatum</code>
(which is accessed via <code>RustIrDatabase</code>). The coroutine witness is implicitly associated with
the coroutine by virtue of sharing the same <code>CoroutineId</code>. It is only used when determining
auto trait impls, where it is considered a 'constituent type'.</p>
<p>For example:</p>
<pre><code class="language-rust ignore">// This is not &quot;real&quot; syntax at the moment.
fn gen() -&gt; Bar {
  let a = yield 0usize;
  use(a)
}

fn use(_: usize) -&gt; Bar {}
</code></pre>
<p>The type of yield would be <code>usize</code>, the resume type would be the type of <code>a</code> and the return type
would be <code>Bar</code>.</p>
<h3><a class="header" href="#coroutine-witness-types" id="coroutine-witness-types">Coroutine witness types</a></h3>
<p>The <code>CoroutineWitness</code> variant represents the coroutine witness of
the coroutine with id <code>CoroutineId</code>. </p>
<p>The coroutine witness contains multiple witness types,
which represent the types that may be part of a coroutine
state - that is, the types of all variables that may be live across
a <code>yield</code> point.</p>
<p>Unlike other types, witnesses include bound, existential
lifetimes, which refer to lifetimes within the suspended stack frame.
You can think of it as a type like <code>exists&lt;'a&gt; { (T...) }</code>.
As an example, imagine that a type that isn't <code>Send</code> lives across a <code>yield</code>, then the coroutine
itself can't be <code>Send</code>.</p>
<p>Witnesses have a binder for the erased lifetime(s), which must be
handled specifically in equating and so forth. In many ways,
witnesses are also quite similar to <code>Function</code> types, and it is not
out of the question that these two could be unified; however, they
are quite distinct semantically and so that would be an annoying
mismatch in other parts of the system. Witnesses are also similar 
to a <code>Dyn</code> type, in that they represent an existential type, but
in contrast to <code>Dyn</code>, what we know here is not a <em>predicate</em> but
rather some upper bound on the set of types contained within.</p>
<h1><a class="header" href="#rust-lifetimes" id="rust-lifetimes">Rust lifetimes</a></h1>
<p>Lifetimes are represented by the <code>Lifetime&lt;I&gt;</code> and <code>LifetimeData&lt;I&gt;</code>
types. As with types, the actual representation of a lifetime is
defined by the associated type <code>I::InternedLifetime</code>.</p>
<h3><a class="header" href="#the-lifetimedata-variants" id="the-lifetimedata-variants">The <code>LifetimeData</code> variants</a></h3>
<p>This section covers the variants we use to categorize lifetimes.</p>
<h4><a class="header" href="#variants-and-their-equivalents-in-rust-syntax" id="variants-and-their-equivalents-in-rust-syntax">Variants and their equivalents in Rust syntax</a></h4>
<table><thead><tr><th>Chalk variant</th><th>Example Rust types</th></tr></thead><tbody>
<tr><td><code>BoundVar</code></td><td>the <code>'a</code> in a type like <code>for&lt;'a&gt; fn(&amp;'a u8)</code>, before it is instantiated</td></tr>
<tr><td><code>InferenceVar</code></td><td>a lifetime whose value is being inferred</td></tr>
<tr><td><code>Placeholder</code></td><td>how we represent <code>'a</code> when type checking <code>fn foo&lt;'a&gt;() { .. }</code></td></tr>
<tr><td><code>Static</code></td><td>the lifetime <code>'static</code></td></tr>
</tbody></table>
<h1><a class="header" href="#operations" id="operations">Operations</a></h1>
<p>This chapter describes various patterns and utilities for manipulating
Rust types.</p>
<h1><a class="header" href="#typefoldable-and-the-typefolder-trait" id="typefoldable-and-the-typefolder-trait">TypeFoldable and the TypeFolder trait</a></h1>
<p>The <a href="https://rust-lang.github.io/chalk/chalk_ir/fold/trait.TypeFoldable.html"><code>TypeFoldable</code></a> trait permits one to traverse a type or other term in the
chalk-ir and make a copy of it, possibly making small substitutions or
alterations along the way. Folding also allows copying a term from one
interner to another.</p>
<p>To use the <a href="https://rust-lang.github.io/chalk/chalk_ir/fold/trait.TypeFoldable.html"><code>TypeFoldable</code></a> trait, one invokes the <a href="https://rust-lang.github.io/chalk/chalk_ir/fold/trait.TypeFoldable.html#tymethod.fold_with"><code>TypeFoldable::fold_with</code></a> method, supplying some
&quot;folder&quot; as well as the number of &quot;in scope binders&quot; for that term (typically <code>0</code>
to start):</p>
<pre><code class="language-rust ignore">let output_ty = input_ty.fold_with(&amp;mut folder, 0);
</code></pre>
<p>The folder is some instance of the <a href="https://rust-lang.github.io/chalk/chalk_ir/fold/trait.TypeFolder.html"><code>TypeFolder</code></a> trait. This trait
defines a few key callbacks that allow you to substitute different
values as the fold proceeds. For example, when a type is folded, the
folder can substitute a new type in its place.</p>
<h2><a class="header" href="#uses-for-folders" id="uses-for-folders">Uses for folders</a></h2>
<p>A common use for <code>TypeFoldable</code> is to permit a substitution -- that is,
replacing generic type parameters with their values.</p>
<h2><a class="header" href="#from-typefoldable-to-typefolder-to-typesuperfoldable-and-back-again" id="from-typefoldable-to-typefolder-to-typesuperfoldable-and-back-again">From TypeFoldable to TypeFolder to TypeSuperFoldable and back again</a></h2>
<p>The overall flow of folding is like this.</p>
<ol>
<li><a href="https://rust-lang.github.io/chalk/chalk_ir/fold/trait.TypeFoldable.html#tymethod.fold_with"><code>TypeFoldable::fold_with</code></a> is invoked on the outermost term. It recursively
walks the term.</li>
<li>For those sorts of terms (types, lifetimes, goals, program clauses) that have
callbacks in the <a href="https://rust-lang.github.io/chalk/chalk_ir/fold/trait.TypeFolder.html"><code>TypeFolder</code></a> trait, invoking <a href="https://rust-lang.github.io/chalk/chalk_ir/fold/trait.TypeFoldable.html#tymethod.fold_with"><code>TypeFoldable::fold_with</code></a> will in turn
invoke the corresponding method on the <a href="https://rust-lang.github.io/chalk/chalk_ir/fold/trait.TypeFolder.html"><code>TypeFolder</code></a> trait, such as <code>TypeFolder::fold_ty</code>.</li>
<li>The default implementation of <code>TypeFolder::fold_ty</code>, in turn, invokes
<code>TypeSuperFoldable::super_fold_with</code>.  This will recursively fold the
contents of the type. In some cases, the <code>super_fold_with</code>
implementation invokes more specialized methods on <a href="https://rust-lang.github.io/chalk/chalk_ir/fold/trait.TypeFolder.html"><code>TypeFolder</code></a>, such
as <a href="https://rust-lang.github.io/chalk/chalk_ir/fold/trait.TypeFolder.html#method.fold_free_var_ty"><code>TypeFolder::fold_free_var_ty</code></a>, which makes it easier to write
folders that just intercept <em>certain</em> types.</li>
</ol>
<p>Thus, as a user, you can customize folding by:</p>
<ul>
<li>Defining your own <code>TypeFolder</code> type</li>
<li>Implementing the appropriate methods to &quot;intercept&quot; types/lifetimes/etc at the right level of
detail</li>
<li>In those methods, if you find a case where you would prefer not to
substitute a new value, then invoke <code>TypeSuperFoldable::super_fold_with</code> to
return to the default behavior.</li>
</ul>
<h2><a class="header" href="#the-binders-argument" id="the-binders-argument">The <code>binders</code> argument</a></h2>
<p>Each callback in the <a href="https://rust-lang.github.io/chalk/chalk_ir/fold/trait.TypeFolder.html"><code>TypeFolder</code></a> trait takes a <code>binders</code> argument. This indicates
the number of binders that we have traversed during folding, which is relevant for De Bruijn indices.
So e.g. a bound variable with depth 1, if invoked with a <code>binders</code> value of 1, indicates something that was bound to something external to the fold.</p>
<p>For example, consider:</p>
<pre><code class="language-rust ignore">Foo&lt;'a&gt;: for&lt;'b&gt; Bar&lt;'b&gt;
</code></pre>
<p>In this case, <code>Foo&lt;'a&gt;</code> gets visited with depth 0 and <code>Bar&lt;'b&gt;</code> gets visited with depth 1.</p>
<h2><a class="header" href="#the-typefoldableresult-associated-type" id="the-typefoldableresult-associated-type">The <code>TypeFoldable::Result</code> associated type</a></h2>
<p>The <code>TypeFoldable</code> trait defines a <a href="https://rust-lang.github.io/chalk/chalk_ir/fold/trait.TypeFoldable.html#associatedtype.Result"><code>Result</code></a> associated type, indicating the
type that will result from folding.</p>
<h2><a class="header" href="#when-to-implement-the-typefoldable-and-typesuperfoldable-traits" id="when-to-implement-the-typefoldable-and-typesuperfoldable-traits">When to implement the TypeFoldable and TypeSuperFoldable traits</a></h2>
<p>Any piece of IR that represents a kind of &quot;term&quot; (e.g., a type, part
of a type, or a goal, etc) in the logic should implement <code>TypeFoldable</code>. We
also implement <code>TypeFoldable</code> for common collection types like <code>Vec</code> as well
as tuples, references, etc.</p>
<p>The <code>TypeSuperFoldable</code> trait should only be implemented for those types that
have a callback defined on the <code>TypeFolder</code> trait (e.g., types and
lifetimes).</p>
<h2><a class="header" href="#derives" id="derives">Derives</a></h2>
<p>Using the <code>chalk-derive</code> crate, you can auto-derive the <code>TypeFoldable</code> trait.
There isn't presently a derive for <code>TypeSuperFoldable</code> since it is very rare
to require it. The derive for <code>TypeFoldable</code> is a bit cludgy and requires:</p>
<ul>
<li>You must import <code>TypeFoldable</code> into scope.</li>
<li>The type you are deriving <code>TypeFoldable</code> on must have either:
<ul>
<li>A type parameter that has a <code>Interner</code> bound, like <code>I: Interner</code></li>
<li>A type parameter that has a <code>HasInterner</code> bound, like <code>I: HasInterner</code></li>
<li>The <code>has_interner(XXX)</code> attribute.</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#lowering-rust-ir-to-logic" id="lowering-rust-ir-to-logic">Lowering Rust IR to logic</a></h1>
<p>The key observation here is that the Rust trait system is basically a
kind of logic, and it can be mapped onto standard logical inference
rules. We can then look for solutions to those inference rules in a
very similar fashion to how e.g. a <a href="https://en.wikipedia.org/wiki/Prolog">Prolog</a> solver works. It turns out
that we can't <em>quite</em> use Prolog rules (also called Horn clauses) but
rather need a somewhat more expressive variant.</p>
<h2><a class="header" href="#rust-traits-and-logic" id="rust-traits-and-logic">Rust traits and logic</a></h2>
<p>One of the first observations is that the Rust trait system is
basically a kind of logic. As such, we can map our struct, trait, and
impl declarations into logical inference rules. For the most part,
these are basically Horn clauses, though we'll see that to capture the
full richness of Rust – and in particular to support generic
programming – we have to go a bit further than standard Horn clauses.</p>
<p>To see how this mapping works, let's start with an example. Imagine
we declare a trait and a few impls, like so:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Clone { }
impl Clone for usize { }
impl&lt;T&gt; Clone for Vec&lt;T&gt; where T: Clone { }
<span class="boring">}
</span></code></pre></pre>
<p>We could map these declarations to some Horn clauses, written in a
Prolog-like notation, as follows:</p>
<pre><code class="language-text">Clone(usize).
Clone(Vec&lt;?T&gt;) :- Clone(?T).

// The notation `A :- B` means &quot;A is true if B is true&quot;.
// Or, put another way, B implies A.
</code></pre>
<p>In Prolog terms, we might say that <code>Clone(Foo)</code> – where <code>Foo</code> is some
Rust type – is a <em>predicate</em> that represents the idea that the type
<code>Foo</code> implements <code>Clone</code>. These rules are <strong>program clauses</strong>; they
state the conditions under which that predicate can be proven (i.e.,
considered true). So the first rule just says &quot;Clone is implemented
for <code>usize</code>&quot;. The next rule says &quot;for any type <code>?T</code>, Clone is
implemented for <code>Vec&lt;?T&gt;</code> if clone is implemented for <code>?T</code>&quot;. So
e.g. if we wanted to prove that <code>Clone(Vec&lt;Vec&lt;usize&gt;&gt;)</code>, we would do
so by applying the rules recursively:</p>
<ul>
<li><code>Clone(Vec&lt;Vec&lt;usize&gt;&gt;)</code> is provable if:
<ul>
<li><code>Clone(Vec&lt;usize&gt;)</code> is provable if:
<ul>
<li><code>Clone(usize)</code> is provable. (Which it is, so we're all good.)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>But now suppose we tried to prove that <code>Clone(Vec&lt;Bar&gt;)</code>. This would
fail (after all, I didn't give an impl of <code>Clone</code> for <code>Bar</code>):</p>
<ul>
<li><code>Clone(Vec&lt;Bar&gt;)</code> is provable if:
<ul>
<li><code>Clone(Bar)</code> is provable. (But it is not, as there are no applicable rules.)</li>
</ul>
</li>
</ul>
<p>We can easily extend the example above to cover generic traits with
more than one input type. So imagine the <code>Eq&lt;T&gt;</code> trait, which declares
that <code>Self</code> is equatable with a value of type <code>T</code>:</p>
<pre><code class="language-rust ignore">trait Eq&lt;T&gt; { ... }
impl Eq&lt;usize&gt; for usize { }
impl&lt;T: Eq&lt;U&gt;&gt; Eq&lt;Vec&lt;U&gt;&gt; for Vec&lt;T&gt; { }
</code></pre>
<p>That could be mapped as follows:</p>
<pre><code class="language-text">Eq(usize, usize).
Eq(Vec&lt;?T&gt;, Vec&lt;?U&gt;) :- Eq(?T, ?U).
</code></pre>
<p>So far so good.</p>
<h2><a class="header" href="#type-checking-normal-functions" id="type-checking-normal-functions">Type-checking normal functions</a></h2>
<p>OK, now that we have defined some logical rules that are able to
express when traits are implemented and to handle associated types,
let's turn our focus a bit towards <strong>type-checking</strong>. Type-checking is
interesting because it is what gives us the goals that we need to
prove. That is, everything we've seen so far has been about how we
derive the rules by which we can prove goals from the traits and impls
in the program; but we are also interested in how to derive the goals
that we need to prove, and those come from type-checking.</p>
<p>Consider type-checking the function <code>foo()</code> here:</p>
<pre><code class="language-rust ignore">fn foo() { bar::&lt;usize&gt;() }
fn bar&lt;U: Eq&lt;U&gt;&gt;() { }
</code></pre>
<p>This function is very simple, of course: all it does is to call
<code>bar::&lt;usize&gt;()</code>. Now, looking at the definition of <code>bar()</code>, we can see
that it has one where-clause <code>U: Eq&lt;U&gt;</code>. So, that means that <code>foo()</code> will
have to prove that <code>usize: Eq&lt;usize&gt;</code> in order to show that it can call <code>bar()</code>
with <code>usize</code> as the type argument.</p>
<p>If we wanted, we could write a Prolog predicate that defines the
conditions under which <code>bar()</code> can be called. We'll say that those
conditions are called being &quot;well-formed&quot;:</p>
<pre><code class="language-text">barWellFormed(?U) :- Eq(?U, ?U).
</code></pre>
<p>Then we can say that <code>foo()</code> type-checks if the reference to
<code>bar::&lt;usize&gt;</code> (that is, <code>bar()</code> applied to the type <code>usize</code>) is
well-formed:</p>
<pre><code class="language-text">fooTypeChecks :- barWellFormed(usize).
</code></pre>
<p>If we try to prove the goal <code>fooTypeChecks</code>, it will succeed:</p>
<ul>
<li><code>fooTypeChecks</code> is provable if:
<ul>
<li><code>barWellFormed(usize)</code>, which is provable if:
<ul>
<li><code>Eq(usize, usize)</code>, which is provable because of an impl.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Ok, so far so good. Let's move on to type-checking a more complex function.</p>
<h2><a class="header" href="#type-checking-generic-functions-beyond-horn-clauses" id="type-checking-generic-functions-beyond-horn-clauses">Type-checking generic functions: beyond Horn clauses</a></h2>
<p>In the last section, we used standard Prolog horn-clauses (augmented with Rust's
notion of type equality) to type-check some simple Rust functions. But that only
works when we are type-checking non-generic functions. If we want to type-check
a generic function, it turns out we need a stronger notion of goal than what Prolog
can provide. To see what I'm talking about, let's revamp our previous
example to make <code>foo</code> generic:</p>
<pre><code class="language-rust ignore">fn foo&lt;T: Eq&lt;T&gt;&gt;() { bar::&lt;T&gt;() }
fn bar&lt;U: Eq&lt;U&gt;&gt;() { }
</code></pre>
<p>To type-check the body of <code>foo</code>, we need to be able to hold the type
<code>T</code> &quot;abstract&quot;.  That is, we need to check that the body of <code>foo</code> is
type-safe <em>for all types <code>T</code></em>, not just for some specific type. We might express
this like so:</p>
<pre><code class="language-text">fooTypeChecks :-
  // for all types T...
  forall&lt;T&gt; {
    // ...if we assume that Eq(T, T) is provable...
    if (Eq(T, T)) {
      // ...then we can prove that `barWellFormed(T)` holds.
      barWellFormed(T)
    }
  }.
</code></pre>
<p>This notation I'm using here is the notation I've been using in my
prototype implementation; it's similar to standard mathematical
notation but a bit Rustified. Anyway, the problem is that standard
Horn clauses don't allow universal quantification (<code>forall</code>) or
implication (<code>if</code>) in goals (though many Prolog engines do support
them, as an extension). For this reason, we need to accept something
called &quot;first-order hereditary harrop&quot; (FOHH) clauses – this long
name basically means &quot;standard Horn clauses with <code>forall</code> and <code>if</code> in
the body&quot;. But it's nice to know the proper name, because there is a
lot of work describing how to efficiently handle FOHH clauses; see for
example Gopalan Nadathur's excellent
<a href="./bibliography.html#pphhf">&quot;A Proof Procedure for the Logic of Hereditary Harrop Formulas&quot;</a>
in <a href="./bibliography.html">the bibliography</a>.</p>
<p>It turns out that supporting FOHH is not really all that hard. And
once we are able to do that, we can easily describe the type-checking
rule for generic functions like <code>foo</code> in our logic.</p>
<h2><a class="header" href="#source" id="source">Source</a></h2>
<p>This page is a lightly adapted version of a
<a href="https://smallcultfollowing.com/babysteps/blog/2017/01/26/lowering-rust-traits-to-logic/">blog post by Nicholas Matsakis</a>.</p>
<h1><a class="header" href="#goals-and-clauses" id="goals-and-clauses">Goals and clauses</a></h1>
<p>In logic programming terms, a <strong>goal</strong> is something that you must
prove and a <strong>clause</strong> is something that you know is true. As
described in the <a href="clauses/../clauses.html">lowering to logic</a>
chapter, Rust's trait solver is based on an extension of hereditary
harrop (HH) clauses, which extend traditional Prolog Horn clauses with
a few new superpowers.</p>
<h2><a class="header" href="#goals-and-clauses-meta-structure" id="goals-and-clauses-meta-structure">Goals and clauses meta structure</a></h2>
<p>In Rust's solver, <strong>goals</strong> and <strong>clauses</strong> have the following forms
(note that the two definitions reference one another):</p>
<pre><code class="language-text">Goal = DomainGoal           // defined in the section below
        | Goal &amp;&amp; Goal
        | Goal || Goal
        | exists&lt;K&gt; { Goal }   // existential quantification
        | forall&lt;K&gt; { Goal }   // universal quantification
        | if (Clause) { Goal } // implication
        | true                 // something that's trivially true
        | ambiguous            // something that's never provable

Clause = DomainGoal
        | Clause :- Goal     // if can prove Goal, then Clause is true
        | Clause &amp;&amp; Clause
        | forall&lt;K&gt; { Clause }

K = &lt;type&gt;     // a &quot;kind&quot;
    | &lt;lifetime&gt;
</code></pre>
<p>The proof procedure for these sorts of goals is actually quite
straightforward.  Essentially, it's a form of depth-first search. The
paper
<a href="clauses/../bibliography.html#pphhf">&quot;A Proof Procedure for the Logic of Hereditary Harrop Formulas&quot;</a>
gives the details.</p>
<p>In terms of code, these types are defined in
<a href="https://github.com/rust-lang/rust/blob/master/compiler/rustc_middle/src/traits/mod.rs"><code>compiler/rustc_middle/src/traits/mod.rs</code></a> in rustc, and in
<a href="https://github.com/rust-lang/chalk/blob/master/chalk-ir/src/lib.rs"><code>chalk-ir/src/lib.rs</code></a> in chalk.</p>
<p><a name="domain-goals"></a></p>
<h2><a class="header" href="#domain-goals" id="domain-goals">Domain goals</a></h2>
<p><em>Domain goals</em> are the atoms of the trait logic. As can be seen in the
definitions given above, general goals basically consist in a combination of
domain goals.</p>
<p>Moreover, flattening a bit the definition of clauses given previously, one can
see that clauses are always of the form:</p>
<pre><code class="language-text">forall&lt;K1, ..., Kn&gt; { DomainGoal :- Goal }
</code></pre>
<p>hence domain goals are in fact clauses' LHS. That is, at the most granular level,
domain goals are what the trait solver will end up trying to prove.</p>
<p><a name="trait-ref"></a></p>
<p>To define the set of domain goals in our system, we need to first
introduce a few simple formulations. A <strong>trait reference</strong> consists of
the name of a trait along with a suitable set of inputs P0..Pn:</p>
<pre><code class="language-text">TraitRef = P0: TraitName&lt;P1..Pn&gt;
</code></pre>
<p>So, for example, <code>u32: Display</code> is a trait reference, as is <code>Vec&lt;T&gt;: IntoIterator</code>. Note that Rust surface syntax also permits some extra
things, like associated type bindings (<code>Vec&lt;T&gt;: IntoIterator&lt;Item = T&gt;</code>), that are not part of a trait reference.</p>
<p><a name="projection"></a></p>
<p>A <strong>projection</strong> consists of an associated item reference along with
its inputs P0..Pm:</p>
<pre><code class="language-text">Projection = &lt;P0 as TraitName&lt;P1..Pn&gt;&gt;::AssocItem&lt;Pn+1..Pm&gt;
</code></pre>
<p>Given these, we can define a <code>DomainGoal</code> as follows:</p>
<pre><code class="language-text">DomainGoal = Holds(WhereClause)
            | FromEnv(TraitRef)
            | FromEnv(Type)
            | WellFormed(TraitRef)
            | WellFormed(Type)
            | Normalize(Projection -&gt; Type)

WhereClause = Implemented(TraitRef)
            | AliasEq(Projection = Type)
            | Outlives(Type: Region)
            | Outlives(Region: Region)
</code></pre>
<p><code>WhereClause</code> refers to a <code>where</code> clause that a Rust user would actually be able
to write in a Rust program. This abstraction exists only as a convenience as we
sometimes want to only deal with domain goals that are effectively writable in
Rust.</p>
<p>Let's break down each one of these, one-by-one.</p>
<h4><a class="header" href="#implementedtraitref" id="implementedtraitref">Implemented(TraitRef)</a></h4>
<p>e.g. <code>Implemented(i32: Copy)</code></p>
<p>True if the given trait is implemented for the given input types and lifetimes.</p>
<h4><a class="header" href="#aliaseqprojection--type" id="aliaseqprojection--type">AliasEq(Projection = Type)</a></h4>
<p>e.g. <code>AliasEq&lt;T as Iterator&gt;::Item = u8</code></p>
<p>The given associated type <code>Projection</code> is equal to <code>Type</code>; this can be proved
with either normalization or using placeholder associated types and is handled
as a special kind of type aliases. See
<a href="clauses/./type_equality.html">the section on associated types</a>.</p>
<h4><a class="header" href="#normalizeprojection---type" id="normalizeprojection---type">Normalize(Projection -&gt; Type)</a></h4>
<p>e.g. <code>Normalize&lt;T as Iterator&gt;::Item -&gt; u8</code></p>
<p>The given associated type <code>Projection</code> can be <a href="clauses/./type_equality.html#normalize">normalized</a> to <code>Type</code>.</p>
<p>As discussed in <a href="clauses/./type_equality.html">the section on associated
types</a>, <code>Normalize</code> implies <code>AliasEq</code>,
but not vice versa. In general, proving <code>Normalize(&lt;T as Trait&gt;::Item -&gt; U)</code>
also requires proving <code>Implemented(T: Trait)</code>.</p>
<h4><a class="header" href="#fromenvtraitref" id="fromenvtraitref">FromEnv(TraitRef)</a></h4>
<p>e.g. <code>FromEnv(Self: Add&lt;i32&gt;)</code></p>
<p>True if the inner <code>TraitRef</code> is <em>assumed</em> to be true,
that is, if it can be derived from the in-scope where clauses.</p>
<p>For example, given the following function:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn loud_clone&lt;T: Clone&gt;(stuff: &amp;T) -&gt; T {
    println!(&quot;cloning!&quot;);
    stuff.clone()
}
<span class="boring">}
</span></code></pre></pre>
<p>Inside the body of our function, we would have <code>FromEnv(T: Clone)</code>. In-scope
where clauses nest, so a function body inside an impl body inherits the
impl body's where clauses, too.</p>
<p>This and the next rule are used to implement <a href="clauses/./lowering_rules.html#implied-bounds">implied bounds</a>. As we'll see
in the section on lowering, <code>FromEnv(TraitRef)</code> implies <code>Implemented(TraitRef)</code>,
but not vice versa. This distinction is crucial to implied bounds.</p>
<h4><a class="header" href="#fromenvtype" id="fromenvtype">FromEnv(Type)</a></h4>
<p>e.g. <code>FromEnv(HashSet&lt;K&gt;)</code></p>
<p>True if the inner <code>Type</code> is <em>assumed</em> to be well-formed, that is, if it is an
input type of a function or an impl.</p>
<p>For example, given the following code:</p>
<pre><code class="language-rust ignore">struct HashSet&lt;K&gt; where K: Hash { ... }

fn loud_insert&lt;K&gt;(set: &amp;mut HashSet&lt;K&gt;, item: K) {
    println!(&quot;inserting!&quot;);
    set.insert(item);
}
</code></pre>
<p><code>HashSet&lt;K&gt;</code> is an input type of the <code>loud_insert</code> function. Hence, we assume it
to be well-formed, so we would have <code>FromEnv(HashSet&lt;K&gt;)</code> inside the body of our
function. As we'll see in the section on lowering, <code>FromEnv(HashSet&lt;K&gt;)</code> implies
<code>Implemented(K: Hash)</code> because the
<code>HashSet</code> declaration was written with a <code>K: Hash</code> where clause. Hence, we don't
need to repeat that bound on the <code>loud_insert</code> function: we rather automatically
assume that it is true.</p>
<h4><a class="header" href="#wellformeditem" id="wellformeditem">WellFormed(Item)</a></h4>
<p>These goals imply that the given item is <em>well-formed</em>.</p>
<p>We can talk about different types of items being well-formed:</p>
<ul>
<li>
<p><em>Types</em>, like <code>WellFormed(Vec&lt;i32&gt;)</code>, which is true in Rust, or
<code>WellFormed(Vec&lt;str&gt;)</code>, which is not (because <code>str</code> is not <code>Sized</code>.)</p>
</li>
<li>
<p><em>TraitRefs</em>, like <code>WellFormed(Vec&lt;i32&gt;: Clone)</code>.</p>
</li>
</ul>
<p>Well-formedness is important to <a href="clauses/./lowering_rules.html#implied-bounds">implied bounds</a>. In particular, the reason
it is okay to assume <code>FromEnv(T: Clone)</code> in the <code>loud_clone</code> example is that we
<em>also</em> verify <code>WellFormed(T: Clone)</code> for each call site of <code>loud_clone</code>.
Similarly, it is okay to assume <code>FromEnv(HashSet&lt;K&gt;)</code> in the <code>loud_insert</code>
example because we will verify <code>WellFormed(HashSet&lt;K&gt;)</code> for each call site of
<code>loud_insert</code>. </p>
<h4><a class="header" href="#outlivestype-region-outlivesregion-region" id="outlivestype-region-outlivesregion-region">Outlives(Type: Region), Outlives(Region: Region)</a></h4>
<p>e.g. <code>Outlives(&amp;'a str: 'b)</code>, <code>Outlives('a: 'static)</code></p>
<p>True if the given type or region on the left outlives the right-hand region.</p>
<p><a name="coinductive"></a></p>
<h2><a class="header" href="#coinductive-goals" id="coinductive-goals">Coinductive goals</a></h2>
<p>Most goals in our system are &quot;inductive&quot;. In an inductive goal,
circular reasoning is disallowed. Consider this example clause:</p>
<pre><code class="language-text">    Implemented(Foo: Bar) :-
        Implemented(Foo: Bar).
</code></pre>
<p>Considered inductively, this clause is useless: if we are trying to
prove <code>Implemented(Foo: Bar)</code>, we would then recursively have to prove
<code>Implemented(Foo: Bar)</code>, and that cycle would continue ad infinitum
(the trait solver will terminate here, it would just consider that
<code>Implemented(Foo: Bar)</code> is not known to be true).</p>
<p>However, some goals are <em>co-inductive</em>. Simply put, this means that
cycles are OK. So, if <code>Bar</code> were a co-inductive trait, then the rule
above would be perfectly valid, and it would indicate that
<code>Implemented(Foo: Bar)</code> is true.</p>
<p><em>Auto traits</em> are one example in Rust where co-inductive goals are used.
Consider the <code>Send</code> trait, and imagine that we have this struct:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    next: Option&lt;Box&lt;Foo&gt;&gt;
}
<span class="boring">}
</span></code></pre></pre>
<p>The default rules for auto traits say that <code>Foo</code> is <code>Send</code> if the
types of its fields are <code>Send</code>. Therefore, we would have a rule like</p>
<pre><code class="language-text">Implemented(Foo: Send) :-
    Implemented(Option&lt;Box&lt;Foo&gt;&gt;: Send).
</code></pre>
<p>As you can probably imagine, proving that <code>Option&lt;Box&lt;Foo&gt;&gt;: Send</code> is
going to wind up circularly requiring us to prove that <code>Foo: Send</code>
again. So this would be an example where we wind up in a cycle – but
that's ok, we <em>do</em> consider <code>Foo: Send</code> to hold, even though it
references itself.</p>
<p>In general, co-inductive traits are used in Rust trait solving when we
want to enumerate a fixed set of possibilities. In the case of auto
traits, we are enumerating the set of reachable types from a given
starting point (i.e., <code>Foo</code> can reach values of type
<code>Option&lt;Box&lt;Foo&gt;&gt;</code>, which implies it can reach values of type
<code>Box&lt;Foo&gt;</code>, and then of type <code>Foo</code>, and then the cycle is complete).</p>
<p>In addition to auto traits, <code>WellFormed</code> predicates are co-inductive.
These are used to achieve a similar &quot;enumerate all the cases&quot; pattern,
as described in the section on <a href="clauses/./lowering_rules.html#implied-bounds">implied bounds</a>.</p>
<h1><a class="header" href="#type-equality-and-unification" id="type-equality-and-unification">Type equality and unification</a></h1>
<p>This section covers how the trait system handles equality between
associated types. The full system consists of several moving parts,
which we will introduce one by one:</p>
<ul>
<li>Projection and the <code>Normalize</code> predicate</li>
<li>Placeholder associated type projections</li>
<li>The <code>AliasEq</code> predicate</li>
<li>Integration with unification</li>
</ul>
<h2><a class="header" href="#associated-type-projection-and-normalization" id="associated-type-projection-and-normalization">Associated type projection and normalization</a></h2>
<p>When a trait defines an associated type (e.g.,
<a href="https://doc.rust-lang.org/nightly/core/iter/trait.IntoIterator.html#associatedtype.Item">the <code>Item</code> type in the <code>IntoIterator</code> trait</a>), that
type can be referenced by the user using an <strong>associated type
projection</strong> like <code>&lt;Option&lt;u32&gt; as IntoIterator&gt;::Item</code>.</p>
<blockquote>
<p>Often, people will use the shorthand syntax <code>T::Item</code>. Presently, that
syntax is expanded during <a href="https://rustc-dev-guide.rust-lang.org/type-checking.html">&quot;type collection&quot;</a> into the
explicit form, though that is something we may want to change in the future.</p>
</blockquote>
<p><a name="normalize"></a></p>
<p>In some cases, associated type projections can be <strong>normalized</strong> –
that is, simplified – based on the types given in an impl. So, to
continue with our example, the impl of <code>IntoIterator</code> for <code>Option&lt;T&gt;</code>
declares (among other things) that <code>Item = T</code>:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; IntoIterator for Option&lt;T&gt; {
  type Item = T;
  ...
}
</code></pre>
<p>This means we can normalize the projection <code>&lt;Option&lt;u32&gt; as IntoIterator&gt;::Item</code> to just <code>u32</code>.</p>
<p>In this case, the projection was a &quot;monomorphic&quot; one – that is, it
did not have any type parameters.  Monomorphic projections are special
because they can <strong>always</strong> be fully normalized.</p>
<p>Often, we can normalize other associated type projections as well. For
example, <code>&lt;Option&lt;?T&gt; as IntoIterator&gt;::Item</code>, where <code>?T</code> is an inference
variable, can be normalized to just <code>?T</code>.</p>
<p>In our logic, normalization is defined by a predicate
<code>Normalize</code>. The <code>Normalize</code> clauses arise only from
impls. For example, the <code>impl</code> of <code>IntoIterator</code> for <code>Option&lt;T&gt;</code> that
we saw above would be lowered to a program clause like so:</p>
<pre><code class="language-text">forall&lt;T&gt; {
    Normalize(&lt;Option&lt;T&gt; as IntoIterator&gt;::Item -&gt; T) :-
        Implemented(Option&lt;T&gt;: IntoIterator)
}
</code></pre>
<p>where in this case, the one <code>Implemented</code> condition is always true.</p>
<blockquote>
<p>Since we do not permit quantification over traits, this is really more like
a family of program clauses, one for each associated type.</p>
</blockquote>
<p>We could apply that rule to normalize either of the examples that
we've seen so far.</p>
<h2><a class="header" href="#placeholder-associated-types" id="placeholder-associated-types">Placeholder associated types</a></h2>
<p>Sometimes however we want to work with associated types that cannot be
normalized. For example, consider this function:</p>
<pre><code class="language-rust ignore">fn foo&lt;T: IntoIterator&gt;(...) { ... }
</code></pre>
<p>In this context, how would we normalize the type <code>T::Item</code>?</p>
<p>Without knowing what <code>T</code> is, we can't really do so. To represent this case,
we introduce a type called a <strong>placeholder associated type projection</strong>. This
is written like so: <code>(IntoIterator::Item)&lt;T&gt;</code>.</p>
<p>You may note that it looks a lot like a regular type (e.g., <code>Option&lt;T&gt;</code>),
except that the &quot;name&quot; of the type is <code>(IntoIterator::Item)</code>. This is not an
accident: placeholder associated type projections work just like ordinary
types like <code>Vec&lt;T&gt;</code> when it comes to unification. That is, they are only
considered equal if (a) they are both references to the same associated type,
like <code>IntoIterator::Item</code> and (b) their type arguments are equal.</p>
<p>Placeholder associated types are never written directly by the user.
They are used internally by the trait system only, as we will see
shortly.</p>
<p>In rustc, they correspond to the <code>TyKind::UnnormalizedProjectionTy</code> enum
variant, declared in <a href="https://github.com/rust-lang/rust/blob/master/compiler/rustc_middle/src/ty/sty.rs"><code>compiler/rustc_middle/src/ty/sty.rs</code></a>. In chalk, we use an
<code>AssociatedType</code>.</p>
<h2><a class="header" href="#projection-equality" id="projection-equality">Projection equality</a></h2>
<p>So far we have seen two ways to answer the question of &quot;When can we
consider an associated type projection equal to another type?&quot;:</p>
<ul>
<li>the <code>Normalize</code> predicate could be used to transform projections when we
knew which impl applied;</li>
<li><strong>placeholder</strong> associated types can be used when we don't. This is also
known as <strong>lazy normalization</strong>.</li>
</ul>
<p>These two cases are brought together by the <code>AliasEq</code> predicate introduced 
<a href="clauses/../types/rust_types/alias.html">before</a> (where the <a href="https://rust-lang.github.io/chalk/chalk_ir/enum.AliasTy.html"><code>AliasTy</code></a> is <code>Projection</code>). The instantiated predicate for projection 
equality looks then like so:</p>
<pre><code class="language-text">AliasEq(&lt;T as IntoIterator&gt;::Item = U)
</code></pre>
<p>and we will see that it can be proven <em>either</em> via normalization or
via the placeholder type. As part of lowering an associated type declaration from
some trait, we create two program clauses for <code>AliasEq</code>:</p>
<pre><code class="language-text">forall&lt;T, U&gt; {
    AliasEq(&lt;T as IntoIterator&gt;::Item = U) :-
        Normalize(&lt;T as IntoIterator&gt;::Item -&gt; U)
}

forall&lt;T&gt; {
    AliasEq(&lt;T as IntoIterator&gt;::Item = (IntoIterator::Item)&lt;T&gt;)
}
</code></pre>
<p>These are the only two <code>AliasEq</code> program clauses we ever make for
any given associated item.</p>
<h2><a class="header" href="#integration-with-unification" id="integration-with-unification">Integration with unification</a></h2>
<p>Now we are ready to discuss how associated type equality integrates
with unification. As described in the
<a href="https://rustc-dev-guide.rust-lang.org/type-inference.html">type inference</a>
section, unification is basically a procedure with a signature like this:</p>
<pre><code class="language-text">Unify(A, B) = Result&lt;Subgoals, NoSolution&gt;
</code></pre>
<p>In other words, we try to unify two things A and B. That procedure
might just fail, in which case we get back <code>Err(NoSolution)</code>. This
would happen, for example, if we tried to unify <code>u32</code> and <code>i32</code>.</p>
<p>The key point is that, on success, unification can also give back to
us a set of subgoals that still remain to be proven.</p>
<p>Whenever unification encounters a non-placeholder associated type
projection P being equated with some other type T, it always succeeds,
but it produces a subgoal <code>AliasEq(P = T)</code> that is propagated
back up. Thus it falls to the ordinary workings of the trait system
to process that constraint.</p>
<blockquote>
<p>If we unify two projections P1 and P2, then unification produces a
variable X and asks us to prove that <code>AliasEq(P1 = X)</code> and
<code>AliasEq(P2 = X)</code>. (That used to be needed in an older system to
prevent cycles; I rather doubt it still is. -nmatsakis)</p>
</blockquote>
<h1><a class="header" href="#implied-bounds" id="implied-bounds">Implied Bounds</a></h1>
<p>Implied bounds remove the need to repeat where clauses written on
a type declaration or a trait declaration. For example, say we have the
following type declaration:</p>
<pre><code class="language-rust ignore">struct HashSet&lt;K: Hash&gt; {
    ...
}
</code></pre>
<p>then everywhere we use <code>HashSet&lt;K&gt;</code> as an &quot;input&quot; type, that is appearing in
the receiver type of an <code>impl</code> or in the arguments of a function, we don't
want to have to repeat the <code>where K: Hash</code> bound, as in:</p>
<pre><code class="language-rust ignore">// I don't want to have to repeat `where K: Hash` here.
impl&lt;K&gt; HashSet&lt;K&gt; {
    ...
}

// Same here.
fn loud_insert&lt;K&gt;(set: &amp;mut HashSet&lt;K&gt;, item: K) {
    println!(&quot;inserting!&quot;);
    set.insert(item);
}
</code></pre>
<p>Note that in the <code>loud_insert</code> example, <code>HashSet&lt;K&gt;</code> is not the type
of the <code>set</code> argument of <code>loud_insert</code>, it only <em>appears</em> in the
argument type <code>&amp;mut HashSet&lt;K&gt;</code>: we care about every type appearing
in the function's header (the header is the signature without the return type),
not only types of the function's arguments.</p>
<p>The rationale for applying implied bounds to input types is that, for example,
in order to call the <code>loud_insert</code> function above, the programmer must have
<em>produced</em> the type <code>HashSet&lt;K&gt;</code> already, hence the compiler already verified
that <code>HashSet&lt;K&gt;</code> was well-formed, i.e. that <code>K</code> effectively implemented
<code>Hash</code>, as in the following example:</p>
<pre><code class="language-rust ignore">fn main() {
    // I am producing a value of type `HashSet&lt;i32&gt;`.
    // If `i32` was not `Hash`, the compiler would report an error here.
    let set: HashSet&lt;i32&gt; = HashSet::new();
    loud_insert(&amp;mut set, 5);
}
</code></pre>
<p>Hence, we don't want to repeat where clauses for input types because that would
sort of duplicate the work of the programmer, having to verify that their types
are well-formed both when calling the function and when using them in the
arguments of their function. The same reasoning applies when using an <code>impl</code>.</p>
<p>Similarly, given the following trait declaration:</p>
<pre><code class="language-rust ignore">trait Copy where Self: Clone { // desugared version of `Copy: Clone`
    ...
}
</code></pre>
<p>then everywhere we bound over <code>SomeType: Copy</code>, we would like to be able to
use the fact that <code>SomeType: Clone</code> without having to write it explicitly,
as in:</p>
<pre><code class="language-rust ignore">fn loud_clone&lt;T: Clone&gt;(x: T) {
    println!(&quot;cloning!&quot;);
    x.clone();
}

fn fun_with_copy&lt;T: Copy&gt;(x: T) {
    println!(&quot;will clone a `Copy` type soon...&quot;);

    // I'm using `loud_clone&lt;T: Clone&gt;` with `T: Copy`, I know this
    // implies `T: Clone` so I don't want to have to write it explicitly.
    loud_clone(x);
}
</code></pre>
<p>The rationale for implied bounds for traits is that if a type implements
<code>Copy</code>, that is, if there exists an <code>impl Copy</code> for that type, there <em>ought</em>
to exist an <code>impl Clone</code> for that type, otherwise the compiler would have
reported an error in the first place. So again, if we were forced to repeat the
additional <code>where SomeType: Clone</code> everywhere whereas we already know that
<code>SomeType: Copy</code> hold, we would kind of duplicate the verification work.</p>
<p>Implied bounds are not yet completely enforced in rustc, at the moment it only
works for outlive requirements, super trait bounds, and bounds on associated
types. The full RFC can be found <a href="https://github.com/rust-lang/rfcs/blob/master/text/2089-implied-bounds.md">here</a>. We'll give here a brief view
of how implied bounds work and why we chose to implement it that way. The
complete set of lowering rules can be found in the corresponding
<a href="clauses/./lowering_rules.html">chapter</a>.</p>
<h2><a class="header" href="#implied-bounds-and-lowering-rules" id="implied-bounds-and-lowering-rules">Implied bounds and lowering rules</a></h2>
<p>Now we need to express implied bounds in terms of logical rules. We will start
with exposing a naive way to do it. Suppose that we have the following traits:</p>
<pre><code class="language-rust ignore">trait Foo {
    ...
}

trait Bar where Self: Foo {
    ...
}
</code></pre>
<p>So we would like to say that if a type implements <code>Bar</code>, then necessarily
it must also implement <code>Foo</code>. We might think that a clause like this would
work:</p>
<pre><code class="language-text">forall&lt;Type&gt; {
    Implemented(Type: Foo) :- Implemented(Type: Bar).
}
</code></pre>
<p>Now suppose that we just write this impl:</p>
<pre><code class="language-rust ignore">struct X;

impl Bar for X { }
</code></pre>
<p>Clearly this should not be allowed: indeed, we wrote a <code>Bar</code> impl for <code>X</code>, but
the <code>Bar</code> trait requires that we also implement <code>Foo</code> for <code>X</code>, which we never
did. In terms of what the compiler does, this would look like this:</p>
<pre><code class="language-rust ignore">struct X;

impl Bar for X {
    // We are in a `Bar` impl for the type `X`.
    // There is a `where Self: Foo` bound on the `Bar` trait declaration.
    // Hence I need to prove that `X` also implements `Foo` for that impl
    // to be legal.
}
</code></pre>
<p>So the compiler would try to prove <code>Implemented(X: Foo)</code>. Of course it will
not find any <code>impl Foo for X</code> since we did not write any. However, it
will see our implied bound clause:</p>
<pre><code class="language-text">forall&lt;Type&gt; {
    Implemented(Type: Foo) :- Implemented(Type: Bar).
}
</code></pre>
<p>so that it may be able to prove <code>Implemented(X: Foo)</code> if <code>Implemented(X: Bar)</code>
holds. And it turns out that <code>Implemented(X: Bar)</code> does hold since we wrote
a <code>Bar</code> impl for <code>X</code>! Hence the compiler will accept the <code>Bar</code> impl while it
should not.</p>
<h2><a class="header" href="#implied-bounds-coming-from-the-environment" id="implied-bounds-coming-from-the-environment">Implied bounds coming from the environment</a></h2>
<p>So the naive approach does not work. What we need to do is to somehow decouple
implied bounds from impls. Suppose we know that a type <code>SomeType&lt;...&gt;</code>
implements <code>Bar</code> and we want to deduce that <code>SomeType&lt;...&gt;</code> must also implement
<code>Foo</code>.</p>
<p>There are two possibilities: first, we have enough information about
<code>SomeType&lt;...&gt;</code> to see that there exists a <code>Bar</code> impl in the program which
covers <code>SomeType&lt;...&gt;</code>, for example a plain <code>impl&lt;...&gt; Bar for SomeType&lt;...&gt;</code>.
Then if the compiler has done its job correctly, there <em>must</em> exist a <code>Foo</code>
impl which covers <code>SomeType&lt;...&gt;</code>, e.g. another plain
<code>impl&lt;...&gt; Foo for SomeType&lt;...&gt;</code>. In that case then, we can just use this
impl and we do not need implied bounds at all.</p>
<p>Second possibility: we do not know enough about <code>SomeType&lt;...&gt;</code> in order to
find a <code>Bar</code> impl which covers it, for example if <code>SomeType&lt;...&gt;</code> is just
a type parameter in a function:</p>
<pre><code class="language-rust ignore">fn foo&lt;T: Bar&gt;() {
    // We'd like to deduce `Implemented(T: Foo)`.
}
</code></pre>
<p>That is, the information that <code>T</code> implements <code>Bar</code> here comes from the
<em>environment</em>. The environment is the set of things that we assume to be true
when we type check some Rust declaration. In that case, what we assume is that
<code>T: Bar</code>. Then at that point, we might authorize ourselves to have some kind
of  &quot;local&quot; implied bound reasoning which would say
<code>Implemented(T: Foo) :- Implemented(T: Bar)</code>. This reasoning would
only be done within our <code>foo</code> function in order to avoid the earlier
problem where we had a global clause.</p>
<p>We can apply this local reasoning everywhere we can have an environment
-- i.e. when we can write where clauses -- that is, inside impls,
trait declarations, and type declarations.</p>
<h2><a class="header" href="#computing-implied-bounds-with-fromenv" id="computing-implied-bounds-with-fromenv">Computing implied bounds with <code>FromEnv</code></a></h2>
<p>The previous subsection showed that it was only useful to compute implied
bounds for facts coming from the environment.
We talked about &quot;local&quot; rules, but there are multiple possible strategies to
indeed implement the locality of implied bounds.</p>
<p>In rustc, the current strategy is to <em>elaborate</em> bounds: that is, each time
we have a fact in the environment, we recursively derive all the other things
that are implied by this fact until we reach a fixed point. For example, if
we have the following declarations:</p>
<pre><code class="language-rust ignore">trait A { }
trait B where Self: A { }
trait C where Self: B { }

fn foo&lt;T: C&gt;() {
    ...
}
</code></pre>
<p>then inside the <code>foo</code> function, we start with an environment containing only
<code>Implemented(T: C)</code>. Then because of implied bounds for the <code>C</code> trait, we
elaborate <code>Implemented(T: B)</code> and add it to our environment. Because of
implied bounds for the <code>B</code> trait, we elaborate <code>Implemented(T: A)</code>and add it
to our environment as well. We cannot elaborate anything else, so we conclude
that our final environment consists of <code>Implemented(T: A + B + C)</code>.</p>
<p>In the new-style trait system, we like to encode as many things as possible
with logical rules. So rather than &quot;elaborating&quot;, we have a set of <em>global</em>
program clauses defined like so:</p>
<pre><code class="language-text">forall&lt;T&gt; { Implemented(T: A) :- FromEnv(T: A). }

forall&lt;T&gt; { Implemented(T: B) :- FromEnv(T: B). }
forall&lt;T&gt; { FromEnv(T: A) :- FromEnv(T: B). }

forall&lt;T&gt; { Implemented(T: C) :- FromEnv(T: C). }
forall&lt;T&gt; { FromEnv(T: B) :- FromEnv(T: C). }
</code></pre>
<p>So these clauses are defined globally (that is, they are available from
everywhere in the program) but they cannot be used because the hypothesis
is always of the form <code>FromEnv(...)</code> which is a bit special. Indeed, as
indicated by the name, <code>FromEnv(...)</code> facts can <strong>only</strong> come from the
environment.
How it works is that in the <code>foo</code> function, instead of having an environment
containing <code>Implemented(T: C)</code>, we replace this environment with
<code>FromEnv(T: C)</code>. From here and thanks to the above clauses, we see that we
are able to reach any of <code>Implemented(T: A)</code>, <code>Implemented(T: B)</code> or
<code>Implemented(T: C)</code>, which is what we wanted.</p>
<h2><a class="header" href="#implied-bounds-and-well-formedness-checking" id="implied-bounds-and-well-formedness-checking">Implied bounds and well-formedness checking</a></h2>
<p>Implied bounds are tightly related with well-formedness checking.
Well-formedness checking is the process of checking that the impls the
programmer wrote are legal, what we referred to earlier as &quot;the compiler doing
its job correctly&quot;.</p>
<p>We already saw examples of illegal and legal impls:</p>
<pre><code class="language-rust ignore">trait Foo { }
trait Bar where Self: Foo { }

struct X;
struct Y;

impl Bar for X {
    // This impl is not legal: the `Bar` trait requires that we also
    // implement `Foo`, and we didn't.
}

impl Foo for Y {
    // This impl is legal: there is nothing to check as there are no where
    // clauses on the `Foo` trait.
}

impl Bar for Y {
    // This impl is legal: we have a `Foo` impl for `Y`.
}
</code></pre>
<p>We must define what &quot;legal&quot; and &quot;illegal&quot; mean. For this, we introduce another
predicate: <code>WellFormed(Type: Trait)</code>. We say that the trait reference
<code>Type: Trait</code> is well-formed if <code>Type</code> meets the bounds written on the
<code>Trait</code> declaration. For each impl we write, assuming that the where clauses
declared on the impl hold, the compiler tries to prove that the corresponding
trait reference is well-formed. The impl is legal if the compiler manages to do
so.</p>
<p>Coming to the definition of <code>WellFormed(Type: Trait)</code>, it would be tempting
to define it as:</p>
<pre><code class="language-rust ignore">trait Trait where WC1, WC2, ..., WCn {
    ...
}
</code></pre>
<pre><code class="language-text">forall&lt;Type&gt; {
    WellFormed(Type: Trait) :- WC1 &amp;&amp; WC2 &amp;&amp; .. &amp;&amp; WCn.
}
</code></pre>
<p>and indeed this was basically what was done in rustc until it was noticed that
this mixed badly with implied bounds. The key thing is that implied bounds
allows someone to derive all bounds implied by a fact in the environment, and
this <em>transitively</em> as we've seen with the <code>A + B + C</code> traits example.
However, the <code>WellFormed</code> predicate as defined above only checks that the
<em>direct</em> superbounds hold. That is, if we come back to our <code>A + B + C</code>
example:</p>
<pre><code class="language-rust ignore">trait A { }
// No where clauses, always well-formed.
// forall&lt;Type&gt; { WellFormed(Type: A). }

trait B where Self: A { }
// We only check the direct superbound `Self: A`.
// forall&lt;Type&gt; { WellFormed(Type: B) :- Implemented(Type: A). }

trait C where Self: B { }
// We only check the direct superbound `Self: B`. We do not check
// the `Self: A` implied bound  coming from the `Self: B` superbound.
// forall&lt;Type&gt; { WellFormed(Type: C) :- Implemented(Type: B). }
</code></pre>
<p>There is an asymmetry between the recursive power of implied bounds and
the shallow checking of <code>WellFormed</code>. It turns out that this asymmetry
can be <a href="https://github.com/rust-lang/rust/pull/43786">exploited</a>. Indeed, suppose that we define the following
traits:</p>
<pre><code class="language-rust ignore">trait Partial where Self: Copy { }
// WellFormed(Self: Partial) :- Implemented(Self: Copy).

trait Complete where Self: Partial { }
// WellFormed(Self: Complete) :- Implemented(Self: Partial).

impl&lt;T&gt; Partial for T where T: Complete { }

impl&lt;T&gt; Complete for T { }
</code></pre>
<p>For the <code>Partial</code> impl, what the compiler must prove is:</p>
<pre><code class="language-text">forall&lt;T&gt; {
    if (T: Complete) { // assume that the where clauses hold
        WellFormed(T: Partial) // show that the trait reference is well-formed
    }
}
</code></pre>
<p>Proving <code>WellFormed(T: Partial)</code> amounts to proving <code>Implemented(T: Copy)</code>.
However, we have <code>Implemented(T: Complete)</code> in our environment: thanks to
implied bounds, we can deduce <code>Implemented(T: Partial)</code>. Using implied bounds
one level deeper, we can deduce <code>Implemented(T: Copy)</code>. Finally, the <code>Partial</code>
impl is legal.</p>
<p>For the <code>Complete</code> impl, what the compiler must prove is:</p>
<pre><code class="language-text">forall&lt;T&gt; {
    WellFormed(T: Complete) // show that the trait reference is well-formed
}
</code></pre>
<p>Proving <code>WellFormed(T: Complete)</code> amounts to proving <code>Implemented(T: Partial)</code>.
We see that the <code>impl Partial for T</code> applies if we can prove
<code>Implemented(T: Complete)</code>, and it turns out we can prove this fact since our
<code>impl&lt;T&gt; Complete for T</code> is a blanket impl without any where clauses.</p>
<p>So both impls are legal and the compiler accepts the program. Moreover, thanks
to the <code>Complete</code> blanket impl, all types implement <code>Complete</code>. So we could
now use this impl like so:</p>
<pre><code class="language-rust ignore">fn eat&lt;T&gt;(x: T) { }

fn copy_everything&lt;T: Complete&gt;(x: T) {
    eat(x);
    eat(x);
}

fn main() {
    let not_copiable = vec![1, 2, 3, 4];
    copy_everything(not_copiable);
}
</code></pre>
<p>In this program, we use the fact that <code>Vec&lt;i32&gt;</code> implements <code>Complete</code>, as any
other type. Hence we can call <code>copy_everything</code> with an argument of type
<code>Vec&lt;i32&gt;</code>. Inside the <code>copy_everything</code> function, we have the
<code>Implemented(T: Complete)</code> bound in our environment. Thanks to implied bounds,
we can deduce <code>Implemented(T: Partial)</code>. Using implied bounds again, we deduce
<code>Implemented(T: Copy)</code> and we can indeed call the <code>eat</code> function which moves
the argument twice since its argument is <code>Copy</code>. Problem: the <code>T</code> type was
in fact <code>Vec&lt;i32&gt;</code> which is not copy at all, hence we will double-free the
underlying vec storage so we have a memory unsoundness in safe Rust.</p>
<p>Of course, disregarding the asymmetry between <code>WellFormed</code> and implied bounds,
this bug was possible only because we had some kind of self-referencing impls.
But self-referencing impls are very useful in practice and are not the real
culprits in this affair.</p>
<h2><a class="header" href="#co-inductiveness-of-wellformed" id="co-inductiveness-of-wellformed">Co-inductiveness of <code>WellFormed</code></a></h2>
<p>So the solution is to fix this asymmetry between <code>WellFormed</code> and implied
bounds. For that, we need for the <code>WellFormed</code> predicate to not only require
that the direct superbounds hold, but also all the bounds transitively implied
by the superbounds. What we can do is to have the following rules for the
<code>WellFormed</code> predicate:</p>
<pre><code class="language-rust ignore">trait A { }
// WellFormed(Self: A) :- Implemented(Self: A).

trait B where Self: A { }
// WellFormed(Self: B) :- Implemented(Self: B) &amp;&amp; WellFormed(Self: A).

trait C where Self: B { }
// WellFormed(Self: C) :- Implemented(Self: C) &amp;&amp; WellFormed(Self: B).
</code></pre>
<p>Notice that we are now also requiring <code>Implemented(Self: Trait)</code> for
<code>WellFormed(Self: Trait)</code> to be true: this is to simplify the process of
traversing all the implied bounds transitively. This does not change anything
when checking whether impls are legal, because since we assume
that the where clauses hold inside the impl, we know that the corresponding
trait reference does hold. Thanks to this setup, you can see that we indeed
require to prove the set of all bounds transitively implied by the where
clauses.</p>
<p>However there is still a catch. Suppose that we have the following trait
definition:</p>
<pre><code class="language-rust ignore">trait Foo where &lt;Self as Foo&gt;::Item: Foo {
    type Item;
}
</code></pre>
<p>so this definition is a bit more involved than the ones we've seen already
because it defines an associated item. However, the well-formedness rule
would not be more complicated:</p>
<pre><code class="language-text">WellFormed(Self: Foo) :-
    Implemented(Self: Foo) &amp;&amp;
    WellFormed(&lt;Self as Foo&gt;::Item: Foo).
</code></pre>
<p>Now we would like to write the following impl:</p>
<pre><code class="language-rust ignore">impl Foo for i32 {
    type Item = i32;
}
</code></pre>
<p>The <code>Foo</code> trait definition and the <code>impl Foo for i32</code> are perfectly valid
Rust: we're kind of recursively using our <code>Foo</code> impl in order to show that
the associated value indeed implements <code>Foo</code>, but that's ok. But if we
translate this to our well-formedness setting, the compiler proof process
inside the <code>Foo</code> impl is the following: it starts with proving that the
well-formedness goal <code>WellFormed(i32: Foo)</code> is true. In order to do that,
it must prove the following goals: <code>Implemented(i32: Foo)</code> and
<code>WellFormed(&lt;i32 as Foo&gt;::Item: Foo)</code>. <code>Implemented(i32: Foo)</code> holds because
there is our impl and there are no where clauses on it so it's always true.
However, because of the associated type value we used,
<code>WellFormed(&lt;i32 as Foo&gt;::Item: Foo)</code> simplifies to just
<code>WellFormed(i32: Foo)</code>. So in order to prove its original goal
<code>WellFormed(i32: Foo)</code>, the compiler needs to prove <code>WellFormed(i32: Foo)</code>:
this clearly is a cycle and cycles are usually rejected by the trait solver,
unless...  if the <code>WellFormed</code> predicate was made to be co-inductive.</p>
<p>A co-inductive predicate, as discussed in the chapter on
<a href="clauses/./goals_and_clauses.html#coinductive-goals">goals and clauses</a>, are predicates
for which the
trait solver accepts cycles. In our setting, this would be a valid thing to do:
indeed, the <code>WellFormed</code> predicate just serves as a way of enumerating all
the implied bounds. Hence, it's like a fixed point algorithm: it tries to grow
the set of implied bounds until there is nothing more to add. Here, a cycle
in the chain of <code>WellFormed</code> predicates just means that there is no more bounds
to add in that direction, so we can just accept this cycle and focus on other
directions. It's easy to prove that under these co-inductive semantics, we
are effectively visiting all the transitive implied bounds, and only these.</p>
<h2><a class="header" href="#implied-bounds-on-types" id="implied-bounds-on-types">Implied bounds on types</a></h2>
<p>We mainly talked about implied bounds for traits, but implied bounds on types
are very similar. Suppose we have the following definition:</p>
<pre><code class="language-rust ignore">struct Type&lt;...&gt; where WC1, ..., WCn {
    ...
}
</code></pre>
<p>To prove that <code>Type&lt;...&gt;</code> is well-formed, we would need to prove a goal of the
form <code>WellFormed(Type&lt;...&gt;).</code>. The <code>WellFormed(Type&lt;...&gt;)</code> predicate is defined
by the rule:</p>
<pre><code class="language-text">forall&lt;...&gt; {
    WellFormed(Type&lt;...&gt;) :- WellFormed(WC1), ..., WellFormed(WCn).
}
</code></pre>
<p>Conversely, if we know a type is well-formed from our environment (for example
because it appears as an argument of one of our functions), we can have implied
bounds thanks to the below set of rules:</p>
<pre><code class="language-text">forall&lt;...&gt; {
    FromEnv(WC1) :- FromEnv(Type&lt;...&gt;).
    ...
    FromEnv(WCn) :- FromEnv(Type&lt;...&gt;).
}
</code></pre>
<p>Looking at the above rules, we see that we can never encounter a chain of
deductions of the form <code>WellFormed(Type&lt;...&gt;) :- ... :- WellFormed(Type&lt;...&gt;)</code>.
So in contrast with traits, the <code>WellFormed(Type&lt;...&gt;)</code> predicate does not need
to be co-inductive.</p>
<h1><a class="header" href="#lowering-rules" id="lowering-rules">Lowering rules</a></h1>
<p>This section gives the complete lowering rules for Rust traits into
<a href="clauses/./goals_and_clauses.html">program clauses</a>. It is a kind of reference. These rules
reference the <a href="clauses/./goals_and_clauses.html#domain-goals">domain goals</a> defined in an earlier section.</p>
<h2><a class="header" href="#notation" id="notation">Notation</a></h2>
<p>The nonterminal <code>Pi</code> is used to mean some generic <em>parameter</em>, either a
named lifetime like <code>'a</code> or a type parameter like <code>A</code>.</p>
<p>The nonterminal <code>Ai</code> is used to mean some generic <em>argument</em>, which
might be a lifetime like <code>'a</code> or a type like <code>Vec&lt;A&gt;</code>.</p>
<p>When defining the lowering rules, we will give goals and clauses in
the <a href="clauses/./goals_and_clauses.html">notation given in this section</a>.
We sometimes insert &quot;macros&quot; like <code>LowerWhereClause!</code> into these
definitions; these macros reference other sections within this chapter.</p>
<h2><a class="header" href="#rule-names-and-cross-references" id="rule-names-and-cross-references">Rule names and cross-references</a></h2>
<p>Each of these lowering rules is given a name, documented with a
comment like so:</p>
<pre><code>// Rule Foo-Bar-Baz
</code></pre>
<p>The reference implementation of these rules is to be found in
<a href="https://github.com/rust-lang/chalk/blob/master/chalk-solve/src/clauses.rs"><code>chalk/chalk-solve/src/clauses.rs</code></a>. They are also ported in
rustc in the <a href="https://github.com/rust-lang/rust/tree/master/compiler/rustc_traits"><code>rustc_traits</code></a> crate.</p>
<h2><a class="header" href="#lowering-where-clauses" id="lowering-where-clauses">Lowering where clauses</a></h2>
<p>When used in a goal position, where clauses can be mapped directly to
the <code>Holds</code> variant of <a href="clauses/./goals_and_clauses.html#domain-goals">domain goals</a>, as follows:</p>
<ul>
<li><code>A0: Foo&lt;A1..An&gt;</code> maps to <code>Implemented(A0: Foo&lt;A1..An&gt;)</code></li>
<li><code>T: 'r</code> maps to <code>Outlives(T, 'r)</code></li>
<li><code>'a: 'b</code> maps to <code>Outlives('a, 'b)</code></li>
<li><code>A0: Foo&lt;A1..An, Item = T&gt;</code> is a bit special and expands to two distinct
goals, namely <code>Implemented(A0: Foo&lt;A1..An&gt;)</code> and
<code>AliasEq(&lt;A0 as Foo&lt;A1..An&gt;&gt;::Item = T)</code></li>
</ul>
<p>In the rules below, we will use <code>WC</code> to indicate where clauses that
appear in Rust syntax; we will then use the same <code>WC</code> to indicate
where those where clauses appear as goals in the program clauses that
we are producing. In that case, the mapping above is used to convert
from the Rust syntax into goals.</p>
<h3><a class="header" href="#transforming-the-lowered-where-clauses" id="transforming-the-lowered-where-clauses">Transforming the lowered where clauses</a></h3>
<p>In addition, in the rules below, we sometimes do some transformations
on the lowered where clauses, as defined here:</p>
<ul>
<li><code>FromEnv(WC)</code> – this indicates that:
<ul>
<li><code>Implemented(TraitRef)</code> becomes <code>FromEnv(TraitRef)</code></li>
<li>other where-clauses are left intact</li>
</ul>
</li>
<li><code>WellFormed(WC)</code> – this indicates that:
<ul>
<li><code>Implemented(TraitRef)</code> becomes <code>WellFormed(TraitRef)</code></li>
<li>other where-clauses are left intact</li>
</ul>
</li>
</ul>
<p><em>TODO</em>: I suspect that we want to alter the outlives relations too,
but Chalk isn't modeling those right now.</p>
<h2><a class="header" href="#lowering-traits" id="lowering-traits">Lowering traits</a></h2>
<p>Given a trait definition</p>
<pre><code class="language-rust ignore">trait Trait&lt;P1..Pn&gt; // P0 == Self
where WC
{
    // trait items
}
</code></pre>
<p>we will produce a number of declarations. This section is focused on
the program clauses for the trait header (i.e., the stuff outside the
<code>{}</code>); the <a href="clauses/lowering_rules.html#trait-items">section on trait items</a> covers the stuff
inside the <code>{}</code>.</p>
<h3><a class="header" href="#trait-header" id="trait-header">Trait header</a></h3>
<p>From the trait itself we mostly make &quot;meta&quot; rules that setup the
relationships between different kinds of domain goals.  The first such
rule from the trait header creates the mapping between the <code>FromEnv</code>
and <code>Implemented</code> predicates:</p>
<pre><code class="language-text">// Rule Implemented-From-Env
forall&lt;Self, P1..Pn&gt; {
  Implemented(Self: Trait&lt;P1..Pn&gt;) :- FromEnv(Self: Trait&lt;P1..Pn&gt;)
}
</code></pre>
<p><a name="implied-bounds"></a></p>
<h4><a class="header" href="#implied-bounds-1" id="implied-bounds-1">Implied bounds</a></h4>
<p>The next few clauses have to do with implied bounds (see also
<a href="https://rust-lang.github.io/rfcs/2089-implied-bounds.html">RFC 2089</a> and the <a href="clauses/./implied_bounds.html">implied bounds</a> chapter for a more in depth
cover). For each trait, we produce two clauses:</p>
<pre><code class="language-text">// Rule Implied-Bound-From-Trait
//
// For each where clause WC:
forall&lt;Self, P1..Pn&gt; {
  FromEnv(WC) :- FromEnv(Self: Trait&lt;P1..Pn&gt;)
}
</code></pre>
<p>This clause says that if we are assuming that the trait holds, then we can also
assume that its where-clauses hold. It's perhaps useful to see an example:</p>
<pre><code class="language-rust ignore">trait Eq: PartialEq { ... }
</code></pre>
<p>In this case, the <code>PartialEq</code> supertrait is equivalent to a <code>where Self: PartialEq</code> where clause, in our simplified model. The program
clause above therefore states that if we can prove <code>FromEnv(T: Eq)</code> –
e.g., if we are in some function with <code>T: Eq</code> in its where clauses –
then we also know that <code>FromEnv(T: PartialEq)</code>. Thus the set of things
that follow from the environment are not only the <strong>direct where
clauses</strong> but also things that follow from them.</p>
<p>The next rule is related; it defines what it means for a trait reference
to be <strong>well-formed</strong>:</p>
<pre><code class="language-text">// Rule WellFormed-TraitRef
forall&lt;Self, P1..Pn&gt; {
  WellFormed(Self: Trait&lt;P1..Pn&gt;) :- Implemented(Self: Trait&lt;P1..Pn&gt;) &amp;&amp; WellFormed(WC)
}
</code></pre>
<p>This <code>WellFormed</code> rule states that <code>T: Trait</code> is well-formed if (a)
<code>T: Trait</code> is implemented and (b) all the where-clauses declared on
<code>Trait</code> are well-formed (and hence they are implemented). Remember
that the <code>WellFormed</code> predicate is
<a href="clauses/./goals_and_clauses.html#coinductive">coinductive</a>; in this
case, it is serving as a kind of &quot;carrier&quot; that allows us to enumerate
all the where clauses that are transitively implied by <code>T: Trait</code>.</p>
<p>An example:</p>
<pre><code class="language-rust ignore">trait Foo: A + Bar { }
trait Bar: B + Foo { }
trait A { }
trait B { }
</code></pre>
<p>Here, the transitive set of implications for <code>T: Foo</code> are <code>T: A</code>, <code>T: Bar</code>, and
<code>T: B</code>.  And indeed if we were to try to prove <code>WellFormed(T: Foo)</code>, we would
have to prove each one of those:</p>
<ul>
<li><code>WellFormed(T: Foo)</code>
<ul>
<li><code>Implemented(T: Foo)</code></li>
<li><code>WellFormed(T: A)</code>
<ul>
<li><code>Implemented(T: A)</code></li>
</ul>
</li>
<li><code>WellFormed(T: Bar)</code>
<ul>
<li><code>Implemented(T: Bar)</code></li>
<li><code>WellFormed(T: B)</code>
<ul>
<li><code>Implemented(T: Bar)</code></li>
</ul>
</li>
<li><code>WellFormed(T: Foo)</code> -- cycle, true coinductively</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>This <code>WellFormed</code> predicate is only used when proving that impls are
well-formed – basically, for each impl of some trait ref <code>TraitRef</code>,
we must show that <code>WellFormed(TraitRef)</code>. This in turn justifies the
implied bounds rules that allow us to extend the set of <code>FromEnv</code>
items.</p>
<h2><a class="header" href="#lowering-type-definitions" id="lowering-type-definitions">Lowering type definitions</a></h2>
<p>We also want to have some rules which define when a type is well-formed.
For example, given this type:</p>
<pre><code class="language-rust ignore">struct Set&lt;K&gt; where K: Hash { ... }
</code></pre>
<p>then <code>Set&lt;i32&gt;</code> is well-formed because <code>i32</code> implements <code>Hash</code>, but
<code>Set&lt;NotHash&gt;</code> would not be well-formed. Basically, a type is well-formed
if its parameters verify the where clauses written on the type definition.</p>
<p>Hence, for every type definition:</p>
<pre><code class="language-rust ignore">struct Type&lt;P1..Pn&gt; where WC { ... }
</code></pre>
<p>we produce the following rule:</p>
<pre><code class="language-text">// Rule WellFormed-Type
forall&lt;P1..Pn&gt; {
  WellFormed(Type&lt;P1..Pn&gt;) :- WellFormed(WC)
}
</code></pre>
<p>Note that we use <code>struct</code> to define a type, but this should be understood as a
general type definition (it could be e.g. a generic <code>enum</code>).</p>
<p>Conversely, we define rules which say that if we assume that a type is
well-formed, we can also assume that its where clauses hold. That is,
we produce the following family of rules:</p>
<pre><code class="language-text">// Rule Implied-Bound-From-Type
//
// For each where clause `WC`
forall&lt;P1..Pn&gt; {
  FromEnv(WC) :- FromEnv(Type&lt;P1..Pn&gt;)
}
</code></pre>
<p>As for the implied bounds RFC, functions will <em>assume</em> that their arguments
are well-formed. For example, suppose we have the following bit of code:</p>
<pre><code class="language-rust ignore">trait Hash: Eq { }
struct Set&lt;K: Hash&gt; { ... }

fn foo&lt;K&gt;(collection: Set&lt;K&gt;, x: K, y: K) {
    // `x` and `y` can be equalized even if we did not explicitly write
    // `where K: Eq`
    if x == y {
        ...
    }
}
</code></pre>
<p>In the <code>foo</code> function, we assume that <code>Set&lt;K&gt;</code> is well-formed, i.e. we have
<code>FromEnv(Set&lt;K&gt;)</code> in our environment. Because of the previous rule, we get
<code>FromEnv(K: Hash)</code> without needing an explicit where clause. And because
of the <code>Hash</code> trait definition, there also exists a rule which says:</p>
<pre><code class="language-text">forall&lt;K&gt; {
  FromEnv(K: Eq) :- FromEnv(K: Hash)
}
</code></pre>
<p>which means that we finally get <code>FromEnv(K: Eq)</code> and then can compare <code>x</code>
and <code>y</code> without needing an explicit where clause.</p>
<p><a name="trait-items"></a></p>
<h2><a class="header" href="#lowering-trait-items" id="lowering-trait-items">Lowering trait items</a></h2>
<h3><a class="header" href="#associated-type-declarations" id="associated-type-declarations">Associated type declarations</a></h3>
<p>Given a trait that declares a (possibly generic) associated type:</p>
<pre><code class="language-rust ignore">trait Trait&lt;P1..Pn&gt; // P0 == Self
where WC
{
    type AssocType&lt;Pn+1..Pm&gt;: Bounds where WC1;
}
</code></pre>
<p>We will produce a number of program clauses. The first two define
the rules by which <code>AliasEq</code> for associated type projections can succeed; these two clauses are discussed
in detail in the <a href="clauses/./type_equality.html">section on associated types</a>,
but reproduced here for reference:</p>
<pre><code class="language-text">// Rule AliasEq-Normalize
//
// AliasEq can succeed by normalizing:
forall&lt;Self, P1..Pn, Pn+1..Pm, U&gt; {
  AliasEq(&lt;Self as Trait&lt;P1..Pn&gt;&gt;::AssocType&lt;Pn+1..Pm&gt; = U) :-
      Normalize(&lt;Self as Trait&lt;P1..Pn&gt;&gt;::AssocType&lt;Pn+1..Pm&gt; -&gt; U)
}
</code></pre>
<pre><code class="language-text">// Rule AliasEq-Placeholder
//
// AliasEq can succeed through the placeholder associated type,
// see &quot;associated type&quot; chapter for more:
forall&lt;Self, P1..Pn, Pn+1..Pm&gt; {
  AliasEq(
    &lt;Self as Trait&lt;P1..Pn&gt;&gt;::AssocType&lt;Pn+1..Pm&gt; =
    (Trait::AssocType)&lt;Self, P1..Pn, Pn+1..Pm&gt;
  )
}
</code></pre>
<p>The next rule covers implied bounds for the projection. In particular,
the <code>Bounds</code> declared on the associated type must have been proven to hold
to show that the impl is well-formed, and hence we can rely on them
elsewhere.</p>
<pre><code class="language-text">// Rule Implied-Bound-From-AssocTy
//
// For each `Bound` in `Bounds`:
forall&lt;Self, P1..Pn, Pn+1..Pm&gt; {
    FromEnv(&lt;Self as Trait&lt;P1..Pn&gt;&gt;::AssocType&lt;Pn+1..Pm&gt;&gt;: Bound) :-
      FromEnv(Self: Trait&lt;P1..Pn&gt;) &amp;&amp; WC1
}
</code></pre>
<p>Next, we define the requirements for an instantiation of our associated
type to be well-formed...</p>
<pre><code class="language-text">// Rule WellFormed-AssocTy
forall&lt;Self, P1..Pn, Pn+1..Pm&gt; {
    WellFormed((Trait::AssocType)&lt;Self, P1..Pn, Pn+1..Pm&gt;) :-
      WellFormed(Self: Trait&lt;P1..Pn&gt;) &amp;&amp; WellFormed(WC1)
}
</code></pre>
<p>...along with the reverse implications, when we can assume that it is
well-formed.</p>
<pre><code class="language-text">// Rule Implied-WC-From-AssocTy
//
// For each where clause WC1:
forall&lt;Self, P1..Pn, Pn+1..Pm&gt; {
    FromEnv(WC1) :- FromEnv((Trait::AssocType)&lt;Self, P1..Pn, Pn+1..Pm&gt;)
}
</code></pre>
<pre><code class="language-text">// Rule Implied-Trait-From-AssocTy
forall&lt;Self, P1..Pn, Pn+1..Pm&gt; {
    FromEnv(Self: Trait&lt;P1..Pn&gt;) :-
      FromEnv((Trait::AssocType)&lt;Self, P1..Pn, Pn+1..Pm&gt;)
}
</code></pre>
<h3><a class="header" href="#lowering-function-and-constant-declarations" id="lowering-function-and-constant-declarations">Lowering function and constant declarations</a></h3>
<p>Chalk didn't model functions and constants, but I would eventually like to
treat them exactly like normalization. See <a href="clauses/lowering_rules.html#constant-vals">the section on function/constant
values below</a> for more details.</p>
<h2><a class="header" href="#lowering-impls" id="lowering-impls">Lowering impls</a></h2>
<p>Given an impl of a trait:</p>
<pre><code class="language-rust ignore">impl&lt;P0..Pn&gt; Trait&lt;A1..An&gt; for A0
where WC
{
    // zero or more impl items
}
</code></pre>
<p>Let <code>TraitRef</code> be the trait reference <code>A0: Trait&lt;A1..An&gt;</code>. Then we
will create the following rules:</p>
<pre><code class="language-text">// Rule Implemented-From-Impl
forall&lt;P0..Pn&gt; {
  Implemented(TraitRef) :- WC
}
</code></pre>
<p>In addition, we will lower all of the <em>impl items</em>.</p>
<h2><a class="header" href="#lowering-impl-items" id="lowering-impl-items">Lowering impl items</a></h2>
<h3><a class="header" href="#associated-type-values" id="associated-type-values">Associated type values</a></h3>
<p>Given an impl that contains:</p>
<pre><code class="language-rust ignore">impl&lt;P0..Pn&gt; Trait&lt;P1..Pn&gt; for P0
where WC_impl
{
    type AssocType&lt;Pn+1..Pm&gt; = T;
}
</code></pre>
<p>and our where clause <code>WC1</code> on the trait associated type from above, we
produce the following rule:</p>
<pre><code class="language-text">// Rule Normalize-From-Impl
forall&lt;P0..Pm&gt; {
  forall&lt;Pn+1..Pm&gt; {
    Normalize(&lt;P0 as Trait&lt;P1..Pn&gt;&gt;::AssocType&lt;Pn+1..Pm&gt; -&gt; T) :-
      Implemented(P0 as Trait) &amp;&amp; WC1
  }
}
</code></pre>
<p>Note that <code>WC_impl</code> and <code>WC1</code> both encode where-clauses that the impl can
rely on. (<code>WC_impl</code> is not used here, because it is implied by
<code>Implemented(P0 as Trait)</code>.)</p>
<p><a name="constant-vals"></a></p>
<h3><a class="header" href="#function-and-constant-values" id="function-and-constant-values">Function and constant values</a></h3>
<p>Chalk didn't model functions and constants, but I would eventually
like to treat them exactly like normalization. This presumably
involves adding a new kind of parameter (constant), and then having a
<code>NormalizeValue</code> domain goal. This is <em>to be written</em> because the
details are a bit up in the air.</p>
<h1><a class="header" href="#opaque-types-impl-trait" id="opaque-types-impl-trait">Opaque types (impl Trait)</a></h1>
<p>This chapter describes how &quot;opaque types&quot; are modeled in chalk. Opaque types are
the underlying concept used to implement &quot;existential <code>impl Trait</code>&quot; in Rust.
They don't have a direct surface syntax, but uses of <code>impl Trait</code> in particular
source locations create a hidden opaque type:</p>
<pre><code class="language-rust ignore">fn as_u32s&lt;'a, T: Copy + Into&lt;u32&gt;&gt;(
    elements: &amp;'a [T],
) -&gt; impl Iterator&lt;Item = u32&gt; + 'a {
    elements.iter().cloned().map(|e| -&gt; u32 { e.into() })
}

<span class="boring">fn main() {
</span><span class="boring">   let x: &amp;[u16] = &amp;[1, 2, 3];
</span><span class="boring">   let y = as_u32s(&amp;x);
</span><span class="boring">   for e in y {
</span><span class="boring">       println!(&quot;e = {}&quot;, e);
</span><span class="boring">   }
</span><span class="boring">}
</span></code></pre>
<p>Conceptually, the function <code>as_u32s</code> is desugared to return a reference to an
<em>opaque type</em>, let's call it <code>AsU32sReturn</code> (note that this is not valid
Rust syntax):</p>
<pre><code class="language-rust ignore">opaque type AsU32sReturn&lt;'a, T&gt;: IntoIterator&lt;Item = u32&gt; + 'a
where
    T: Copy + Into&lt;u32&gt;;

fn as_u32s&lt;'a, T: Copy + Into&lt;u32&gt;&gt;(
    elements: &amp;'a [T],
) -&gt; AsU32sReturn&lt;'a, T&gt; {
    ...
}
</code></pre>
<p>Opaque types are a kind of type alias. They are called <em>opaque</em> because, unlike
an ordinary type alias, most Rust code (e.g., the callers of <code>as_u32s</code>) doesn't
know what type <code>AsU32sReturn</code> represents. It only knows what traits that type
implements (e.g., <code>IntoIterator&lt;Item = u32&gt;</code>). The actual type that is inferred
for <code>AsU32sReturn</code> is called the &quot;hidden type&quot;.</p>
<h2><a class="header" href="#chalk-syntax-for-an-opaque-type-declaration" id="chalk-syntax-for-an-opaque-type-declaration">Chalk syntax for an opaque type declaration</a></h2>
<p>Although the above is not valid Rust syntax, it is quite close to the
format that chalk unit tests use, which looks something like this:</p>
<pre><code class="language-rust ignore">opaque type OpaqueTypeName&lt;P0..Pn&gt;: /* bounds */
where
    /* where clauses */
= /* hidden type */;
</code></pre>
<p>A chalk opaque type declaration has several parts:</p>
<ul>
<li>The <strong>name</strong> <code>OpaqueTypeName</code>, which is the name we use to refer to the opaque type
within the chalk file. In real Rust opaque types are not explicitly declared
and hence they are identified just by internal ids (i.e., they are anonymous
in the same way that a closure type is anonymous), so this is just for unit
testing.</li>
<li>The <strong>generic parameters</strong> <code>P0..Pn</code>. In real Rust, these parameters are inherited
from the context in which the <code>impl Trait</code> appeared. In our example, these
parameters come from the surrounding function. Note that in real Rust the set
of generic parameters is a <em>subset</em> of those that appear on the surrounding
function: in particular, lifetime parameters may not appear unless they explicitly
appear in the opaque type's bounds.</li>
<li>The <strong>bounds</strong>, which would be <code>IntoIterator&lt;Item = u32&gt; + 'a</code> in our example.
These are traits that the <em>hidden type</em> (see below) is supposed to implement.
They come from the <code>impl IntoIterator&lt;Item = u32&gt; + 'a</code> type. Even when the hidden
type is, well, hidden, we can assume that the bounds hold.</li>
<li>The <strong>where clauses</strong>, which would be <code>T: Copy</code> and <code>T: Into&lt;u32&gt;</code> in our
example. These are conditions that must hold on <code>V0..Vn</code> for
<code>OpaqueTypeName&lt;V0..Vn&gt;</code> to be a valid type.
<ul>
<li>Note that this contrasts with bounds: bounds are things that the hidden type must meet
but which the rest of the code can assume to be true. Where clauses are things
that the rest of the code must prove to be true in order to use the opaque type.
In our example, then, a type like <code>AsU32sReturn&lt;'a, String&gt;</code> would be invalid
because <code>String: Copy</code> does not hold.</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#representing-opaque-types-in-chalk-types" id="representing-opaque-types-in-chalk-types">Representing opaque types in chalk types</a></h2>
<p>We represent opaque types as a kind of <strong><a href="clauses/../types/rust_types/alias.html">type alias</a></strong>. Like any type alias,
we have to define the conditions in which they can be normalized:</p>
<h2><a class="header" href="#placeholder-rules" id="placeholder-rules">Placeholder rules</a></h2>
<h1><a class="header" href="#well-known-traits" id="well-known-traits">Well known traits</a></h1>
<p>For most traits, the question of whether some type T implements the trait is determined by 
looking solely at the impls that exist for the trait. But there are some well-known traits 
where we have &quot;built-in&quot; impls that are never expressly written in the compiler, they are 
built-in to the language itself. In some cases, these impls also encode complex conditions
that an ordinary impl cannot express. To address this, chalk has a notion of a <code>WellKnownTrait</code> 
-- basically, a trait which is inherent to the language and where we will generate custom logic.</p>
<p>As an example, consider the logic for <code>Sized</code> in regards to structs: A struct can have
at most one <code>!Sized</code> field, and it must be the last. And the last field isn't <code>Sized</code>, 
then neither is the struct itself. </p>
<p>Chalk has two main places that deal with well known trait logic:</p>
<ol>
<li><a href="https://github.com/rust-lang/chalk/blob/master/chalk-solve/src/clauses/builtin_traits.rs"><code>chalk-solve\clauses\builtin_traits</code></a>, which generates built-in implementations
for well-known traits.</li>
<li><a href="clauses/wf.html">well-formedness</a> checks, some of which need to know about well known traits.</li>
</ol>
<h1><a class="header" href="#auto-traits" id="auto-traits">Auto traits</a></h1>
<p>Auto traits, while not exactly well known traits, do also have special logic. 
The idea is that the type implements an auto trait if all data owned by that type implements it, 
with an ability to specifically opt-out or opt-in. Additionally, auto traits are <a href="clauses/../engine/logic/coinduction.html#coinduction-and-refinement-strands">coinductive</a>. 
Some common examples of auto traits are <code>Send</code> and <code>Sync</code>.</p>
<h1><a class="header" href="#current-state" id="current-state">Current state</a></h1>
<table><thead><tr><th>Type</th><th>Copy</th><th>Clone</th><th>Sized</th><th>Unsize</th><th>CoerceUnsized</th><th>Drop</th><th>FnOnce/FnMut/Fn</th><th>Unpin</th><th>Coroutine</th><th>auto traits</th></tr></thead><tbody>
<tr><td>tuple types</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>✅</td></tr>
<tr><td>structs</td><td>⚬</td><td>⚬</td><td>✅</td><td>✅</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>✅</td></tr>
<tr><td>scalar types</td><td>📚</td><td>📚</td><td>✅</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>✅</td></tr>
<tr><td>str</td><td>📚</td><td>📚</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>✅</td></tr>
<tr><td>never type</td><td>📚</td><td>📚</td><td>✅</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>✅</td></tr>
<tr><td>trait objects</td><td>⚬</td><td>⚬</td><td>⚬</td><td>✅</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td></tr>
<tr><td>functions defs</td><td>✅</td><td>✅</td><td>✅</td><td>⚬</td><td>⚬</td><td>⚬</td><td>❌</td><td>⚬</td><td>⚬</td><td>✅</td></tr>
<tr><td>functions ptrs</td><td>✅</td><td>✅</td><td>✅</td><td>⚬</td><td>⚬</td><td>⚬</td><td>✅</td><td>⚬</td><td>⚬</td><td>✅</td></tr>
<tr><td>raw ptrs</td><td>📚</td><td>📚</td><td>✅</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>✅</td></tr>
<tr><td>immutable refs</td><td>📚</td><td>📚</td><td>✅</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>✅</td></tr>
<tr><td>mutable refs</td><td>⚬</td><td>⚬</td><td>✅</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>✅</td></tr>
<tr><td>slices</td><td>⚬</td><td>⚬</td><td>⚬</td><td>✅</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>✅</td></tr>
<tr><td>arrays</td><td>✅</td><td>✅</td><td>✅</td><td>❌</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>✅</td></tr>
<tr><td>closures</td><td>✅</td><td>✅</td><td>✅</td><td>⚬</td><td>⚬</td><td>⚬</td><td>✅</td><td>⚬</td><td>⚬</td><td>✅</td></tr>
<tr><td>coroutines</td><td>⚬</td><td>⚬</td><td>❌</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>✅</td><td>❌</td><td>✅</td></tr>
<tr><td>gen. witness</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>❌</td></tr>
<tr><td>opaque</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>❌</td></tr>
<tr><td>foreign</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td><td>❌</td></tr>
<tr><td>-----------</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>well-formedness</td><td>✅</td><td>⚬</td><td>✅</td><td>⚬</td><td>✅</td><td>✅</td><td>⚬</td><td>⚬</td><td>⚬</td><td>⚬</td></tr>
</tbody></table>
<p>legend:<br />
⚬ - not applicable<br />
✅ - implemented<br />
📚 - implementation provided in libcore<br />
❌ - not implemented</p>
<p>❌ after a type name means that type is not yet in chalk</p>
<h1><a class="header" href="#well-formedness-checking" id="well-formedness-checking">Well-formedness checking</a></h1>
<p>WF checking has the job of checking that the various declarations in a Rust
program are well-formed. This is the basis for implied bounds, and partly for
that reason, this checking can be surprisingly subtle! For example, we
have to be sure that each impl proves the WF conditions declared on
the trait.</p>
<p>For each declaration in a Rust program, we will generate a logical goal and try
to prove it using the lowered rules we described in the
<a href="clauses/./lowering_rules.html">lowering rules</a> chapter. If we are able to prove it, we
say that the construct is well-formed. If not, we report an error to the user.</p>
<p>Well-formedness checking happens in the <a href="https://github.com/rust-lang/chalk/blob/master/chalk-solve/src/wf.rs"><code>chalk/chalk-solve/src/wf.rs</code></a>
module in chalk. After you have read this chapter, you may find useful to see
an extended set of examples in the <a href="https://github.com/rust-lang/chalk/blob/master/tests/test/wf_lowering.rs"><code>chalk/tests/test/wf_lowering.rs</code></a> submodule.</p>
<p>The new-style WF checking has not been implemented in rustc yet.</p>
<p>We give here a complete reference of the generated goals for each Rust
declaration.</p>
<p>In addition to the notations introduced in the chapter about
lowering rules, we'll introduce another notation: when checking WF of a
declaration, we'll often have to prove that all types that appear are
well-formed, except type parameters that we always assume to be WF. Hence,
we'll use the following notation: for a type <code>SomeType&lt;...&gt;</code>, we define
<code>InputTypes(SomeType&lt;...&gt;)</code> to be the set of all non-parameter types appearing
in <code>SomeType&lt;...&gt;</code>, including <code>SomeType&lt;...&gt;</code> itself.</p>
<p>Examples:</p>
<ul>
<li><code>InputTypes((u32, f32)) = [u32, f32, (u32, f32)]</code></li>
<li><code>InputTypes(Box&lt;T&gt;) = [Box&lt;T&gt;]</code> (assuming that <code>T</code> is a type parameter)</li>
<li><code>InputTypes(Box&lt;Box&lt;T&gt;&gt;) = [Box&lt;T&gt;, Box&lt;Box&lt;T&gt;&gt;]</code></li>
</ul>
<p>We also extend the <code>InputTypes</code> notation to where clauses in the natural way.
So, for example <code>InputTypes(A0: Trait&lt;A1,...,An&gt;)</code> is the union of
<code>InputTypes(A0)</code>, <code>InputTypes(A1)</code>, ..., <code>InputTypes(An)</code>.</p>
<h1><a class="header" href="#type-definitions" id="type-definitions">Type definitions</a></h1>
<p>Given a general type definition:</p>
<pre><code class="language-rust ignore">struct Type&lt;P...&gt; where WC_type {
    field1: A1,
    ...
    fieldn: An,
}
</code></pre>
<p>we generate the following goal, which represents its well-formedness condition:</p>
<pre><code class="language-text">forall&lt;P...&gt; {
    if (FromEnv(WC_type)) {
        WellFormed(InputTypes(WC_type)) &amp;&amp;
            WellFormed(InputTypes(A1)) &amp;&amp;
            ...
            WellFormed(InputTypes(An))
    }
}
</code></pre>
<p>which in English states: assuming that the where clauses defined on the type
hold, prove that every type appearing in the type definition is well-formed.</p>
<p>Some examples:</p>
<pre><code class="language-rust ignore">struct OnlyClone&lt;T&gt; where T: Clone {
    clonable: T,
}
// The only types appearing are type parameters: we have nothing to check,
// the type definition is well-formed.
</code></pre>
<pre><code class="language-rust ignore">struct Foo&lt;T&gt; where T: Clone {
    foo: OnlyClone&lt;T&gt;,
}
// The only non-parameter type which appears in this definition is
// `OnlyClone&lt;T&gt;`. The generated goal is the following:
// ```
// forall&lt;T&gt; {
//     if (FromEnv(T: Clone)) {
//          WellFormed(OnlyClone&lt;T&gt;)
//     }
// }
// ```
// which is provable.
</code></pre>
<pre><code class="language-rust ignore">struct Bar&lt;T&gt; where &lt;T as Iterator&gt;::Item: Debug {
    bar: i32,
}
// The only non-parameter types which appear in this definition are
// `&lt;T as Iterator&gt;::Item` and `i32`. The generated goal is the following:
// ```
// forall&lt;T&gt; {
//     if (FromEnv(&lt;T as Iterator&gt;::Item: Debug)) {
//          WellFormed(&lt;T as Iterator&gt;::Item) &amp;&amp;
//               WellFormed(i32)
//     }
// }
// ```
// which is not provable since `WellFormed(&lt;T as Iterator&gt;::Item)` requires
// proving `Implemented(T: Iterator)`, and we are unable to prove that for an
// unknown `T`.
//
// Hence, this type definition is considered illegal. An additional
// `where T: Iterator` would make it legal.
</code></pre>
<h1><a class="header" href="#trait-definitions" id="trait-definitions">Trait definitions</a></h1>
<p>Given a general trait definition:</p>
<pre><code class="language-rust ignore">trait Trait&lt;P1...&gt; where WC_trait {
    type Assoc&lt;P2...&gt;: Bounds_assoc where WC_assoc;
}
</code></pre>
<p>we generate the following goal:</p>
<pre><code class="language-text">forall&lt;P1...&gt; {
    if (FromEnv(WC_trait)) {
        WellFormed(InputTypes(WC_trait)) &amp;&amp;

            forall&lt;P2...&gt; {
                if (FromEnv(WC_assoc)) {
                    WellFormed(InputTypes(Bounds_assoc)) &amp;&amp;
                        WellFormed(InputTypes(WC_assoc))
                }
            }
    }
}
</code></pre>
<p>There is not much to verify in a trait definition. We just want
to prove that the types appearing in the trait definition are well-formed,
under the assumption that the different where clauses hold.</p>
<p>Some examples:</p>
<pre><code class="language-rust ignore">trait Foo&lt;T&gt; where T: Iterator, &lt;T as Iterator&gt;::Item: Debug {
    ...
}
// The only non-parameter type which appears in this definition is
// `&lt;T as Iterator&gt;::Item`. The generated goal is the following:
// ```
// forall&lt;T&gt; {
//     if (FromEnv(T: Iterator), FromEnv(&lt;T as Iterator&gt;::Item: Debug)) {
//         WellFormed(&lt;T as Iterator&gt;::Item)
//     }
// }
// ```
// which is provable thanks to the `FromEnv(T: Iterator)` assumption.
</code></pre>
<pre><code class="language-rust ignore">trait Bar {
    type Assoc&lt;T&gt;: From&lt;&lt;T as Iterator&gt;::Item&gt;;
}
// The only non-parameter type which appears in this definition is
// `&lt;T as Iterator&gt;::Item`. The generated goal is the following:
// ```
// forall&lt;T&gt; {
//     WellFormed(&lt;T as Iterator&gt;::Item)
// }
// ```
// which is not provable, hence the trait definition is considered illegal.
</code></pre>
<pre><code class="language-rust ignore">trait Baz {
    type Assoc&lt;T&gt;: From&lt;&lt;T as Iterator&gt;::Item&gt; where T: Iterator;
}
// The generated goal is now:
// ```
// forall&lt;T&gt; {
//     if (FromEnv(T: Iterator)) {
//         WellFormed(&lt;T as Iterator&gt;::Item)
//     }
// }
// ```
// which is now provable.
</code></pre>
<h1><a class="header" href="#impls" id="impls">Impls</a></h1>
<p>Now we give ourselves a general impl for the trait defined above:</p>
<pre><code class="language-rust ignore">impl&lt;P1...&gt; Trait&lt;A1...&gt; for SomeType&lt;A2...&gt; where WC_impl {
    type Assoc&lt;P2...&gt; = SomeValue&lt;A3...&gt; where WC_assoc;
}
</code></pre>
<p>Note that here, <code>WC_assoc</code> are the same where clauses as those defined on the
associated type definition in the trait declaration, <em>except</em> that type
parameters from the trait are substituted with values provided by the impl
(see example below). You cannot add new where clauses. You may omit to write
the where clauses if you want to emphasize the fact that you are actually not
relying on them.</p>
<p>Some examples to illustrate that:</p>
<pre><code class="language-rust ignore">trait Foo&lt;T&gt; {
    type Assoc where T: Clone;
}

struct OnlyClone&lt;T: Clone&gt; { ... }

impl&lt;U&gt; Foo&lt;Option&lt;U&gt;&gt; for () {
    // We substitute type parameters from the trait by the ones provided
    // by the impl, that is instead of having a `T: Clone` where clause,
    // we have an `Option&lt;U&gt;: Clone` one.
    type Assoc = OnlyClone&lt;Option&lt;U&gt;&gt; where Option&lt;U&gt;: Clone;
}

impl&lt;T&gt; Foo&lt;T&gt; for i32 {
    // I'm not using the `T: Clone` where clause from the trait, so I can
    // omit it.
    type Assoc = u32;
}

impl&lt;T&gt; Foo&lt;T&gt; for f32 {
    type Assoc = OnlyClone&lt;Option&lt;T&gt;&gt; where Option&lt;T&gt;: Clone;
    //                                ^^^^^^^^^^^^^^^^^^^^^^
    //                                this where clause does not exist
    //                                on the original trait decl: illegal
}
</code></pre>
<blockquote>
<p>So in Rust, where clauses on associated types work <em>exactly</em> like where
clauses on trait methods: in an impl, we must substitute the parameters from
the traits with values provided by the impl, we may omit them if we don't
need them, but we cannot add new where clauses.</p>
</blockquote>
<p>Now let's see the generated goal for this general impl:</p>
<pre><code class="language-text">forall&lt;P1...&gt; {
    // Well-formedness of types appearing in the impl
    if (FromEnv(WC_impl), FromEnv(InputTypes(SomeType&lt;A2...&gt;: Trait&lt;A1...&gt;))) {
        WellFormed(InputTypes(WC_impl)) &amp;&amp;

            forall&lt;P2...&gt; {
                if (FromEnv(WC_assoc)) {
                        WellFormed(InputTypes(SomeValue&lt;A3...&gt;))
                }
            }
    }

    // Implied bounds checking
    if (FromEnv(WC_impl), FromEnv(InputTypes(SomeType&lt;A2...&gt;: Trait&lt;A1...&gt;))) {
        WellFormed(SomeType&lt;A2...&gt;: Trait&lt;A1...&gt;) &amp;&amp;

            forall&lt;P2...&gt; {
                if (FromEnv(WC_assoc)) {
                    WellFormed(SomeValue&lt;A3...&gt;: Bounds_assoc)
                }
            }
    }
}
</code></pre>
<p>Here is the most complex goal. As always, first, assuming that
the various where clauses hold, we prove that every type appearing in the impl
is well-formed, <em><strong>except</strong></em> types appearing in the impl header
<code>SomeType&lt;A2...&gt;: Trait&lt;A1...&gt;</code>. Instead, we <em>assume</em> that those types are
well-formed
(hence the <code>if (FromEnv(InputTypes(SomeType&lt;A2...&gt;: Trait&lt;A1...&gt;)))</code>
conditions). This is
part of the implied bounds proposal, so that we can rely on the bounds
written on the definition of e.g. the <code>SomeType&lt;A2...&gt;</code> type (and that we don't
need to repeat those bounds).</p>
<blockquote>
<p>Note that we don't need to check well-formedness of types appearing in
<code>WC_assoc</code> because we already did that in the trait decl (they are just
repeated with some substitutions of values which we already assume to be
well-formed)</p>
</blockquote>
<p>Next, still assuming that the where clauses on the impl <code>WC_impl</code> hold and that
the input types of <code>SomeType&lt;A2...&gt;</code> are well-formed, we prove that
<code>WellFormed(SomeType&lt;A2...&gt;: Trait&lt;A1...&gt;)</code> hold. That is, we want to prove
that <code>SomeType&lt;A2...&gt;</code> verify all the where clauses that might transitively
be required by the <code>Trait</code> definition (see
<a href="clauses/./implied_bounds.html#co-inductiveness-of-wellformed">this subsection</a>).</p>
<p>Lastly, assuming in addition that the where clauses on the associated type
<code>WC_assoc</code> hold,
we prove that <code>WellFormed(SomeValue&lt;A3...&gt;: Bounds_assoc)</code> hold. Again, we are
not only proving <code>Implemented(SomeValue&lt;A3...&gt;: Bounds_assoc)</code>, but also
all the facts that might transitively come from <code>Bounds_assoc</code>. We must do this
because we allow the use of implied bounds on associated types: if we have
<code>FromEnv(SomeType: Trait)</code> in our environment, the lowering rules
chapter indicates that we are able to deduce
<code>FromEnv(&lt;SomeType as Trait&gt;::Assoc: Bounds_assoc)</code> without knowing what the
precise value of <code>&lt;SomeType as Trait&gt;::Assoc</code> is.</p>
<p>Some examples for the generated goal:</p>
<pre><code class="language-rust ignore">// Trait Program Clauses

// These are program clauses that come from the trait definitions below
// and that the trait solver can use for its reasonings. I'm just restating
// them here so that we have them in mind.

trait Copy { }
// This is a program clause that comes from the trait definition above
// and that the trait solver can use for its reasonings. I'm just restating
// it here (and also the few other ones coming just after) so that we have
// them in mind.
// `WellFormed(Self: Copy) :- Implemented(Self: Copy).`

trait Partial where Self: Copy { }
// ```
// WellFormed(Self: Partial) :-
//     Implemented(Self: Partial) &amp;&amp;
//     WellFormed(Self: Copy).
// ```

trait Complete where Self: Partial { }
// ```
// WellFormed(Self: Complete) :-
//     Implemented(Self: Complete) &amp;&amp;
//     WellFormed(Self: Partial).
// ```

// Impl WF Goals

impl&lt;T&gt; Partial for T where T: Complete { }
// The generated goal is:
// ```
// forall&lt;T&gt; {
//     if (FromEnv(T: Complete)) {
//         WellFormed(T: Partial)
//     }
// }
// ```
// Then proving `WellFormed(T: Partial)` amounts to proving
// `Implemented(T: Partial)` and `Implemented(T: Copy)`.
// Both those facts can be deduced from the `FromEnv(T: Complete)` in our
// environment: this impl is legal.

impl&lt;T&gt; Complete for T { }
// The generated goal is:
// ```
// forall&lt;T&gt; {
//     WellFormed(T: Complete)
// }
// ```
// Then proving `WellFormed(T: Complete)` amounts to proving
// `Implemented(T: Complete)`, `Implemented(T: Partial)` and
// `Implemented(T: Copy)`.
//
// `Implemented(T: Complete)` can be proved thanks to the
// `impl&lt;T&gt; Complete for T` blanket impl.
//
// `Implemented(T: Partial)` can be proved thanks to the
// `impl&lt;T&gt; Partial for T where T: Complete` impl and because we know
// `T: Complete` holds.

// However, `Implemented(T: Copy)` cannot be proved: the impl is illegal.
// An additional `where T: Copy` bound would be sufficient to make that impl
// legal.
</code></pre>
<pre><code class="language-rust ignore">trait Bar { }

impl&lt;T&gt; Bar for T where &lt;T as Iterator&gt;::Item: Bar { }
// We have a non-parameter type appearing in the where clauses:
// `&lt;T as Iterator&gt;::Item`. The generated goal is:
// ```
// forall&lt;T&gt; {
//     if (FromEnv(&lt;T as Iterator&gt;::Item: Bar)) {
//         WellFormed(T: Bar) &amp;&amp;
//             WellFormed(&lt;T as Iterator&gt;::Item: Bar)
//     }
// }
// ```
// And `WellFormed(&lt;T as Iterator&gt;::Item: Bar)` is not provable: we'd need
// an additional `where T: Iterator` for example.
</code></pre>
<pre><code class="language-rust ignore">trait Foo { }

trait Bar {
    type Item: Foo;
}

struct Stuff&lt;T&gt; { }

impl&lt;T&gt; Bar for Stuff&lt;T&gt; where T: Foo {
    type Item = T;
}
// The generated goal is:
// ```
// forall&lt;T&gt; {
//     if (FromEnv(T: Foo)) {
//         WellFormed(T: Foo).
//     }
// }
// ```
// which is provable.
</code></pre>
<pre><code class="language-rust ignore">trait Debug { ... }
// `WellFormed(Self: Debug) :- Implemented(Self: Debug).`

struct Box&lt;T&gt; { ... }
impl&lt;T&gt; Debug for Box&lt;T&gt; where T: Debug { ... }

trait PointerFamily {
    type Pointer&lt;T&gt;: Debug where T: Debug;
}
// `WellFormed(Self: PointerFamily) :- Implemented(Self: PointerFamily).`

struct BoxFamily;

impl PointerFamily for BoxFamily {
    type Pointer&lt;T&gt; = Box&lt;T&gt; where T: Debug;
}
// The generated goal is:
// ```
// forall&lt;T&gt; {
//     WellFormed(BoxFamily: PointerFamily) &amp;&amp;
//
//     if (FromEnv(T: Debug)) {
//         WellFormed(Box&lt;T&gt;: Debug) &amp;&amp;
//             WellFormed(Box&lt;T&gt;)
//     }
// }
// ```
// `WellFormed(BoxFamily: PointerFamily)` amounts to proving
// `Implemented(BoxFamily: PointerFamily)`, which is ok thanks to our impl.
//
// `WellFormed(Box&lt;T&gt;)` is always true (there are no where clauses on the
// `Box` type definition).
//
// Moreover, we have an `impl&lt;T: Debug&gt; Debug for Box&lt;T&gt;`, hence
// we can prove `WellFormed(Box&lt;T&gt;: Debug)` and the impl is indeed legal.
</code></pre>
<pre><code class="language-rust ignore">trait Foo {
    type Assoc&lt;T&gt;;
}

struct OnlyClone&lt;T: Clone&gt; { ... }

impl Foo for i32 {
    type Assoc&lt;T&gt; = OnlyClone&lt;T&gt;;
}
// The generated goal is:
// ```
// forall&lt;T&gt; {
//     WellFormed(i32: Foo) &amp;&amp;
//        WellFormed(OnlyClone&lt;T&gt;)
// }
// ```
// however `WellFormed(OnlyClone&lt;T&gt;)` is not provable because it requires
// `Implemented(T: Clone)`. It would be tempting to just add a `where T: Clone`
// bound inside the `impl Foo for i32` block, however we saw that it was
// illegal to add where clauses that didn't come from the trait definition.
</code></pre>
<h1><a class="header" href="#chalk-coherence" id="chalk-coherence">Chalk Coherence</a></h1>
<p>This document was previously prepared for the initial design of coherence rules in Chalk. It was copy-pasted here on 2020-10-06, but has not been vetted for accuracy of the current implementation or edited for clarity.</p>
<h2><a class="header" href="#coherence-1" id="coherence-1">Coherence</a></h2>
<blockquote>
<p>The idea of trait coherence is that, given a trait and some set of types for its type parameters, there should be exactly one impl that applies. So if we think of the trait <code>Display</code>, we want to guarantee that if we have a trait reference like <code>MyType : Display</code>, we can uniquely identify a particular impl.</p>
<p>The role of the orphan rules in particular is basically to prevent you from implementing external traits for external types. So continuing our simple example of <code>Display</code>, if you are defining your own library, you could not implement <code>Display</code> for <code>Vec&lt;T&gt;</code>, because both <code>Display</code> and <code>Vec</code> are defined in the standard library. But you can implement <code>Display</code> for <code>MyType</code>, because you defined <code>MyType</code>. However, if you define your own trait <code>MyTrait</code>, then you can implement <code>MyTrait</code> for any type you like, including external types like <code>Vec&lt;T&gt;</code>. To this end, the orphan rule intuitively says “either the trait must be local or the self-type must be local”.</p>
<p>-- <a href="https://smallcultfollowing.com/babysteps/blog/2015/01/14/little-orphan-impls/">Little Orphan Impls</a> by Niko Matsakis</p>
</blockquote>
<p>To check for coherence, the Rust compiler completes two separate but related checks:</p>
<ul>
<li>orphan check - ensures that each impl abides by the orphan rules, or in other words, that an impl is potentially implementable by the crate adding it
<ul>
<li>A consequence of the orphan rules: for every impl that could exist, it only exists in <strong>one</strong> place — this is key to having a coherent system</li>
</ul>
</li>
<li>overlap check - ensures that no two impls overlap in your program <strong>or</strong> <strong>in any</strong> <em><strong>compatible</strong></em> <strong>world</strong>
<ul>
<li><strong>compatible</strong> - any semver compatible world</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#resources-about-coherence" id="resources-about-coherence">Resources About Coherence</a></h1>
<ul>
<li><a href="https://www.youtube.com/watch?v=AI7SLCubTnk&amp;t=43m19s">Coherence - talk by withoutboats</a></li>
<li><a href="https://smallcultfollowing.com/babysteps/blog/2015/01/14/little-orphan-impls/">Little Orphan Impls</a></li>
<li><a href="https://rust-lang.github.io/rfcs/1023-rebalancing-coherence.html">RFC 1023 Rebalancing Coherence</a></li>
<li><a href="http://blog.ezyang.com/2014/07/type-classes-confluence-coherence-global-uniqueness/">Type classes: confluence, coherence and global uniqueness</a></li>
</ul>
<h2><a class="header" href="#axioms--properties-of-coherence" id="axioms--properties-of-coherence">Axioms &amp; Properties of Coherence</a></h2>
<blockquote>
<p>Historical Note: We used to use the term “external” instead of “upstream”.</p>
</blockquote>
<ul>
<li><strong>Axiom 1:</strong> crates upstream to you should be able to implement their own traits for their own types</li>
<li><strong>Axiom 2:</strong> crates downstream from you should be able to implement your traits</li>
<li><strong>Property:</strong> Upstream crates must assume that downstream crates will add any impls that compile. Downstream crates are allowed to assume that upstream crates will not add any semver incompatible impls.</li>
</ul>
<h1><a class="header" href="#chalk-orphan-check" id="chalk-orphan-check">Chalk: Orphan Check</a></h1>
<p>The purpose of the orphan check is to ensure that an impl is only definable in a single crate. This check is what makes it impossible for other crates to define impls of your traits for your types.</p>
<p><strong>We want to capture some rule:</strong> Given <code>impl&lt;T0…Tn&gt; for Trait&lt;P1…Pn&gt; for P0</code>, <code>LocalImplAllowed(P0: Trait&lt;P1…Pn&gt;)</code> is true if and only if this impl is allowed in the current (local) crate. </p>
<p>This check is applied to all impls in the current crate. Upstream impls are not checked with this rule.</p>
<h2><a class="header" href="#the-orphan-rules" id="the-orphan-rules">The Orphan Rules</a></h2>
<p>In order to model the orphan check in chalk, we need a precise description of the orphan rules as they are implemented in rustc today.</p>
<p>There are several resources which can be used to figure out the orphan rules in rustc.</p>
<ul>
<li><a href="https://rust-lang.github.io/rfcs/1023-rebalancing-coherence.html">RFC 1023: Rebalancing Coherence</a></li>
<li><a href="https://doc.rust-lang.org/reference/items/implementations.html#trait-implementation-coherence"><em>Trait Implementation Coherence</em></a> <a href="https://doc.rust-lang.org/reference/items/implementations.html#trait-implementation-coherence">in the</a> <a href="https://doc.rust-lang.org/reference/items/implementations.html#trait-implementation-coherence"><em>Rust Reference</em></a></li>
<li><a href="https://doc.rust-lang.org/error-index.html#E0210">E0210: A violation of the orphan rules in the</a> <a href="https://doc.rust-lang.org/error-index.html#E0210"><em>Rust Error Index</em></a></li>
<li><a href="https://smallcultfollowing.com/babysteps/blog/2015/01/14/little-orphan-impls/"><em>Little Orphan Impls</em></a> <a href="https://smallcultfollowing.com/babysteps/blog/2015/01/14/little-orphan-impls/">by Niko Matsakis</a></li>
</ul>
<p>Of all of these, RFC 1023 is probably considered the most authoritative source on the orphan rules. The orphan rules as proposed in that RFC are as follows:</p>
<p>Given an impl <code>impl&lt;T1...Tn&gt; Trait&lt;P1...Pn&gt; for P0</code>, either <code>Trait</code> must be local to the current crate, or:</p>
<ol>
<li>At least one type must meet the <code>LT</code> pattern defined above. Let <code>Pi</code> be the first such type.</li>
<li>No type parameters <code>T1...Tn</code> may appear in the type parameters that precede <code>Pi</code> (that is, <code>Pj</code> where <code>j &lt; i</code>).</li>
</ol>
<p>The <code>LT</code> pattern being referred to basically means that the type is a “local type” including the affects of fundamental types. That means that <code>Ti</code> is either a local type, or a fundamental type whose first parameter is a local type.</p>
<p>This definition is good. Once you read it a few times and it makes sense, it is fairly unambiguous. That being said, the RFC was written quite a while ago and we have since found <a href="https://github.com/rust-lang/rust/issues/43355">unsoundness</a> in some of the parts of the compiler that were implemented based on that RFC.</p>
<p>Thus, it is probably best to look at the only <em>truly authoritative</em> source on the Rust compiler: the rustc source code itself! Indeed, if you think of the rustc source code as an executable specification of how the Rust programming language is meant to work, you can look at it and determine the true behaviour of the orphan rules.</p>
<h2><a class="header" href="#the-orphan-check-in-rustc" id="the-orphan-check-in-rustc">The Orphan Check in rustc</a></h2>
<p>The orphan check as implemented today in the Rust compiler takes place in the <a href="https://github.com/rust-lang/rust/blob/b7c6e8f1805cd8a4b0a1c1f22f17a89e9e2cea23/src/librustc/traits/coherence.rs#L236"><code>orphan_check</code></a> function which is called <a href="https://github.com/rust-lang/rust/blob/b7c6e8f1805cd8a4b0a1c1f22f17a89e9e2cea23/src/librustc_typeck/coherence/orphan.rs#L45">for every declared impl</a>. Since implementations for locally defined traits are always defined, that function returns OK if the trait being implemented is local. Otherwise, it dispatches to the <a href="https://github.com/rust-lang/rust/blob/b7c6e8f1805cd8a4b0a1c1f22f17a89e9e2cea23/src/librustc/traits/coherence.rs#L343"><code>orphan_check_trait_ref</code></a> function which does the major orphan rules checking.</p>
<p>Recall that the impls we are dealing with are in the form <code>impl&lt;T0…Tn&gt; Trait&lt;P1…Pn&gt; for P0</code>.</p>
<p>The <code>orphan_check_trait_ref</code> function takes a <strong>trait ref</strong> which is essentially <code>Trait</code> and its parameters <code>P0…Pn</code> (notice that the <code>Self</code> type <code>P0</code> is included). The parameters <code>P0…Pn</code> are known as the <strong>input types</strong> of the trait. The function goes through each input type from <code>P0</code> to <code>Pn</code> looking for the first local type <code>Pi</code>. For each type parameter <code>Pj</code> found before that, the function checks that it does not contain any of the placeholder types <code>T0…Tn</code> at any level. That means that <code>Pj</code> cannot have any of the types <code>T0…Tn</code> at any level recursively. When the first local type <code>Pi</code> is found, we check to make sure any type parameters used in it are covered by a local type. Since we don’t have any fundamental types with more than one type parameter, this check is probably extraneous.</p>
<h2><a class="header" href="#the-orphan-rules-in-rustc" id="the-orphan-rules-in-rustc">The Orphan Rules in rustc</a></h2>
<p>Thus, based on the source code, the orphan rules in Rust are as follows:</p>
<p>Given an impl of the form <code>impl&lt;T0…Tn&gt; Trait&lt;P1…Pn&gt; for P0</code>, the impl is allowed if:</p>
<ul>
<li><code>Trait</code> is local to the current crate</li>
<li><code>Trait</code> is upstream to the current crate and:
<ul>
<li>There is at least one type parameter <code>Pi</code> which, taking fundamental types into account, is <strong>local</strong> to the current crate</li>
<li>Within the type <code>Pi</code>,  all type parameters are covered by <code>Pi</code>
<ul>
<li>This only really applies if we allowed fundamental types with multiple type parameters</li>
<li>Since we don’t do that yet, we can ignore this for the time being</li>
</ul>
</li>
<li>All types <code>Pj</code> such that <code>j &lt; i</code> do not contain <code>T0…Tn</code> at any level of depth (i.e. the types are <strong>fully visible</strong> <strong>—</strong> “visible” meaning that the type is a known type and not a type parameter or variable)</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#modeling-the-orphan-check" id="modeling-the-orphan-check">Modeling The Orphan Check</a></h2>
<p>Determining how to model these rules in chalk is actually quite straightforward at this point. We have an exact specification of how the rules are meant to work and we can translate that directly. </p>
<p>Here’s how the lowering rules would look: </p>
<p>For each trait <code>Trait</code>,</p>
<ul>
<li>If <code>Trait</code> is local to the current crate, we generate:
<code>forall&lt;Self, P1…Pn&gt; { LocalImplAllowed(Self: Trait&lt;P1...Pn&gt;) }</code>
This models that any impls are allowed if the trait is local to the current crate.</li>
<li>If <code>Trait</code> is upstream to the current crate, we need a rule which models the additional conditions on which impls are allowed:</li>
</ul>
<pre><code class="language-ignore">forall&lt;Self, P1...Pn&gt; { LocalImplAllowed(Self: Trait&lt;P1...Pn&gt;) :- IsLocal(Self) }
forall&lt;Self, P1...Pn&gt; {
  LocalImplAllowed(Self: Trait&lt;P1...Pn&gt;) :- IsFullyVisible(Self), IsLocal(P1)
}
forall&lt;Self, P1...Pn&gt; {
  LocalImplAllowed(Self: Trait&lt;P1...Pn&gt;) :-
    IsFullyVisible(Self),
    IsFullyVisible(P1),
    IsLocal(P2)
}
forall&lt;Self, P1...Pn&gt; {
  LocalImplAllowed(Self: Trait&lt;P1...Pn&gt;) :-
    IsFullyVisible(Self),
    IsFullyVisible(P1),
    IsFullyVisible(P2),
    IsLocal(P3)
}
...
forall&lt;Self, P1...Pn&gt; {
  LocalImplAllowed(Self: Trait&lt;P1...Pn&gt;) :-
    IsFullyVisible(Self),
    IsFullyVisible(P1),
    IsFullyVisible(P2),
    ...
    IsFullyVisible(Pn-1),
    IsLocal(Pn)
}
</code></pre>
<p>Here, we have modeled every possible case of <code>P1</code> to <code>Pn</code> being local and then checked if all prior type parameters are fully visible. This truly is a direct translation of the rules listed above!</p>
<p>Now, to complete the orphan check, we can iterate over each impl of the same form as before and check if <code>LocalImplAllowed(P0: Trait&lt;P1…Pn&gt;)</code> is provable.</p>
<h1><a class="header" href="#chalk-overlap-check" id="chalk-overlap-check">Chalk: Overlap Check</a></h1>
<blockquote>
<p>Note: A key assumption for the overlap check is that the orphan check runs before it. That means that any impl that the overlap check encounters already abides by the orphan rules. This is very important to how the check works and it wouldn’t work without the orphan check also present before it.</p>
</blockquote>
<p>The purpose of the overlap check is to ensure that there is only up to one impl that can apply to a method call at a given time. In order to accomplish this, the overlap check looks at all pairs of impls and tries to ensure that there is no “overlap” between the sets of types that both impls can apply to. It accomplishes this by attempting to take the “intersection” of the constraints of both impls and then ensuring that this intersection cannot possibly apply to any types. If this turns out to be provable, the types are truly disjoint.</p>
<p>This is a simple application of the mathematical law:</p>
<blockquote>
<p>If two sets <em>A</em> and <em>B</em> are disjoint, then <em>A</em> ∩ <em>B</em> = ∅</p>
</blockquote>
<p>More concretely, let’s say you have the following two impls: (<a href="https://rust-lang.github.io/rfcs/1023-rebalancing-coherence.html#type-locality-and-negative-reasoning">example from RFC 1023</a>)</p>
<pre><code class="language-rust ignore">impl&lt;T: Copy&gt; Clone for T { /* ... */ }
impl&lt;U&gt; Clone for MyType&lt;U&gt; { /* ... */ }
</code></pre>
<p>Then we’ll try to solve the following:</p>
<pre><code class="language-ignore">not { exists&lt;T, U&gt; { T = MyType&lt;U&gt;, T: Copy } }
</code></pre>
<p>One way to read this is to say “try to prove that there is no <code>MyType&lt;U&gt;</code> for any <code>U</code> that implements the <code>Copy</code> trait”. The reason we’re trying to prove this is because if there is such an implementation, then the second impl would overlap with the first one. The first impl applies to any type that implements <code>Copy</code>.</p>
<p>The issue is that there may very well not be any such impl at this current time. In that case, chalk will conclude that these two impls do not overlap. This is an issue because that is certainly an impl that could be added later, so this conclusion may be too strong.</p>
<p>Why is that we’re only saying that this conclusion <em>may</em> be too strong? Well we’re using “may” because it depends on what we want to assume about different crates. The orphan rules make it so that upstream crates can add certain impls to themselves in a semver compatible way. In particular, upstream crates can add impls of upstream traits for their own upstream types without having to worry about breaking downstream code. That means that we can’t just assume that upstream type doesn’t implement an upstream trait. This particular assumption is too strong.</p>
<p>On the other hand, the orphan rules permit the current crate to add certain impls as well. A property of the orphan rules is that the impls it allows are only allowed to be defined in a single crate. So that means that if the impls allowed by the orphan rules in the current crate don’t exist, it is perfectly safe to assume that they are not there.</p>
<p>The conclusion from all of this is that it is perfectly safe to rule out impls that can be defined in the current crate, but we can’t do the same for impls in any other crate. That means that we need to come up with a way to model all possible impls in upstream, downstream and even sibling crates so we can make sure that our overlap check isn’t making assumptions that are too strong.</p>
<p><strong>Clarification:</strong> One caveat to all of this is that we can’t simply model “all possible impls” because then the current crate wouldn’t be able to add any impls at all for upstream traits. After all, it is <em>possible</em> for an upstream crate to add <em>any</em> impl for its upstream trait. A more precise version of what we’re looking for is to model impls that an upstream crate could add in a <strong>compatible</strong> way. These are impls that we may not be able to current see, but also cannot ignore since that would be too strong of an assumption.</p>
<p><strong>We are specifically trying to avoid a situation where a semver compatible upgrade of a dependency breaks the current crate because the current crate was able to add an impl that only the dependency was meant to be able to add.</strong></p>
<p><strong>Sibling Crates:</strong> Furthermore, we can immediately rule out sibling crates because by definition they are unable to use each other’s types or traits. If two crates are unable to interact at all, they cannot possibly add a conflicting implementation in any <strong>coherent</strong> world. Proof: Suppose that a sibling crate could add an impl that would conflict with a conclusion drawn by the overlap check in the current crate. Then the sibling crate would have to be able to implement a trait that was available to the current crate for a type that was available for the current crate. Since the sibling crate by definition does not have access to the current crate’s types or traits, the conflicting type and trait must be upstream. By the orphan rules, the sibling crate cannot implement a trait for upstream types and traits. Thus, the conflicting implementation in the sibling crate is impossible and no such implementation can exist.</p>
<p><strong>Downstream Crates:</strong> Downstream crates come into play because all traits in upstream crates and in the current crate can potentially be implemented by downstream crates using the forms allowed by the orphan rules. In essence, we always need to assume that downstream crates will implement traits in all ways that compile.</p>
<h2><a class="header" href="#discussion-modeling-the-overlap-check" id="discussion-modeling-the-overlap-check">Discussion: Modeling the Overlap Check</a></h2>
<p><a href="https://aturon.github.io/blog/2017/04/24/negative-chalk/">Aaron’s excellent blog post</a> talks about this exact problem from the point of view of negative reasoning. It also describes a potential solution which we will apply here to solve our problem.</p>
<p>The <strong>compatible modality</strong> (<code>compat</code> in Aaron’s blog post) is necessary because we don’t always want to assume that all compatible impls exist. In particular, there are certain phases of compilation (e.g. trans) where the closed-world assumption is entirely necessary and sufficient.</p>
<p>To start addressing the problem at hand, the question is: what implementations are crates other than the current crate allowed to add in a semver compatible way? </p>
<p>Since we already ruled out sibling crates, this only leaves upstream crates and downstream crates. Upstream crates only have access to upstream types and traits. That means that the only impls they can add are impls for upstream types or blanket impls over type parameters. Downstream crates have access to all upstream traits and types in addition to all traits and types in the current crate.</p>
<p><strong>Claim:</strong> No impl containing generic types can be added in a semver compatible way.
<strong>Proof:</strong> If the impl contains only generic types, it is considered a blanket impl and it may already be that a downstream trait implements that trait. So by adding a blanket impl, it now conflicts with the potential downstream implementation and is thus a breaking change. If the impl contains a generic type and also some number of upstream types, then a downstream crate may still have implemented that trait for all of the same values of the type parameters but with the generic types filled with downstream types. Thus, adding such an impl would also be a breaking change that would conflict with that potential downstream impl.</p>
<p>The only situation where an impl containing generic types can be added in a way that is <strong>not</strong> a breaking change is if <strong>in addition to the impl</strong>, a new type is also added to the upstream crate. In that case, downstream crates would not have had an opportunity to implement that trait for those types just yet. All of that being said, from the perspective of the current crate looking at potential upstream impls, this case does not matter at all because the current crate can never query for a type that doesn’t exist yet. That means that this situation doesn’t actually impact the potential impls that we need to account for even though it is a valid example of a situation where a new blanket impl is possible.</p>
<p>Thus, for all intents and purposes, impls containing generic type parameters cannot be added in semver compatible ways. This only leaves a single option: impls containing only upstream types. These are compatible because by the orphan rules, the current crate and any further downstream crates is not allowed to implement upstream traits for all upstream types. Thus, adding these impls cannot possibly break anything.</p>
<p>This significantly narrows down our set of potential impls that we need to account for to only impls of upstream traits for upstream types.</p>
<p>For downstream crates, we need to add rules for all possible impls that they could potentially add using any upstream traits or traits in the current crate. We can do this by enumerating the possibilities generated from the orphan rules specified above:</p>
<pre><code class="language-ignore">// Given a trait MyTrait&lt;P1...Pn&gt; where WCs

forall&lt;Self, P1...Pn&gt; {
  Implemented(Self: MyTrait&lt;P1...Pn&gt;) :-
    WCs,                  // where clauses
    Compatible,
    DownstreamType(Self), // local to a downstream crate
    CannotProve,
}
forall&lt;Self, P1...Pn&gt; {
  Implemented(Self: MyTrait&lt;P1...Pn&gt;) :-
    WCs,
    Compatible,
    IsFullyVisible(Self),
    DownstreamType(P1),
    CannotProve,
}
...
forall&lt;Self, P1...Pn&gt; {
  Implemented(Self: MyTrait&lt;P1...Pn&gt;) :-
    WCs,
    Compatible,
    IsFullyVisible(Self),
    IsFullyVisible(P1),
    ...,
    IsFullyVisible(Pn-1),
    DownstreamType(Pn),
    CannotProve,
}
</code></pre>
<p>Perhaps somewhat surprisingly, <code>IsFullyVisible</code> works here too. This is because our previous definition of the lowering for <code>IsFullyVisible</code> was quite broad. By lowering <em>all</em> types in the current crate and in upstream crates with <code>IsFullyVisible</code>, that predicate covers the correct set of types here too. The orphan rules only require that there are no types parameters prior to the first local type. Types that are not type parameters and also by definition not downstream types are all of the types in the current crate and in upstream crates. This is exactly what <code>IsFullyVisible</code> covers.</p>
<p>Fundamental types in both the current crate and in upstream crates can be considered local in a downstream crate if they are provided with a downstream type. To model this, we can add an additional rule for fundamental types:</p>
<pre><code class="language-ignore">forall&lt;T&gt; { DownstreamType(MyFundamentalType&lt;T&gt;) :- DownstreamType(T) }
</code></pre>
<p><strong>Where clauses:</strong> Traits can have where clauses.</p>
<pre><code class="language-rust ignore">#[upstream] trait Foo&lt;T, U, V&gt; where Self: Eq&lt;T&gt; { /* ... */ }
</code></pre>
<p><strong>The question is</strong>: do we need to bring these where clauses down into the rule that we generate for the overlap check?
<strong>Answer:</strong> Yes. Since the trait can only be implemented for types that satisfy its where clauses, it makes sense to also limit our assumption of compatible impls to impls that can exist.</p>
<p><strong>Associated types:</strong> Traits can have associated types. We do not need to worry about them in our discussion because associated types are output types and trait matching is done on input types. This is also why the orphan rules do not mention associated types at all.</p>
<h2><a class="header" href="#overlap-check-in-chalk" id="overlap-check-in-chalk">Overlap Check in Chalk</a></h2>
<p>Thus, based on the discussion above, the overlap check with coherence in mind can be modeled in chalk with the following:</p>
<ul>
<li>
<p>All disjoint queries take place inside of <code>compatible</code></p>
</li>
<li>
<p><code>compatible { G }</code> desugars into <code>forall&lt;T&gt; { (Compatible, DownstreamType(T)) =&gt; G }</code>, thus introducing a <code>Compatible</code> predicate using implication</p>
</li>
<li>
<p>For each upstream trait <code>MyTrait&lt;P1…Pn&gt;</code>, we lower it into the following rule:</p>
<pre><code class="language-ignore">forall&lt;Self, P1...Pn&gt; {
  Implemented(Self: MyTrait&lt;P1...Pn&gt;) :-
    Compatible,
    IsUpstream(Self),
    IsUpstream(P1),
    ...,
    IsUpstream(Pn),
    CannotProve
}
</code></pre>
<p>This will accomplish our goal of returning an ambiguous answer whenever the
overlap check query asks about any impls that an upstream crate may add in a
compatible way. We determined in the discussion above that these are the only
impls in any crate that can be added compatibly.</p>
<p><strong>Note:</strong> Trait <code>where</code> clauses are lowered into the rule’s conditions as well as a prerequisite to everything else.</p>
</li>
<li>
<p>For all traits <code>MyTrait&lt;P1…Pn&gt; where WCs</code> in the current crate and in upstream traits,</p>
<pre><code class="language-ignore">forall&lt;Self, P1...Pn&gt; {
  Implemented(Self: MyTrait&lt;P1...Pn&gt;) :-
    WCs,                  // where clauses
    Compatible,
    DownstreamType(Self), // local to a downstream crate
    CannotProve,
}
forall&lt;Self, P1...Pn&gt; {
  Implemented(Self: MyTrait&lt;P1...Pn&gt;) :-
    WCs,
    Compatible,
    IsFullyVisible(Self),
    DownstreamType(P1),
    CannotProve,
}
...
forall&lt;Self, P1...Pn&gt; {
  Implemented(Self: MyTrait&lt;P1...Pn&gt;) :-
    WCs,
    Compatible,
    IsFullyVisible(Self),
    IsFullyVisible(P1),
    ...,
    IsFullyVisible(Pn-1),
    DownstreamType(Pn),
    CannotProve,
}
</code></pre>
</li>
<li>
<p>For fundamental types in both the current crate and in upstream crates,</p>
<pre><code class="language-ignore">forall&lt;T&gt; { DownstreamType(MyFundamentalType&lt;T&gt;) :- DownstreamType(T) }
</code></pre>
</li>
</ul>
<h2><a class="header" href="#alternative-designs" id="alternative-designs">Alternative Designs</a></h2>
<p>Initially, when Niko and I started working on this, Niko suggested the following implementation:</p>
<blockquote>
<p>For each upstream trait, <code>MyTrait&lt;P1…Pn&gt;</code>, we lower it into the following rule:</p>
<pre><code class="language-ignore">forall&lt;Self, P1...Pn&gt; {
  Implemented(Self: MyTrait&lt;P1...Pn&gt;) :-
    Compatible,
    not { LocalImplAllowed(Self: MyTrait&lt;P1...Pn&gt;) },
    CannotProve
}
</code></pre>
</blockquote>
<p>This appears to make sense because we need to assume that any impls that the current crate cannot add itself may exist somewhere else. By using <code>not { LocalImplAllowed(…) }</code>, we modeled exactly that. The problem is, that this assumption is actually too strong. What we actually need to model is that any <strong>compatible</strong> impls that the current crate cannot add itself may exist somewhere else. This is a <strong>subset</strong> of the impls covered by <code>not { LocalImplAllowed(…) }</code>.</p>
<p>Notes to be added somewhere:</p>
<ul>
<li>For impls that are definable in the current crate, we assume that the only ones that exist are the ones that are actually present. If the current crate does not define an impl that it could define, for our purposes, that impl does not exist. This is in contrast to how we treat upstream impls. For those, we assume that impls <em>may</em> exist even if we don’t <em>know</em> that they do.</li>
<li>Struct/Trait privacy (e.g. <code>pub</code>) does not matter. For better or for worse, we always assume that everything is public or is going to be public someday, so we do not consider privacy at all.</li>
<li>Fundamental traits - tend to be traits that you generally wouldn't implement yourself. The compiler is the one generating implementations for those traits, so it was decided that it was okay to definitively conclude whether or not an impl exists for them</li>
</ul>
<h1><a class="header" href="#canonical-queries" id="canonical-queries">Canonical queries</a></h1>
<p>The &quot;start&quot; of the trait system is the <strong>canonical query</strong> (these are
both queries in the more general sense of the word – something you
would like to know the answer to – and in the
rustc-specific sense).  The idea is that the type
checker or other parts of the system, may in the course of doing their
thing want to know whether some trait is implemented for some type
(e.g., is <code>u32: Debug</code> true?). Or they may want to
normalize some associated type.</p>
<p>This section covers queries at a fairly high level of abstraction. The
subsections look a bit more closely at how these ideas are implemented
in rustc.</p>
<h2><a class="header" href="#the-traditional-interactive-prolog-query" id="the-traditional-interactive-prolog-query">The traditional, interactive Prolog query</a></h2>
<p>In a traditional Prolog system, when you start a query, the solver
will run off and start supplying you with every possible answer it can
find. So given something like this:</p>
<pre><code class="language-text">?- Vec&lt;i32&gt;: AsRef&lt;?U&gt;
</code></pre>
<p>The solver might answer:</p>
<pre><code class="language-text">Vec&lt;i32&gt;: AsRef&lt;[i32]&gt;
    continue? (y/n)
</code></pre>
<p>This <code>continue</code> bit is interesting. The idea in Prolog is that the
solver is finding <strong>all possible</strong> instantiations of your query that
are true. In this case, if we instantiate <code>?U = [i32]</code>, then the query
is true (note that a traditional Prolog interface does not, directly,
tell us a value for <code>?U</code>, but we can infer one by unifying the
response with our original query – Rust's solver gives back a
substitution instead). If we were to hit <code>y</code>, the solver might then
give us another possible answer:</p>
<pre><code class="language-text">Vec&lt;i32&gt;: AsRef&lt;Vec&lt;i32&gt;&gt;
    continue? (y/n)
</code></pre>
<p>This answer derives from the fact that there is a reflexive impl
(<code>impl&lt;T&gt; AsRef&lt;T&gt; for T</code>) for <code>AsRef</code>. If were to hit <code>y</code> again,
then we might get back a negative response:</p>
<pre><code class="language-text">no
</code></pre>
<p>Naturally, in some cases, there may be no possible answers, and hence
the solver will just give me back <code>no</code> right away:</p>
<pre><code class="language-text">?- Box&lt;i32&gt;: Copy
    no
</code></pre>
<p>In some cases, there might be an infinite number of responses. So for
example if I gave this query, and I kept hitting <code>y</code>, then the solver
would never stop giving me back answers:</p>
<pre><code class="language-text">?- Vec&lt;?U&gt;: Clone
    Vec&lt;i32&gt;: Clone
        continue? (y/n)
    Vec&lt;Box&lt;i32&gt;&gt;: Clone
        continue? (y/n)
    Vec&lt;Box&lt;Box&lt;i32&gt;&gt;&gt;: Clone
        continue? (y/n)
    Vec&lt;Box&lt;Box&lt;Box&lt;i32&gt;&gt;&gt;&gt;: Clone
        continue? (y/n)
</code></pre>
<p>As you can imagine, the solver will gleefully keep adding another
layer of <code>Box</code> until we ask it to stop, or it runs out of memory.</p>
<p>Another interesting thing is that queries might still have variables
in them. For example:</p>
<pre><code class="language-text">?- Rc&lt;?T&gt;: Clone
</code></pre>
<p>might produce the answer:</p>
<pre><code class="language-text">Rc&lt;?T&gt;: Clone
    continue? (y/n)
</code></pre>
<p>After all, <code>Rc&lt;?T&gt;</code> is true <strong>no matter what type <code>?T</code> is</strong>.</p>
<p><a name="query-response"></a></p>
<h2><a class="header" href="#a-trait-query-in-rustc" id="a-trait-query-in-rustc">A trait query in rustc</a></h2>
<p>The trait queries in rustc work somewhat differently. Instead of
trying to enumerate <strong>all possible</strong> answers for you, they are looking
for an <strong>unambiguous</strong> answer. In particular, when they tell you the
value for a type variable, that means that this is the <strong>only possible
instantiation</strong> that you could use, given the current set of impls and
where-clauses, that would be provable. (Internally within the solver,
though, they can potentially enumerate all possible answers. See
the description of the SLG solver for details.)</p>
<p>The response to a trait query in rustc is typically a
<code>Result&lt;QueryResult&lt;T&gt;, NoSolution&gt;</code> (where the <code>T</code> will vary a bit
depending on the query itself). The <code>Err(NoSolution)</code> case indicates
that the query was false and had no answers (e.g., <code>Box&lt;i32&gt;: Copy</code>).
Otherwise, the <code>QueryResult</code> gives back information about the possible answer(s)
we did find. It consists of four parts:</p>
<ul>
<li><strong>Certainty:</strong> tells you how sure we are of this answer. It can have two
values:
<ul>
<li><code>Proven</code> means that the result is known to be true.
<ul>
<li>This might be the result for trying to prove <code>Vec&lt;i32&gt;: Clone</code>,
say, or <code>Rc&lt;?T&gt;: Clone</code>.</li>
</ul>
</li>
<li><code>Ambiguous</code> means that there were things we could not yet prove to
be either true <em>or</em> false, typically because more type information
was needed. (We'll see an example shortly.)
<ul>
<li>This might be the result for trying to prove <code>Vec&lt;?T&gt;: Clone</code>.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Var values:</strong> Values for each of the unbound inference variables
(like <code>?T</code>) that appeared in your original query. (Remember that in Prolog,
we had to infer these.)
<ul>
<li>As we'll see in the example below, we can get back var values even
for <code>Ambiguous</code> cases.</li>
</ul>
</li>
<li><strong>Region constraints:</strong> these are relations that must hold between
the lifetimes that you supplied as inputs. We'll ignore these here,
but see the section on handling regions in traits for
more details.</li>
<li><strong>Value:</strong> The query result also comes with a value of type <code>T</code>. For
some specialized queries – like normalizing associated types –
this is used to carry back an extra result, but it's often just
<code>()</code>.</li>
</ul>
<h3><a class="header" href="#examples" id="examples">Examples</a></h3>
<p>Let's work through an example query to see what all the parts mean.
Consider <a href="https://doc.rust-lang.org/std/borrow/trait.Borrow.html">the <code>Borrow</code> trait</a>. This trait has a number of
impls; among them, there are these two (for clarity, I've written the
<code>Sized</code> bounds explicitly):</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Borrow&lt;T&gt; for T where T: ?Sized
impl&lt;T&gt; Borrow&lt;[T]&gt; for Vec&lt;T&gt; where T: Sized
</code></pre>
<p><strong>Example 1.</strong> Imagine we are type-checking this (rather artificial)
bit of code:</p>
<pre><code class="language-rust ignore">fn foo&lt;A, B&gt;(a: A, vec_b: Option&lt;B&gt;) where A: Borrow&lt;B&gt; { }

fn main() {
    let mut t: Vec&lt;_&gt; = vec![]; // Type: Vec&lt;?T&gt;
    let mut u: Option&lt;_&gt; = None; // Type: Option&lt;?U&gt;
    foo(t, u); // Example 1: requires `Vec&lt;?T&gt;: Borrow&lt;?U&gt;`
    ...
}
</code></pre>
<p>As the comments indicate, we first create two variables <code>t</code> and <code>u</code>;
<code>t</code> is an empty vector and <code>u</code> is a <code>None</code> option. Both of these
variables have unbound inference variables in their type: <code>?T</code>
represents the elements in the vector <code>t</code> and <code>?U</code> represents the
value stored in the option <code>u</code>.  Next, we invoke <code>foo</code>; comparing the
signature of <code>foo</code> to its arguments, we wind up with <code>A = Vec&lt;?T&gt;</code> and
<code>B = ?U</code>. Therefore, the where clause on <code>foo</code> requires that <code>Vec&lt;?T&gt;: Borrow&lt;?U&gt;</code>. This is thus our first example trait query.</p>
<p>There are many possible solutions to the query <code>Vec&lt;?T&gt;: Borrow&lt;?U&gt;</code>;
for example:</p>
<ul>
<li><code>?U = Vec&lt;?T&gt;</code>,</li>
<li><code>?U = [?T]</code>,</li>
<li><code>?T = u32, ?U = [u32]</code></li>
<li>and so forth.</li>
</ul>
<p>Therefore, the result we get back would be as follows (I'm going to
ignore region constraints and the &quot;value&quot;):</p>
<ul>
<li>Certainty: <code>Ambiguous</code> – we're not sure yet if this holds</li>
<li>Var values: <code>[?T = ?T, ?U = ?U]</code> – we learned nothing about the values of
the variables</li>
</ul>
<p>In short, the query result says that it is too soon to say much about
whether this trait is proven. During type-checking, this is not an
immediate error: instead, the type checker would hold on to this
requirement (<code>Vec&lt;?T&gt;: Borrow&lt;?U&gt;</code>) and wait. As we'll see in the next
example, it may happen that <code>?T</code> and <code>?U</code> wind up constrained from
other sources, in which case we can try the trait query again.</p>
<p><strong>Example 2.</strong> We can now extend our previous example a bit,
and assign a value to <code>u</code>:</p>
<pre><code class="language-rust ignore">fn foo&lt;A, B&gt;(a: A, vec_b: Option&lt;B&gt;) where A: Borrow&lt;B&gt; { }

fn main() {
    // What we saw before:
    let mut t: Vec&lt;_&gt; = vec![]; // Type: Vec&lt;?T&gt;
    let mut u: Option&lt;_&gt; = None; // Type: Option&lt;?U&gt;
    foo(t, u); // `Vec&lt;?T&gt;: Borrow&lt;?U&gt;` =&gt; ambiguous

    // New stuff:
    u = Some(vec![]); // ?U = Vec&lt;?V&gt;
}
</code></pre>
<p>As a result of this assignment, the type of <code>u</code> is forced to be
<code>Option&lt;Vec&lt;?V&gt;&gt;</code>, where <code>?V</code> represents the element type of the
vector. This in turn implies that <code>?U</code> is unified to <code>Vec&lt;?V&gt;</code>.</p>
<p>Let's suppose that the type checker decides to revisit the
&quot;as-yet-unproven&quot; trait obligation we saw before, <code>Vec&lt;?T&gt;: Borrow&lt;?U&gt;</code>. <code>?U</code> is no longer an unbound inference variable; it now
has a value, <code>Vec&lt;?V&gt;</code>. So, if we &quot;refresh&quot; the query with that value, we get:</p>
<pre><code class="language-text">Vec&lt;?T&gt;: Borrow&lt;Vec&lt;?V&gt;&gt;
</code></pre>
<p>This time, there is only one impl that applies, the reflexive impl:</p>
<pre><code class="language-text">impl&lt;T&gt; Borrow&lt;T&gt; for T where T: ?Sized
</code></pre>
<p>Therefore, the trait checker will answer:</p>
<ul>
<li>Certainty: <code>Proven</code></li>
<li>Var values: <code>[?T = ?T, ?V = ?T]</code></li>
</ul>
<p>Here, it is saying that we have indeed proven that the obligation
holds, and we also know that <code>?T</code> and <code>?V</code> are the same type (but we
don't know what that type is yet!).</p>
<p>(In fact, as the function ends here, the type checker would give an
error at this point, since the element types of <code>t</code> and <code>u</code> are still
not yet known, even though they are known to be the same.)</p>
<h1><a class="header" href="#canonicalization" id="canonicalization">Canonicalization</a></h1>
<p>Canonicalization is the process of <strong>isolating</strong> an inference value
from its context. It is a key part of implementing
<a href="canonical_queries/../canonical_queries.html">canonical queries</a>, and you may wish to read the parent chapter
to get more context.</p>
<p>Canonicalization is really based on a very simple concept: every
<a href="https://rustc-dev-guide.rust-lang.org/type-inference.html#vars">inference variable</a> 
is always in one of two states: either it is <strong>unbound</strong>, in which case we don't know yet
what type it is, or it is <strong>bound</strong>, in which case we do. So to
isolate some data-structure T that contains types/regions from its
environment, we just walk down and find the unbound variables that
appear in T; those variables get replaced with &quot;canonical variables&quot;,
starting from zero and numbered in a fixed order (left to right, for
the most part, but really it doesn't matter as long as it is
consistent).</p>
<p>So, for example, if we have the type <code>X = (?T, ?U)</code>, where <code>?T</code> and
<code>?U</code> are distinct, unbound inference variables, then the canonical
form of <code>X</code> would be <code>(?0, ?1)</code>, where <code>?0</code> and <code>?1</code> represent these
<strong>canonical placeholders</strong>. Note that the type <code>Y = (?U, ?T)</code> also
canonicalizes to <code>(?0, ?1)</code>. But the type <code>Z = (?T, ?T)</code> would
canonicalize to <code>(?0, ?0)</code> (as would <code>(?U, ?U)</code>). In other words, the
exact identity of the inference variables is not important – unless
they are repeated.</p>
<p>We use this to improve caching as well as to detect cycles and other
things during trait resolution. Roughly speaking, the idea is that if
two trait queries have the same canonical form, then they will get
the same answer. That answer will be expressed in terms of the
canonical variables (<code>?0</code>, <code>?1</code>), which we can then map back to the
original variables (<code>?T</code>, <code>?U</code>).</p>
<h2><a class="header" href="#canonicalizing-the-query" id="canonicalizing-the-query">Canonicalizing the query</a></h2>
<p>To see how it works, imagine that we are asking to solve the following
trait query: <code>?A: Foo&lt;'static, ?B&gt;</code>, where <code>?A</code> and <code>?B</code> are unbound.
This query contains two unbound variables, but it also contains the
lifetime <code>'static</code>. The trait system generally ignores all lifetimes
and treats them equally, so when canonicalizing, we will <em>also</em>
replace any <a href="https://rustc-dev-guide.rust-lang.org/appendix/background.html#free-vs-bound">free lifetime</a> with a
canonical variable (Note that <code>'static</code> is actually a <em>free</em> lifetime 
variable here. We are not considering it in the typing context of the whole 
program but only in the context of this trait reference. Mathematically, we
are not quantifying over the whole program, but only this obligation).
Therefore, we get the following result:</p>
<pre><code class="language-text">?0: Foo&lt;'?1, ?2&gt;
</code></pre>
<p>Sometimes we write this differently, like so:</p>
<pre><code class="language-text">for&lt;T,L,T&gt; { ?0: Foo&lt;'?1, ?2&gt; }
</code></pre>
<p>This <code>for&lt;&gt;</code> gives some information about each of the canonical
variables within.  In this case, each <code>T</code> indicates a type variable,
so <code>?0</code> and <code>?2</code> are types; the <code>L</code> indicates a lifetime variable, so
<code>?1</code> is a lifetime. The <code>canonicalize</code> method <em>also</em> gives back a
<code>CanonicalVarValues</code> array OV with the &quot;original values&quot; for each
canonicalized variable:</p>
<pre><code class="language-text">[?A, 'static, ?B]
</code></pre>
<p>We'll need this vector OV later, when we process the query response.</p>
<h2><a class="header" href="#executing-the-query" id="executing-the-query">Executing the query</a></h2>
<p>Once we've constructed the canonical query, we can try to solve it.
To do so, we will wind up creating a fresh inference context and
<strong>instantiating</strong> the canonical query in that context. The idea is that
we create a substitution S from the canonical form containing a fresh
inference variable (of suitable kind) for each canonical variable.
So, for our example query:</p>
<pre><code class="language-text">for&lt;T,L,T&gt; { ?0: Foo&lt;'?1, ?2&gt; }
</code></pre>
<p>the substitution S might be:</p>
<pre><code class="language-text">S = [?A, '?B, ?C]
</code></pre>
<p>We can then replace the bound canonical variables (<code>?0</code>, etc) with
these inference variables, yielding the following fully instantiated
query:</p>
<pre><code class="language-text">?A: Foo&lt;'?B, ?C&gt;
</code></pre>
<p>Remember that substitution S though! We're going to need it later.</p>
<p>OK, now that we have a fresh inference context and an instantiated
query, we can go ahead and try to solve it. The trait solver itself is
explained in more detail in <a href="canonical_queries/../engine/slg.html">another section</a>, but
suffice to say that it will compute a <a href="canonical_queries/../canonical_queries.html#query-response">certainty value</a> (<code>Proven</code> or
<code>Ambiguous</code>) and have side-effects on the inference variables we've
created. For example, if there were only one impl of <code>Foo</code>, like so:</p>
<pre><code class="language-rust ignore">impl&lt;'a, X&gt; Foo&lt;'a, X&gt; for Vec&lt;X&gt;
where X: 'a
{ ... }
</code></pre>
<p>then we might wind up with a certainty value of <code>Proven</code>, as well as
creating fresh inference variables <code>'?D</code> and <code>?E</code> (to represent the
parameters on the impl) and unifying as follows:</p>
<ul>
<li><code>'?B = '?D</code></li>
<li><code>?A = Vec&lt;?E&gt;</code></li>
<li><code>?C = ?E</code></li>
</ul>
<p>We would also accumulate the region constraint <code>?E: '?D</code>, due to the
where clause.</p>
<p>In order to create our final query result, we have to &quot;lift&quot; these
values out of the query's inference context and into something that
can be reapplied in our original inference context. We do that by
<strong>re-applying canonicalization</strong>, but to the <strong>query result</strong>.</p>
<h2><a class="header" href="#canonicalizing-the-query-result" id="canonicalizing-the-query-result">Canonicalizing the query result</a></h2>
<p>As discussed in <a href="canonical_queries/../canonical_queries.html#query-response">the parent section</a>, most trait queries wind up
with a result that brings together a &quot;certainty value&quot; <code>certainty</code>, a
result substitution <code>var_values</code>, and some region constraints. To
create this, we wind up re-using the substitution S that we created
when first instantiating our query. To refresh your memory, we had a query</p>
<pre><code class="language-text">for&lt;T,L,T&gt; { ?0: Foo&lt;'?1, ?2&gt; }
</code></pre>
<p>for which we made a substitution S:</p>
<pre><code class="language-text">S = [?A, '?B, ?C]
</code></pre>
<p>We then did some work which unified some of those variables with other things.
If we &quot;refresh&quot; S with the latest results, we get:</p>
<pre><code class="language-text">S = [Vec&lt;?E&gt;, '?D, ?E]
</code></pre>
<p>These are precisely the new values for the three input variables from
our original query. Note though that they include some new variables
(like <code>?E</code>). We can make those go away by canonicalizing again! We don't
just canonicalize S, though, we canonicalize the whole query response QR:</p>
<pre><code class="language-text">QR = {
    certainty: Proven,             // or whatever
    var_values: [Vec&lt;?E&gt;, '?D, ?E] // this is S
    region_constraints: [?E: '?D], // from the impl
    value: (),                     // for our purposes, just (), but
                                   // in some cases this might have
                                   // a type or other info
}
</code></pre>
<p>The result would be as follows:</p>
<pre><code class="language-text">Canonical(QR) = for&lt;T, L&gt; {
    certainty: Proven,
    var_values: [Vec&lt;?0&gt;, '?1, ?0]
    region_constraints: [?0: '?1],
    value: (),
}
</code></pre>
<p>(One subtle point: when we canonicalize the query <strong>result</strong>, we do not
use any special treatment for free lifetimes. Note that both
references to <code>'?D</code>, for example, were converted into the same
canonical variable (<code>?1</code>). This is in contrast to the original query,
where we canonicalized every free lifetime into a fresh canonical
variable.)</p>
<p>Now, this result must be reapplied in each context where needed.</p>
<h2><a class="header" href="#processing-the-canonicalized-query-result" id="processing-the-canonicalized-query-result">Processing the canonicalized query result</a></h2>
<p>In the previous section we produced a canonical query result. We now have
to apply that result in our original context. If you recall, way back in the
beginning, we were trying to prove this query:</p>
<pre><code class="language-text">?A: Foo&lt;'static, ?B&gt;
</code></pre>
<p>We canonicalized that into this:</p>
<pre><code class="language-text">for&lt;T,L,T&gt; { ?0: Foo&lt;'?1, ?2&gt; }
</code></pre>
<p>and now we got back a canonical response:</p>
<pre><code class="language-text">for&lt;T, L&gt; {
    certainty: Proven,
    var_values: [Vec&lt;?0&gt;, '?1, ?0]
    region_constraints: [?0: '?1],
    value: (),
}
</code></pre>
<p>We now want to apply that response to our context. Conceptually, how
we do that is to (a) instantiate each of the canonical variables in
the result with a fresh inference variable, (b) unify the values in
the result with the original values, and then (c) record the region
constraints for later. Doing step (a) would yield a result of</p>
<pre><code class="language-text">{
      certainty: Proven,
      var_values: [Vec&lt;?C&gt;, '?D, ?C]
                       ^^   ^^^ fresh inference variables
      region_constraints: [?C: '?D],
      value: (),
}
</code></pre>
<p>Step (b) would then unify:</p>
<pre><code class="language-text">?A with Vec&lt;?C&gt;
'static with '?D
?B with ?C
</code></pre>
<p>And finally the region constraint of <code>?C: 'static</code> would be recorded
for later verification.</p>
<p>(What we <em>actually</em> do is a mildly optimized variant of that: Rather
than eagerly instantiating all of the canonical values in the result
with variables, we instead walk the vector of values, looking for
cases where the value is just a canonical variable. In our example,
<code>values[2]</code> is <code>?C</code>, so that means we can deduce that <code>?C := ?B</code> and
<code>'?D := 'static</code>. This gives us a partial set of values. Anything for
which we do not find a value, we create an inference variable.)</p>
<h1><a class="header" href="#chalk-engine" id="chalk-engine">Chalk engine</a></h1>
<p>The <code>chalk-engine</code> crate is the core PROLOG-like solver for logical
predicates. Importantly, it is very general and not specific to Rust,
Rust types, or Rust logic.</p>
<h2><a class="header" href="#implemented-prolog-concepts" id="implemented-prolog-concepts">Implemented PROLOG concepts</a></h2>
<p>The engine implements the following PROLOG logic concepts. Some of these
have been published on previously, and some are <code>Chalk</code>-specific. This isn't
necessarily an exhaustive list:</p>
<ul>
<li>Basic logic</li>
<li>Negation</li>
<li>Floundering</li>
<li>Coinductive solving</li>
</ul>
<h2><a class="header" href="#note" id="note">Note</a></h2>
<p>Throughout most of this chapter, the specifics in regards to
<code>Canonicalization</code> and <code>UCanonicalization</code> are avoided. These are important
concepts to understand, but don't particularly help to understand how
<code>chalk-engine</code> <em>works</em>. In a few places, it may be highlighted if it <em>is</em>
important.</p>
<h1><a class="header" href="#major-concepts" id="major-concepts">Major concepts</a></h1>
<p>This section goes over a few different concepts that are crucial to
understanding how <code>chalk-engine</code> works, without going over the exact solving
logic.</p>
<h2><a class="header" href="#goals" id="goals">Goals</a></h2>
<p>A &quot;goal&quot; in Chalk can be thought of as &quot;something we want to prove&quot;. The engine
itself understands <code>GoalData</code>s. <code>GoalData</code>s consist of the most basic logic,
such as introducing Binders (<code>Forall</code> or <code>Exists</code>) or combining goals (<code>All</code>).
On the other hand, <code>DomainGoal</code> represents an opaque goal generated
externally. As such, it may contain any extra information or may be interned.
When solving a logic predicate, Chalk will lazily convert <code>DomainGoal</code>s
into <code>GoalData</code>s.</p>
<p>There are three types of completely opaque <code>GoalData</code>s that Chalk can solve:
<code>Unify</code>, <code>DomainGoal</code>, and <code>CannotProve</code>. Unlike the other types of goals,
these three cannot be simplified any further. <code>Unify</code> is the goal of unifying
any two types. <code>DomainGoal</code> is any goal that can solve by applying a
<a href="https://rust-lang.github.io/chalk/chalk_ir/struct.ProgramClause.html"><code>ProgramClause</code></a>. To solve this, more <code>Goal</code>s may generated. Finally,
<code>CannotProve</code> is a special goal that <em>cannot</em> be proven true or false.</p>
<h2><a class="header" href="#answers-and-solutions" id="answers-and-solutions">Answers and Solutions</a></h2>
<p>For every <code>Goal</code>, there are zero or more <code>Answer</code>s. Each <a href="https://rust-lang.github.io/chalk/chalk_engine/struct.Answer.html"><code>Answer</code></a> contains
values for the inference variables in the goal.</p>
<p>For example, given the following program:</p>
<pre><code class="language-notrust">trait Clone {}
struct A {}
struct B {}
impl Clone for A {}
impl Clone for B {}
</code></pre>
<p>With the following goal: <code>exists&lt;T&gt; { T: Clone }</code>
The following solutions would be given:</p>
<pre><code class="language-notrust">T = A
T = B
</code></pre>
<p>In other words, either <code>A</code> or <code>B</code> can substituted for <code>T</code> and the goal will
hold true. Moreover, either answer could be used when further solving other
goals that depend on this goal.</p>
<p>However, oftentimes, this is not what external crates want when solving for a
goal. Instead, the may want a <em>unique</em> solution to this goal. Indeed, when we
solve for a given root <a href="https://rust-lang.github.io/chalk/chalk_ir/struct.Goal.html"><code>Goal</code></a>, we return a single <a href="https://rust-lang.github.io/chalk/chalk_solve/solve/enum.Solution.html"><code>Solution</code></a>. The
<a href="https://rust-lang.github.io/chalk/chalk_engine/slg/aggregate/struct.AntiUnifier.html"><code>AntiUnifier</code></a>
struct from <code>chalk-solve</code> then finds that solution, by finding a minimal
generalization of answers which don't
unify. (For the example above, it would return only <code>Ambiguous</code>, since <code>A</code> and
<code>B</code> can't unify.)</p>
<h2><a class="header" href="#exclauses-and-strands" id="exclauses-and-strands">ExClauses and Strands</a></h2>
<p>An <a href="https://rust-lang.github.io/chalk/chalk_engine/struct.ExClause.html"><code>ExClause</code></a> is described in literature as <code>A :- D | G</code> or
<code>A holds given that G holds with D delayed goals</code>. In <code>chalk-engine</code>, an
<code>ExClause</code> stores the current state of proving a goal, including existing
substitutions already found, subgoals yet to be proven, or delayed subgoals. A
<a href="https://rust-lang.github.io/chalk/chalk_engine/strand/struct.Strand.html"><code>Strand</code></a> wraps both an <a href="https://rust-lang.github.io/chalk/chalk_engine/struct.ExClause.html"><code>ExClause</code></a> and an <a href="https://rust-lang.github.io/chalk/chalk_solve/infer/struct.InferenceTable.html"><code>InferenceTable</code></a> together.</p>
<h2><a class="header" href="#tables-and-forests" id="tables-and-forests">Tables and Forests</a></h2>
<p>A <a href="https://rust-lang.github.io/chalk/chalk_engine/strand/struct.Strand.html"><code>Strand</code></a> represents a <em>single</em> direction to find an <a href="https://rust-lang.github.io/chalk/chalk_engine/struct.Answer.html"><code>Answer</code></a> - for example, an
implementation of a trait with a set of where clauses. However, in a program,
there may be <em>multiple</em> possible implementations that match a goal - e.g.
multiple impls with different where clauses. Every <a href="https://rust-lang.github.io/chalk/chalk_engine/table/struct.Table.html"><code>Table</code></a> has a goal, and
stores existing <code>Answers</code>, as well as all <code>Strand</code>s that may result in more
answers.</p>
<p>A <a href="https://rust-lang.github.io/chalk/chalk_engine/forest/struct.Forest.html"><code>Forest</code></a> holds all the <code>Table</code>s that program generates, and is what most of
the logic is implemented on. It also stores the current state of solving (the
stack).</p>
<h1><a class="header" href="#logic" id="logic">Logic</a></h1>
<h2><a class="header" href="#overview" id="overview">Overview</a></h2>
<p><code>chalk-engine</code> solves a <code>Goal</code> using a hybrid search strategy with elements of depth- and breadth-first search. When asked to solve a
particular <code>Goal</code> it hasn't seen before, it will first try to
generate a set of program clauses, that get turned into <a href="https://rust-lang.github.io/chalk/chalk_engine/strand/struct.Strand.html"><code>Strand</code></a>s, that could
solve that goal. Otherwise, if asked to solve a <code>Goal</code> it has seen before, it
will select the existing table.</p>
<p>Once a table is selected, it will pick a <code>Strand</code> and a subgoal of that
<code>Strand</code>, try to solve that <code>Goal</code>, repeating the process.</p>
<p>When an <code>Answer</code> is found for a <code>Goal</code>, it is merged into the parent <code>Strand</code>,
or returned if it was the root <code>Goal</code>. It will then go on to pick the next
subgoal of the <code>Strand</code> and continue on.</p>
<p>If at any point the solving stops being &quot;successful&quot; (i.e. we definitely found
something to be unsolvable), the solving is restarted at the root <code>Goal</code>.</p>
<h2><a class="header" href="#the-stack" id="the-stack">The stack</a></h2>
<p>In order to detect cycles (talked more about later), as well as keep track of
the selected <a href="https://rust-lang.github.io/chalk/chalk_engine/strand/struct.Strand.html"><code>Strand</code></a> for each table, <code>chalk-engine</code> stores a <a href="https://rust-lang.github.io/chalk/chalk_engine/stack/struct.Stack.html"><code>Stack</code></a> on the
<code>Forest</code>. Whenever a new goal is selected, a <a href="https://rust-lang.github.io/chalk/chalk_engine/stack/struct.StackEntry.html"><code>StackEntry</code></a> is pushed onto the
<code>Stack</code>, as well as the &quot;time&quot; (which also gets incremented) that it was pushed.
This &quot;time&quot; can be compared later to check if all the <code>Strands</code> of a <a href="https://rust-lang.github.io/chalk/chalk_engine/table/struct.Table.html"><code>Table</code></a>
have been checked in a single solve.</p>
<p>As either <code>Answer</code>s are found for the selected <code>Table</code>, entries on the stack are
<code>pop</code>ed. If something is found to be unsolvable, the complete stack is unwound.</p>
<h2><a class="header" href="#table-creation" id="table-creation">Table creation</a></h2>
<p>As mentioned before, whenever a new <code>Goal</code> is encountered, a new <a href="https://rust-lang.github.io/chalk/chalk_engine/table/struct.Table.html"><code>Table</code></a> is
created to store current and future answers. First, the <a href="https://rust-lang.github.io/chalk/chalk_ir/struct.Goal.html"><code>Goal</code></a> is converted into
an <code>GoalData</code>. If it can be simplified, then a <code>Strand</code> with one or more
subgoals will be generated and can be followed as above. Otherwise, if it is a
<code>DomainGoal</code> (see above), then
<a href="https://rust-lang.github.io/chalk/chalk_solve/clauses/fn.program_clauses_for_goal.html"><code>program_clauses_for_goal</code></a>
is called and each clause is converted into a <code>Strand</code> and can be followed.</p>
<h2><a class="header" href="#root_answer-and-ensure_root_answer" id="root_answer-and-ensure_root_answer"><code>root_answer</code> and <code>ensure_root_answer</code></a></h2>
<p>The <a href="https://rust-lang.github.io/chalk/chalk_engine/forest/struct.Forest.html#method.root_answer"><code>root_answer</code></a> function is the entry point to solve a <code>Goal</code>. Up until now,
the idea of <code>Answer</code> versus <code>CompleteAnswer</code> have been ignored. However, in
reality <code>Answer</code>s to <code>Goal</code>s may actually have delayed subgoals (see <code>ExClause</code>
and <a href="engine/logic.html#coinduction-and-refinement-strands">Coinduction and refinement strands</a>), whereas <a href="https://rust-lang.github.io/chalk/chalk_engine/struct.CompleteAnswer.html"><code>CompleteAnswer</code></a>s may not.
<code>root_answer</code> essentially just wraps <a href="https://rust-lang.github.io/chalk/chalk_engine/forest/struct.Forest.html#method.ensure_root_answer"><code>ensure_root_answer</code></a> and converts the
<code>Goal</code>'s <a href="https://rust-lang.github.io/chalk/chalk_engine/struct.Answer.html"><code>Answer</code></a> to a <a href="https://rust-lang.github.io/chalk/chalk_engine/struct.CompleteAnswer.html"><code>CompleteAnswer</code></a>.</p>
<p>The <a href="https://rust-lang.github.io/chalk/chalk_engine/forest/struct.Forest.html#method.ensure_root_answer"><code>ensure_root_answer</code></a> function contains the core skeleton of the logic around
<code>Strand</code> and subgoal selection. The majority of the logic, however, is split out
into separate functions that branch out from <code>ensure_root_answer</code>.</p>
<h2><a class="header" href="#subgoal-selection" id="subgoal-selection">Subgoal selection</a></h2>
<p>Once a given <code>Strand</code> for a table has been selected, a subgoal has to be
selected. If there are no subgoals left, then there is nothing to do. Otherwise,
if there are subgoals left, then a subgoal will attempt to be selected (from
<a href="https://rust-lang.github.io/chalk/chalk_engine/slg/struct.SlgContext.html#method.next_subgoal_index"><code>next_subgoal_index</code></a>).
If the table for that subgoal had previously floundered (see next section), then
we mark that subgoal as floundered and try the next subgoal. If all subgoals are
marked as floundered, then this entire <code>Strand</code> is marked as floundered. If a
subgoal is successfully selected, there is nothing left to do.</p>
<h2><a class="header" href="#floundering" id="floundering">Floundering</a></h2>
<p>There a couple cases where we &quot;give up&quot; - here called floundering - on trying to
solve a goal. The most easy to understand case is if the types for a <code>Goal</code> or
<code>Answer</code> are too large. (Side note, we <em>could</em> actually handle this - by
generalizing - but turns out to be quite buggy and probably unnecessary).
Another case where we flounder is if we try to solve a <code>Goal</code> where we try to
<strong>enumerate</strong> non-enumerable types (like auto traits). In general, floundering
just means that we <em>can't</em> know any more answers about a <code>Goal</code>, for some
reason. However, if there are other <code>Strands</code> that don't flounder, there may
still be other <code>Answer</code>s available.</p>
<h2><a class="header" href="#answers" id="answers">Answers</a></h2>
<p>After an answer has been found for a subgoal, it must be <em>applied</em> to the parent
<code>Strand</code>. Specifically, it must be able to unify with any existing <code>Answers</code>. If
the <code>Answer</code>s are incompatible, the <code>Strand</code> is dropped since it can't lead
anywhere.</p>
<h2><a class="header" href="#cycles" id="cycles">Cycles</a></h2>
<p>If while pursuing a <code>Goal</code>, the engine encounters the same <code>Table</code> twice, then a
cycle has occurred. If the cycle is not coinductive (see next), then there is
nothing that can be gained from taking this route. We mark how far up the stack
is in the cycle, and try the next <code>Strand</code>. If all <code>Strand</code>s for a table
encounter a cycle, then we know that the current selected <code>Goal</code> has no more
answers.</p>
<h2><a class="header" href="#coinduction-and-refinement-strands" id="coinduction-and-refinement-strands">Coinduction and refinement strands</a></h2>
<p>Coinduction basically means that two statements can rely on each other being
true, unless either is proven false.</p>
<p>For example with the following program:</p>
<pre><code class="language-notrust">#[coinductive]
trait C1&lt;T&gt; { }
forall&lt;A, B&gt; { A: C1&lt;B&gt; if B: C1&lt;A&gt; }
</code></pre>
<p>Then the goal <code>exists&lt;T, U&gt; { T: C1&lt;U&gt; }</code> holds for all <code>T</code> and <code>U</code>. If the <code>C1</code>
trait was not coinductive, this would be a simple cycle.</p>
<p>To implement coinduction in the engine, delayed subgoals were introduced.
Essentially, if a cycle is found, and the <code>Goal</code> is coinductive, then this is
&quot;delayed&quot; until the stack unwinds back to the top <code>Goal</code> and all other
non-coinductive cycles have been proven. Then, <code>Goal</code> has been proven itself. In
some cases, it is the <em>root</em> <code>Goal</code> that has delayed coinductive subgoals (see
above example). In this case, we create another &quot;Refinement Strand&quot; where the
only subgoals are the delayed coinductive subgoals. If this new <code>Strand</code> can be
proven, then any <code>Answer</code>s from that are valid answers for the root <code>Goal</code>.
However, since there are currently delayed coinductive subgoals, there are no
answers available yet.</p>
<p>For much more in-depth </p>
<h1><a class="header" href="#coinduction" id="coinduction">Coinduction</a></h1>
<p>This sub-chapter was originally prepared for wg-traits design meeting on 2019-11-08 (see the <a href="https://hackmd.io/OJRi5OM6Twunw8ZmuLxfRA">Hackmd</a> doc). It briefly covers some tricky (and previously incorrectly handled) cases of coinduction, as well as two proposed solutions. The resulting and current solution ended up being something <em>pretty</em> close to Niko's solution. However, this is basically a copy-paste from the original document, and so shouldn't necessarily be taken as 100% truth as far as implementation.</p>
<h2><a class="header" href="#the-problem" id="the-problem">The problem</a></h2>
<p>See <a href="https://github.com/rust-lang/chalk/issues/248">chalk#248</a> for details. The short version is that we fail to handle a case like this correctly, where <code>Ci</code> are all co-inductive goals:</p>
<pre><code class="language-notrust">C1 :- C2, C3.
C2 :- C1.
</code></pre>
<p>What happens is that we </p>
<ul>
<li>start to prove C1</li>
<li>start to prove C2</li>
<li>see a recursive attempt to prove C1, assume it is successful</li>
<li>consider C2 proved <strong>and cache this</strong></li>
<li>start to prove C3, fail</li>
<li>consider C1 <strong>unproven</strong></li>
</ul>
<p>Now we incorrectly have a result that <code>C2</code> is true -- but that result was made on the assumption that <code>C1</code> was true, and it was not.</p>
<h2><a class="header" href="#some-other-tricky-cases-to-consider" id="some-other-tricky-cases-to-consider">Some other tricky cases to consider</a></h2>
<h3><a class="header" href="#unification-failures" id="unification-failures">Unification failures</a></h3>
<p>One thing to consider is that even when we have &quot;coinduction obligations&quot; to prove, we have to remember their substitutions too:</p>
<pre><code class="language-notrust">C1(X) :- C2(Y), X = 22.
C2(X) :- C3(X), X = 44.
C3(X) :- C1(X), C2(X).
</code></pre>
<p>None of these predicates should be provable,  because <code>C1(X)</code> and <code>C2(X)</code> don't hold for the same <code>X</code>.</p>
<p>If we're not careful, we might:</p>
<ul>
<li>start to prove C1</li>
<li>start to prove C2</li>
<li>start to prove C3, see the recursive calls to C1 and C2
<ul>
<li>maybe we wait to consider it proven until C1 and C2 complete</li>
</ul>
</li>
</ul>
<p>In this case, it's not enough that C1 and C2 are provable at all, they have to be provable for the same X.</p>
<h3><a class="header" href="#non-trivial-self-cycles" id="non-trivial-self-cycles">Non-trivial self-cycles</a></h3>
<pre><code class="language-notrust">C1(A) :- C1(B), B = 22, C2(A).
C2(44).
</code></pre>
<p>This case is not provable, even though the only cycle is <code>C1(X) :- C1(Y)</code> -- but it turns out that <code>X</code> must not be 22. The catch is that while this might <em>appear</em> to be a trivial self-cycle, it is not! </p>
<p>Actually I have to think about the best way to handle this case, as my proposed solution doesn't quite cut it. It wouldn't be <em>wrong</em> but it seems not ideal. -- Niko</p>
<h3><a class="header" href="#delayed-trivial-cycles" id="delayed-trivial-cycles">Delayed trivial cycles</a></h3>
<pre><code class="language-notrust">C1(A, B) :- C2(A, B), A = 22, B = 22.
C2(A, B) :- C1(B, A).
</code></pre>
<p>This should be provable, but the cycle from C2 to C1 is not immediately visible as a trivial cycle, at least if subgoals are solved in order.</p>
<h3><a class="header" href="#delayed-trivial-cycles-variant-2" id="delayed-trivial-cycles-variant-2">Delayed trivial cycles, variant 2</a></h3>
<pre><code class="language-notrust">C1(A, B) :- C2(A, B), A = 22.
C2(A, B) :- C1(B, A).
</code></pre>
<p>As above, here the only complete answer is <code>C1(22, 22)</code>. This is because the <code>C1</code>, <code>C2</code> cycle effectively guarantees equality.</p>
<h3><a class="header" href="#delayed-trivial-cycles-variant-3" id="delayed-trivial-cycles-variant-3">Delayed trivial cycles, variant 3</a></h3>
<pre><code class="language-notrust">C1(A, B) :- C1(B, A).
</code></pre>
<p>This is true for all <code>A, B</code></p>
<h3><a class="header" href="#other-cases" id="other-cases">Other cases?</a></h3>
<h2><a class="header" href="#approach-in-existing-pr" id="approach-in-existing-pr">Approach in existing PR</a></h2>
<h3><a class="header" href="#high-level-idea" id="high-level-idea">High-level idea</a></h3>
<ul>
<li>When we encounter a co-inductive subgoal, we delay them in the current <code>Strand</code></li>
<li>When all subgoals have been tested, and there are remaining delayed co-inductive subgoals, this is propagated up, marking the current <code>Strand</code> as co-inductive</li>
<li>When the co-inductive <code>Strand</code>s reach the root table, we only then pursue an answer</li>
</ul>
<h2><a class="header" href="#nikos-proposed-solution" id="nikos-proposed-solution">Niko's proposed solution</a></h2>
<h3><a class="header" href="#high-level-idea-1" id="high-level-idea-1">High-level idea</a></h3>
<ul>
<li>We only consider a co-induction subgoal proven for <em>trivial</em> recursion -- i.e., self-recursion where you have <code>C1 :- C1</code>.</li>
<li>For non-trivial recursion, we propagate the co-inductive subgoal to the parent. This continues until it becomes trivial.</li>
</ul>
<h3><a class="header" href="#implementation-steps" id="implementation-steps">Implementation steps</a></h3>
<p><strong>Extend <code>Answer</code> in two ways.</strong></p>
<p>Currently <code>Answer</code> has a &quot;constrained substitution&quot; that includes values for the table's substitution + region constraints:</p>
<pre><code class="language-notrust">struct Answer {
    constrained_subst: Canonical&lt;ConstrainedSubst&gt;,
    is_ambiguous: bool
}

struct ConstrainedSubst {
    substitution: Substitution,
    region_constraints: Vec&lt;RegionConstraint&gt;,
}
</code></pre>
<p>we would first extend <code>ConstrainedSubst</code> to include as yet unproven co-inductive subgoals (this might actually be better done as a new type): </p>
<pre><code class="language-rust ignore">struct ConstrainedSubst {
    substitution: Substitution,
    delayed_subgoals: Vec&lt;Literal&gt;,
    region_constraints: Vec&lt;RegionConstraint&gt;,
}
</code></pre>
<p>then we would extend <code>Answer</code> slightly as well so it can be &quot;ok&quot; or ambiguous, as today, but also an <em>error</em> case</p>
<pre><code class="language-rust ignore">enum AnswerMode {
    OK,
    Ambiguous,
    Error,
}

struct Answer {
    constrained_subst: Canonical&lt;ConstrainedSubst&gt;,
    mode: AnswerMode
}
</code></pre>
<p>We won't need this error case till later, so let's ignore it for now. (And in a way, we never need it.)</p>
<p><strong>Deferring coinductive subgoals</strong></p>
<p>When we encounter a co-inductive subgoal, we check if it is <strong>trivial cycle</strong> or not. A trivial cycle is a case like <code>C1 :- C1</code>. We can simply consider such cycles to be true (but note the distinction between a <em>trivial</em> cycle and a <em>self-cycle</em> -- see the &quot;non-trivial self-cycle&quot; example above).</p>
<p>For non-trivial cycles, we will want to store the cycle to be validated later. To accommodate that, we extend <code>ExClause</code> to include a <code>delayed_subgoals</code> list as well. We can write this the same way SLG does, so <code>Goal :- DelayedSubgoals | Subgoals</code></p>
<p>In our example, proving <code>C2 :- C1</code> would result in adding <code>C1</code> to the list of delayed subgoals.</p>
<p>When we reach the end of the list of subgoals, we can create an answer that contains the delayed subgoals. We don't have to add all the goals -- we can check for those that are trivial self-cycles again and remove them (in some cases, something which was not trivial to start may have become trivial through later unifications, see Delayed Trivial Self-Cycle case). Note that we <em>do</em> have to add all non-trivial cycles, including non-trivial self-cycles -- see the walkthrough of Non-trivial self-cycle variant 3.</p>
<p>So the answer to <code>C2</code> would be</p>
<pre><code class="language-notrust">substitution: [] // no variables
delayed_subgoals: [&quot;C1&quot;]
region_constraints: []
</code></pre>
<p>We can denote this as <code>C2 :- C1 |</code>, to use SLG notation.</p>
<p><strong>Incorporating an answer with deferred subgoals.</strong></p>
<p>When a table gets back an answer that has deferred sub-goals, they get added to the current list of subgoals. </p>
<p>So e.g. in our case, we had a <code>ExClause</code> like:</p>
<pre><code class="language-notrust">C1 :- | C2, C3
</code></pre>
<p>and we get the answer <code>C2 :- C1 |</code>, so we would convert it to</p>
<pre><code class="language-notrust">C1 :- | C3, C1
</code></pre>
<p>i.e., we have added <code>C1</code> to the list of goals to prove. When we go to prove <code>C3</code>, of course, we will fail -- but it had succeeded, we would go on to prove <code>C1</code> but encounter a trivial cycle and hence succeed.</p>
<p><strong>Extending root answer</strong></p>
<p>So we failed to prove C1, but we do have a (conditional) answer to C2 -- <code>C2 :- C1 |</code>, even though <code>C2</code> is unprovable. What happens if <code>ensure_root_answer</code> is invoked on <code>C2</code>?</p>
<p>What we have here is a <em>conditional</em> answer. We know that <code>C1</code> must have ultimately resolved itself somehow (although it might not yet be proven). What we can do is create a strand in C2 to evaluate C1 again -- if this strand succeeds, it can actually overwrite the <code>C2 :- C1 |</code> answer in place with <code>C2 :-</code> (i.e., an unconditional answer). This is just a refinement of what we had. If the strand fails, though, we'll want to remember the error.</p>
<p>I think when we get a new answer, we want it to <em>overwrite</em> the old answer in place, rather than create a new answer. This is valid because it's not a new answer, it's just a more refined form of the old answer (although note that it might have different substitutions and other details, see the &quot;delayed trivial cycle&quot; case).</p>
<p>In particular, it could be that the table already has a &quot;complete&quot; set of answers -- i.e., somebody invoked <code>ensure_answer(N)</code> and got back <code>None</code>. We don't want to be adding new answers which would change the result of that call. It <em>is</em> a bit strange that we are changing the result of <code>ensure_answer(i)</code> for the current <code>i</code>, but then the result is the same answer, just a bit more elaborated.</p>
<p>The idea then would be to create a strand <em>associated with this answer somehow</em> (it doesn't, I don't think, live in the normal strand table; we probably have a separate &quot;refinement strand&quot; table). This strand has as its subgoals the delayed subgoals. It pursues them. This either results in an answer (which replaces the existing answer) or an error (in which case the existing answer is marked as <em>error</em>). This may require extending strand with an optional answer index that it should overwrite, or perhaps we thread it down as an argument to <code>pursue_strand</code> (optional because, in the normal mode, we are just appending a new answer).</p>
<p>(Question: What distinguishes root answer? Nothing -- we could actually do this process for any answer, so long as the delayed subgoals are not to tables actively on the stack. This just happens to be trivially true for root answers. The key part though is that the answer must be registered in the table first before the refinement strand is created, see Delayed Self-Cycle Variant 3.)</p>
<p>This is complex, so let's walk through an example or two.</p>
<p><strong>The original problem.</strong> When we finish solving <code>C1</code>, we leave <code>C2</code> with a single answer <code>C2 :- C1 |</code>. If someone  invokes <code>ensure_root_answer(C2, 0)</code>, we would see the delayed literal and create a refinement strand for the answer: <code>C2 :- | C1</code>. We would pursue <code>C1</code> and get back the successful answer. So the refinement strand would terminate and we can overwrite with the answer <code>C2 :- |</code>.</p>
<p><strong>Delayed trivial self-cycle.</strong> Similar to above, but the answer is <code>C2(?A, ?B) :- C1(?B, ?A) |</code>. In other words, in the canonical answer, we have a (identity) substitution of <code>[^0, ^1]</code> and a delayed goal of <code>C1(^1, ^0)</code>. The strand we create will find only one answer to <code>C1</code>, <code>C1(22, 22)</code>, so we wind up with an answer <code>C2(22, 22)</code>.</p>
<p><strong>Handling error answers</strong></p>
<p>We introduced the idea of an &quot;error answer&quot;...how do we handle that? It's fairly simple. If a strand encounters an error answer, it simply fails. Done. The <em>outer</em> search however needs to treat an error answer as basically a no-op -- so e.g. the answer iterator should simply increment the error counter and move to the next answer.</p>
<h3><a class="header" href="#walk-through-delayed-trivial-self-cycle-variant-2" id="walk-through-delayed-trivial-self-cycle-variant-2">Walk through: delayed trivial self cycle, variant 2</a></h3>
<pre><code class="language-notrust">C1(A, B) :- C2(A, B), A = 22.
C2(A, B) :- C1(B, A).
</code></pre>
<ul>
<li><code>ensure_root_answer(C1(?A, ?B))</code> is invoked
<ul>
<li>We start solving <code>C1(?A, ?B)</code> with the ex-clause <code>C1(?A, ?B) :- | C2(?A, ?B), ?A = 22</code>
<ul>
<li>That starts solving <code>C2(?A, ?B)</code>
<ul>
<li>This gets an answer <code>C2(?A, ?B) :- C1(?B, ?A) |</code></li>
<li>When answer is incorporated, we get <code>C1(?A, ?B) :- | C1(?B, ?A), ?A = 22</code></li>
</ul>
</li>
<li><code>C1(?B, ?A)</code> is a non-trivial cycle, and so we get 
<ul>
<li><code>C1(?A, ?B) :- C1(?B, ?A) | ?A = 22</code></li>
</ul>
</li>
<li>Unification completes, leaving us with
<ul>
<li><code>C1(22, ?B) :- C1(?B, 22) |</code></li>
</ul>
</li>
<li>This is a complete answer</li>
</ul>
</li>
<li>ensure root answer attempts to refine this answer, creating a strand for <code>C1(22, ?B) :- | C1(?B, 22)</code>
<ul>
<li>This creates a table for <code>C1(?B, 22)</code> with ex-clause <code>C1(?B, 22) :- | C2(?B, 22), ?B = 22</code>
<ul>
<li>We start solving <code>C2(?B, 22)</code>, which has ex-clause <code>C2(?B, 22) :- C1(22, ?B)</code>
<ul>
<li>This creates a table for <code>C1(22, ?B)</code>, with ex-clause <code>C1(22, ?B) :- C2(22, ?B), 22 = 22</code>
<ul>
<li>This starts solving <code>C2(22, ?B)</code>, which is a fresh table with ex-clause <code>C2(22, ?B) :- C1(?B, 22)</code>
<ul>
<li>This is a co-inductive cycle</li>
<li>So our answer is <code>C2(22, ?B) :- C1(?B, 22) |</code></li>
</ul>
</li>
<li>Incorporating this answer yields <code>C1(22, ?B) :- 22 = 22, C1(?B, 22)</code></li>
<li>The unification constraint succeeds, leaving <code>C1(22, ?B) :- C1(?B, 22)</code></li>
<li>Co-inductive cycle detected, so answer is
<ul>
<li><code>C1(22, ?B) :- C1(?B, 22) |</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>This answer is incorporated into <code>C2</code>, yielding the ex-clause
<ul>
<li><code>C2(?B, 22) :- C1(?B, 22)</code></li>
</ul>
</li>
<li>Pursuing that sub-goal gives a co-inductive cycle, so our final answer is
<ul>
<li><code>C2(?B, 22) :- C1(?B, 22) |</code></li>
</ul>
</li>
</ul>
</li>
<li>This answer is incorporated, yielding ex-clause <code>C1(?B, 22) :- | ?B = 22, C1(?B, 22)</code></li>
<li>Unification yields <code>C1(22, 22) :- C1(22, 22)</code></li>
<li>Trivial self-cycle detected, so final answer is
<ul>
<li><code>C1(22, 22)</code></li>
</ul>
</li>
</ul>
</li>
<li>the answer for <code>C1(?A, ?B)</code> is thus updated to <code>C1(22, 22)</code></li>
</ul>
</li>
</ul>
<h3><a class="header" href="#walk-through-delayed-trivial-self-cycle-variant-3" id="walk-through-delayed-trivial-self-cycle-variant-3">Walk through: delayed trivial self cycle, variant 3</a></h3>
<pre><code class="language-notrust">C1(A, B) :- C1(B, A).
</code></pre>
<p>This example is interesting because it shows that we have to incorporate non-trivial self cycles into an answer so they can recursively build on one another.</p>
<ul>
<li>we get an initial answer of
<ul>
<li><code>C1(?A, ?B) :- C1(?B, ?A) |</code></li>
</ul>
</li>
<li>if we attempt to refine this, we will get a strand <code>C1(?X, ?Y) :- C1(?Y, ?X)</code>
<ul>
<li>pursuing the first subgoal <code>C1(?Y, ?X)</code> leads us to our own table, but at answer 0
<ul>
<li>(the very answer we are refining)</li>
<li>the answer is <code>C1(?Y, ?X) :- C1(?X, ?Y) |</code></li>
</ul>
</li>
<li>this strand incorporates its own answer, yielding
<ul>
<li><code>C1(?X, ?Y) :- C1(?X, ?Y)</code></li>
</ul>
</li>
<li>next subgoal is a trivial self-cycle, discard, yielding
<ul>
<li><code>C1(?X, ?Y) :-</code></li>
</ul>
</li>
</ul>
</li>
<li>result: true</li>
</ul>
<h3><a class="header" href="#walk-through-non-trivial-self-cycle" id="walk-through-non-trivial-self-cycle">Walk through: non-trivial self cycle</a></h3>
<p>Let's walk through one more case, the non-trivial self cycle.</p>
<pre><code class="language-notrust">C1(A) :- C1(B), B = 22, C2(A).
C2(44).
</code></pre>
<p>What happens here is that we get an initial answer from <code>C1</code> that looks like:</p>
<pre><code class="language-notrust">C1(44) :- C1(22) |
</code></pre>
<p>Ensure root answer will thus try to refine by trying to solve <code>C1(22)</code>. Interestingly, this is going to go to a distinct table, because the canonical form is not the same, but that table will just fail.</p>
<h1><a class="header" href="#the-on-demand-slg-solver" id="the-on-demand-slg-solver">The On-Demand SLG solver</a></h1>
<p>Given a set of program clauses (provided by our <a href="engine/../clauses.html">lowering rules</a>)
and a query, we need to return the result of the query and the value of any
type variables we can determine. This is the job of the solver.</p>
<p>For example, <code>exists&lt;T&gt; { Vec&lt;T&gt;: FromIterator&lt;u32&gt; }</code> has one solution, so
its result is <code>Unique; substitution [?T := u32]</code>. A solution also comes with
a set of region constraints, which we'll ignore in this introduction.</p>
<h2><a class="header" href="#goals-of-the-solver" id="goals-of-the-solver">Goals of the Solver</a></h2>
<h3><a class="header" href="#on-demand" id="on-demand">On demand</a></h3>
<p>There are often many, or even infinitely many, solutions to a query. For
example, say we want to prove that <code>exists&lt;T&gt; { Vec&lt;T&gt;: Debug }</code> for <em>some</em>
type <code>?T</code>. Our solver should be capable of yielding one answer at a time, say
<code>?T = u32</code>, then <code>?T = i32</code>, and so on, rather than iterating over every type
in the type system. If we need more answers, we can request more until we are
done. This is similar to how Prolog works.</p>
<p><em>See also: <a href="engine/../canonical_queries.html#the-traditional-interactive-prolog-query">The traditional, interactive Prolog query</a></em></p>
<h3><a class="header" href="#breadth-first" id="breadth-first">Breadth-first</a></h3>
<p><code>Vec&lt;?T&gt;: Debug</code> is true if <code>?T: Debug</code>. This leads to a cycle: <code>[Vec&lt;u32&gt;, Vec&lt;Vec&lt;u32&gt;&gt;, Vec&lt;Vec&lt;Vec&lt;u32&gt;&gt;&gt;]</code>, and so on all implement <code>Debug</code>. Our
solver ought to be breadth first and consider answers like <code>[Vec&lt;u32&gt;: Debug, Vec&lt;i32&gt;: Debug, ...]</code> before it recurses, or we may never find the answer
we're looking for.</p>
<h3><a class="header" href="#cachable" id="cachable">Cachable</a></h3>
<p>To speed up compilation, we need to cache results, including partial results
left over from past solver queries.</p>
<h2><a class="header" href="#description-of-how-it-works" id="description-of-how-it-works">Description of how it works</a></h2>
<p>The basis of the solver is the <a href="https://rust-lang.github.io/chalk/chalk_engine/forest/struct.Forest.html"><code>Forest</code></a> type. A <em>forest</em> stores a
collection of <em>tables</em> as well as a <em>stack</em>. Each <em>table</em> represents
the stored results of a particular query that is being performed, as
well as the various <em>strands</em>, which are basically suspended
computations that may be used to find more answers. Tables are
interdependent: solving one query may require solving others.</p>
<h3><a class="header" href="#walkthrough-1" id="walkthrough-1">Walkthrough</a></h3>
<p>Perhaps the easiest way to explain how the solver works is to walk
through an example. Let's imagine that we have the following program:</p>
<pre><code class="language-rust ignore">trait Debug { }

struct u32 { }
impl Debug for u32 { }

struct Rc&lt;T&gt; { }
impl&lt;T: Debug&gt; Debug for Rc&lt;T&gt; { }

struct Vec&lt;T&gt; { }
impl&lt;T: Debug&gt; Debug for Vec&lt;T&gt; { }
</code></pre>
<p>Now imagine that we want to find answers for the query <code>exists&lt;T&gt; { Rc&lt;T&gt;: Debug }</code>. The first step would be to u-canonicalize this query; this is the
act of giving canonical names to all the unbound inference variables based on
the order of their left-most appearance, as well as canonicalizing the
universes of any universally bound names (e.g., the <code>T</code> in <code>forall&lt;T&gt; { ... }</code>). In this case, there are no universally bound names, but the canonical
form Q of the query might look something like:</p>
<pre><code class="language-text">Rc&lt;?0&gt;: Debug
</code></pre>
<p>where <code>?0</code> is a variable in the root universe U0. We would then go and
look for a table with this canonical query as the key: since the forest is
empty, this lookup will fail, and we will create a new table T0,
corresponding to the u-canonical goal Q.</p>
<p><strong>Ignoring negative reasoning and regions.</strong> To start, we'll ignore
the possibility of negative goals like <code>not { Foo }</code>. We'll phase them
in later, as they bring several complications.</p>
<p><strong>Creating a table.</strong> When we first create a table, we also initialize
it with a set of <em>initial strands</em>. A &quot;strand&quot; is kind of like a
&quot;thread&quot; for the solver: it contains a particular way to produce an
answer. The initial set of strands for a goal like <code>Rc&lt;?0&gt;: Debug</code>
(i.e., a &quot;domain goal&quot;) is determined by looking for <em>clauses</em> in the
environment. In Rust, these clauses derive from impls, but also from
where-clauses that are in scope. In the case of our example, there
would be three clauses, each coming from the program. Using a
Prolog-like notation, these look like:</p>
<pre><code class="language-text">(u32: Debug).
(Rc&lt;T&gt;: Debug) :- (T: Debug).
(Vec&lt;T&gt;: Debug) :- (T: Debug).
</code></pre>
<p>To create our initial strands, then, we will try to apply each of
these clauses to our goal of <code>Rc&lt;?0&gt;: Debug</code>. The first and third
clauses are inapplicable because <code>u32</code> and <code>Vec&lt;?0&gt;</code> cannot be unified
with <code>Rc&lt;?0&gt;</code>. The second clause, however, will work.</p>
<p><strong>What is a strand?</strong> Let's talk a bit more about what a strand <em>is</em>. In the code, a strand
is the combination of an inference table, an <em>X-clause</em>, and (possibly)
a selected subgoal from that X-clause. But what is an X-clause
(<a href="https://rust-lang.github.io/chalk/chalk_engine/struct.ExClause.html"><code>ExClause</code></a>, in the code)? An X-clause pulls together a few things:</p>
<ul>
<li>The current state of the goal we are trying to prove;</li>
<li>A set of subgoals that have yet to be proven;</li>
<li>There are also a few things we're ignoring for now:
<ul>
<li>delayed literals, region constraints</li>
</ul>
</li>
</ul>
<p>The general form of an X-clause is written much like a Prolog clause,
but with somewhat different semantics. Since we're ignoring delayed
literals and region constraints, an X-clause just looks like this:</p>
<pre><code class="language-text">G :- L
</code></pre>
<p>where G is a goal and L is a set of subgoals that must be proven.
(The L stands for <em>literal</em> -- when we address negative reasoning, a
literal will be either a positive or negative subgoal.) The idea is
that if we are able to prove L then the goal G can be considered true.</p>
<p>In the case of our example, we would wind up creating one strand, with
an X-clause like so:</p>
<pre><code class="language-text">(Rc&lt;?T&gt;: Debug) :- (?T: Debug)
</code></pre>
<p>Here, the <code>?T</code> refers to one of the inference variables created in the
inference table that accompanies the strand. (I'll use named variables
to refer to inference variables, and numbered variables like <code>?0</code> to
refer to variables in a canonicalized goal; in the code, however, they
are both represented with an index.)</p>
<p>For each strand, we also optionally store a <em>selected subgoal</em>. This
is the subgoal after the turnstile (<code>:-</code>) that we are currently trying
to prove in this strand. Initially, when a strand is first created,
there is no selected subgoal.</p>
<p><strong>Activating a strand.</strong> Now that we have created the table T0 and
initialized it with strands, we have to actually try and produce an answer.
We do this by invoking the <a href="https://rust-lang.github.io/chalk/chalk_engine/forest/struct.Forest.html#method.ensure_root_answer"><code>ensure_root_answer</code></a> operation on the table:
specifically, we say <code>ensure_root_answer(T0, A0)</code>, meaning &quot;ensure that there
is a 0th answer A0 to query T0&quot;.</p>
<p>Remember that tables store not only strands, but also a vector of cached
answers. The first thing that <a href="https://rust-lang.github.io/chalk/chalk_engine/forest/struct.Forest.html#method.ensure_root_answer"><code>ensure_root_answer</code></a> does is to check whether
answer A0 is in this vector. If so, we can just return immediately. In this
case, the vector will be empty, and hence that does not apply (this becomes
important for cyclic checks later on).</p>
<p>When there is no cached answer, <a href="https://rust-lang.github.io/chalk/chalk_engine/forest/struct.Forest.html#method.ensure_root_answer"><code>ensure_root_answer</code></a> will try to produce one.
It does this by selecting a strand from the set of active strands -- the
strands are stored in a <code>VecDeque</code> and hence processed in a round-robin
fashion. Right now, we have only one strand, storing the following X-clause
with no selected subgoal:</p>
<pre><code class="language-text">(Rc&lt;?T&gt;: Debug) :- (?T: Debug)
</code></pre>
<p>When we activate the strand, we see that we have no selected subgoal,
and so we first pick one of the subgoals to process. Here, there is only
one (<code>?T: Debug</code>), so that becomes the selected subgoal, changing
the state of the strand to:</p>
<pre><code class="language-text">(Rc&lt;?T&gt;: Debug) :- selected(?T: Debug, A0)
</code></pre>
<p>Here, we write <code>selected(L, An)</code> to indicate that (a) the literal <code>L</code>
is the selected subgoal and (b) which answer <code>An</code> we are looking for. We
start out looking for <code>A0</code>.</p>
<p><strong>Processing the selected subgoal.</strong> Next, we have to try and find an
answer to this selected goal. To do that, we will u-canonicalize it
and try to find an associated table. In this case, the u-canonical
form of the subgoal is <code>?0: Debug</code>: we don't have a table yet for
that, so we can create a new one, T1. As before, we'll initialize T1
with strands. In this case, there will be three strands, because all
the program clauses are potentially applicable. Those three strands
will be:</p>
<ul>
<li><code>(u32: Debug) :-</code>, derived from the program clause <code>(u32: Debug).</code>.
<ul>
<li>Note: This strand has no subgoals.</li>
</ul>
</li>
<li><code>(Vec&lt;?U&gt;: Debug) :- (?U: Debug)</code>, derived from the <code>Vec</code> impl.</li>
<li><code>(Rc&lt;?U&gt;: Debug) :- (?U: Debug)</code>, derived from the <code>Rc</code> impl.</li>
</ul>
<p>We can thus summarize the state of the whole forest at this point as
follows:</p>
<pre><code class="language-text">Table T0 [Rc&lt;?0&gt;: Debug]
  Strands:
    (Rc&lt;?T&gt;: Debug) :- selected(?T: Debug, A0)

Table T1 [?0: Debug]
  Strands:
    (u32: Debug) :-
    (Vec&lt;?U&gt;: Debug) :- (?U: Debug)
    (Rc&lt;?V&gt;: Debug) :- (?V: Debug)
</code></pre>
<p><strong>Delegation between tables.</strong> Now that the active strand from T0 has
created the table T1, it can try to extract an answer. It does this
via that same <code>ensure_answer</code> operation we saw before. In this case,
the strand would invoke <code>ensure_answer(T1, A0)</code>, since we will start
with the first answer. This will cause T1 to activate its first
strand, <code>u32: Debug :-</code>.</p>
<p>This strand is somewhat special: it has no subgoals at all. This means
that the goal is proven. We can therefore add <code>u32: Debug</code> to the set
of <em>answers</em> for our table, calling it answer A0 (it is the first
answer). The strand is then removed from the list of strands.</p>
<p>The state of table T1 is therefore:</p>
<pre><code class="language-text">Table T1 [?0: Debug]
  Answers:
    A0 = [?0 = u32]
  Strand:
    (Vec&lt;?U&gt;: Debug) :- (?U: Debug)
    (Rc&lt;?V&gt;: Debug) :- (?V: Debug)
</code></pre>
<p>Note that I am writing out the answer A0 as a substitution that can be
applied to the table goal; actually, in the code, the goals for each
X-clause are also represented as substitutions, but in this exposition
I've chosen to write them as full goals, following <a href="engine/../bibliography.html#slg">NFTD</a>.</p>
<p>Since we now have an answer, <code>ensure_answer(T1, A0)</code> will return <code>Ok</code>
to the table T0, indicating that answer A0 is available. T0 now has
the job of incorporating that result into its active strand. It does
this in two ways. First, it creates a new strand that is looking for
the next possible answer of T1. Next, it incorporates the answer from
A0 and removes the subgoal. The resulting state of table T0 is:</p>
<pre><code class="language-text">Table T0 [Rc&lt;?0&gt;: Debug]
  Strands:
    (Rc&lt;?T&gt;: Debug) :- selected(?T: Debug, A1)
    (Rc&lt;u32&gt;: Debug) :-
</code></pre>
<p>We then immediately activate the strand that incorporated the answer
(the <code>Rc&lt;u32&gt;: Debug</code> one). In this case, that strand has no further
subgoals, so it becomes an answer to the table T0. This answer can
then be returned up to our caller, and the whole forest goes quiescent
at this point (remember, we only do enough work to generate <em>one</em>
answer). The ending state of the forest at this point will be:</p>
<pre><code class="language-text">Table T0 [Rc&lt;?0&gt;: Debug]
  Answer:
    A0 = [?0 = u32]
  Strands:
    (Rc&lt;?T&gt;: Debug) :- selected(?T: Debug, A1)

Table T1 [?0: Debug]
  Answers:
    A0 = [?0 = u32]
  Strand:
    (Vec&lt;?U&gt;: Debug) :- (?U: Debug)
    (Rc&lt;?V&gt;: Debug) :- (?V: Debug)
</code></pre>
<p>Here you can see how the forest captures both the answers we have
created thus far <em>and</em> the strands that will let us try to produce
more answers later on.</p>
<h2><a class="header" href="#see-also" id="see-also">See also</a></h2>
<ul>
<li><a href="https://github.com/rust-lang/chalk/blob/239e4ae4e69b2785b5f99e0f2b41fc16b0b4e65e/chalk-engine/src/README.md">chalk_solve README</a>, which contains links to papers used and
acronyms referenced in the code</li>
<li>This section is a lightly adapted version of the blog post <a href="https://smallcultfollowing.com/babysteps/blog/2018/01/31/an-on-demand-slg-solver-for-chalk/">An on-demand
SLG solver for chalk</a></li>
<li><a href="https://aturon.github.io/blog/2017/04/24/negative-chalk/">Negative Reasoning in Chalk</a> explains the need
for negative reasoning, but not how the SLG solver does it</li>
</ul>
<h1><a class="header" href="#chalk-recursive-solver" id="chalk-recursive-solver">Chalk recursive solver</a></h1>
<p>The recursive solver, as its name suggests, is a logic solver that works
&quot;recursively&quot;. In particular, its basic structure is a function like:</p>
<pre><code class="language-rust ignore">fn(Goal) -&gt; Solution
</code></pre>
<p>where the Goal is some <a href="./canonical_queries.html">canonical goal</a> and
the Solution is a result like:</p>
<ul>
<li>Provable(S): meaning the goal is provable and it is provably exactly (and
only) for the substitution S. S is a set of values for the inference variables
that appear in the goal. So if we had a goal like <code>Vec&lt;?X&gt;: Foo</code>, and we
returned <code>Provable(?X = u32)</code>, it would mean that only <code>Vec&lt;u32&gt;: Foo</code> and not
any other sort of vector (e.g., <code>Vec&lt;u64&gt;: Foo</code> does not hold).</li>
<li>Ambiguous(S): meaning that we can't prove whether or not the goal is true.
This can sometimes come with a substitution S, which offers suggested values
for the inference variables that might make it provable.</li>
<li>Error: the goal cannot be proven.</li>
</ul>
<h2><a class="header" href="#recursion-pros-and-cons" id="recursion-pros-and-cons">Recursion: pros and cons</a></h2>
<p>The recursive solver is so-called because, in the process of solving one goal,
it will &quot;recurse&quot; to solve another. Consider an example like this:</p>
<pre><code class="language-rust ignore">trait A { }
impl&lt;T: A&gt; A for Vec&lt;T&gt; { }
impl A for u32 { }
impl A for i32 { }
</code></pre>
<p>which results in program clauses like:</p>
<pre><code class="language-notrust">forall&lt;T&gt; { Implemented(Vec&lt;T&gt;: A) :- Implemented(T: A) }
Implemented(u32: A)
Implemented(i32: A)
</code></pre>
<p>First, suppose that we have a goal like <code>Implemented(Vec&lt;u64&gt;: A)</code>. This would
proceed like so:</p>
<ul>
<li><code>Solve(Implemented(Vec&lt;u64&gt;: A))</code>
<ul>
<li><code>Solve(Implemented(u64: A))</code>
<ul>
<li>returns <code>Error</code></li>
</ul>
</li>
<li>returns <code>Error</code></li>
</ul>
</li>
</ul>
<p>In other words, the recursive solver would start by applying the first rule,
which would cause us recursively try to solve <code>Implemented(u64: A)</code>. This would
yield an Error result, because there are no applicable rules, and that error
would propagate back up, causing the entire attempt at proving things to fail.</p>
<p>Next, consider <code>Implemented(Vec&lt;u32&gt;: A)</code>. This would proceed like so:</p>
<ul>
<li><code>Solve(Implemented(Vec&lt;u32&gt;: A))</code>
<ul>
<li><code>Solve(Implemented(u32: A))</code>
<ul>
<li>returns <code>Provable</code> with no substitution (no variables)</li>
</ul>
</li>
<li>returns <code>Provable</code></li>
</ul>
</li>
</ul>
<p>Finally, consider <code>Implemented(Vec&lt;?X&gt;: A)</code>. This is more interesting because it
has a variable:</p>
<ul>
<li><code>Solve(Implemented(Vec&lt;?X&gt;: A))</code>
<ul>
<li><code>Solve(Implemented(?X: A))</code>
<ul>
<li>finds two viable solutions, returns <code>Ambiguous</code></li>
</ul>
</li>
<li>returns <code>Ambiguous</code></li>
</ul>
</li>
</ul>
<h2><a class="header" href="#recursion-and-completeness" id="recursion-and-completeness">Recursion and completeness</a></h2>
<p>One side-effect of the recursive solver's structure is that it
cannot solve find solutions in some cases where a traditional
Prolog solver would be successful. Consider this example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait A { }
trait B { }

impl&lt;T: A + B&gt; A for Vec&lt;T&gt; { }

impl A for u32 { }
impl B for u32 { }

impl A for i32 { }
impl B for i8 { }
<span class="boring">}
</span></code></pre></pre>
<p>In the recursive solver, with a goal of <code>Implemented(Vec&lt;?X&gt;: A)</code>, we
recursively try to prove <code>Implemented(?X: A)</code> and <code>Implemented(?X: B)</code>, which
are both ambiguous, and we get stuck there.</p>
<p>The <a href="./engine.html">SLG solver</a> in contrast starts by exploring <code>?X = u32</code> and finds
that it works, and then later tries to explore <code>?X = i32</code> and finds that it
fails (because <code>i32: B</code> is not true).</p>
<h1><a class="header" href="#the-stack-1" id="the-stack-1">The stack</a></h1>
<p>The first &quot;layer&quot; of the recursive solver is the <a href="https://rust-lang.github.io/chalk/chalk_recursive/fixed_point/stack/struct.Stack.html"><code>Stack</code></a>. It is really just
what it sounds like: a stack that stores each thing that the recursive solver is
solving. Initially, it contains only one item, the root goal that was given by
the user.</p>
<p>Each frame on the stack has an associated <a href="https://rust-lang.github.io/chalk/chalk_recursive/fixed_point/stack/struct.StackDepth.html"><code>StackDepth</code></a>, which is basically an
index that increases (so 0 is the top of the stack, 1 is the next thing pushed,
etc).</p>
<h2><a class="header" href="#how-the-recursive-solver-works-at-the-highest-level" id="how-the-recursive-solver-works-at-the-highest-level">How the recursive solver works at the highest level</a></h2>
<p>At the highest level, the recursive solver works like so.</p>
<ul>
<li>Push the initial goal <code>G0</code> onto the stack.</li>
<li>Find all the program clauses <code>G1 :- G2...Gn</code> that could apply to the goal <code>G0</code>.</li>
<li>For each program clause, unify <code>G1</code> and <code>G0</code>. If that succeeds, then recursively try to prove each goal <code>Gi</code> in the list <code>G2..Gn</code>:
<ul>
<li>If proving <code>Gi</code> yields an error, return an error.</li>
<li>If proving <code>Gi</code> yields an ambiguity, keep going, but remember that we got an ambiguous result.</li>
<li>If proving <code>Gi</code> succeeded, apply the resulting answer to our inference variables and keep going.</li>
</ul>
</li>
<li>At the end, if any result proved ambiguous, return ambiguous, otherwise construct the final answer and return success.</li>
</ul>
<h2><a class="header" href="#example" id="example">Example</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait A { }
trait B { }

impl&lt;T: B&gt; A for Vec&lt;T&gt; { }

impl B for u32 { }
<span class="boring">}
</span></code></pre></pre>
<p>Imagine we are trying to prove <code>Implemented(Vec&lt;?X&gt;: A)</code>. There is one unbound
inference variable here, <code>?X</code>. We will ultimately get the result <code>Provable(?X = u32)</code>. But how do we find it?</p>
<ul>
<li>Initially we are solving <code>Implemented(Vec&lt;?X&gt;: A)</code>
<ul>
<li>we find one applicable program clause, <code>forall&lt;T&gt; { Implemented(Vec&lt;T&gt;: A) :- Implemented(T: B) }</code>.</li>
<li>after unification, the list of subgoals is <code>[Implemented(?X: B)]</code>.</li>
<li>we recursively try to solve <code>Implemented(?X: B)</code>
<ul>
<li>we find one applicable program clause, <code>Implemented(u32: B)</code>.</li>
<li>after unification, <code>?X = u32</code>, but there are no more subgoals.</li>
<li>we return the answer <code>Provable(?X = u32)</code>.</li>
</ul>
</li>
<li>we apply the substitution <code>?X = u32</code>, and find there are no more subgoals.</li>
<li>we return the answer <code>Provable(?X = u32)</code>.</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#why-do-we-need-the-stack" id="why-do-we-need-the-stack">Why do we need the stack?</a></h2>
<p>You may have noticed that the description above never seemed to use the <a href="https://rust-lang.github.io/chalk/chalk_recursive/fixed_point/stack/struct.Stack.html"><code>Stack</code></a>,
it only relied on the program stack. That's because I left out any discussion
of cycles. In fact, the <a href="https://rust-lang.github.io/chalk/chalk_recursive/fixed_point/stack/struct.Stack.html"><code>Stack</code></a> data structure does mirror the program stack,
it just adds some extra information we use in resolving cycles. We'll discuss
cycles in the next chapter, when we discuss the <a href="recursive/./search_graph.html">search graph</a>.</p>
<h2><a class="header" href="#figuring-out-if-something-is-on-the-stack" id="figuring-out-if-something-is-on-the-stack">Figuring out if something is on the stack</a></h2>
<p>The stack itself never stores the goal associated with a particular entry. That
information is found in the <a href="recursive/./search_graph.html">search graph</a>, which will be covered in detail in
the next section. For now it suffices to say that the search graph maps from
&quot;some goal that we are currently solving&quot; to &quot;information about that goal&quot;, and
one of the bits of information is the <a href="https://rust-lang.github.io/chalk/chalk_recursive/fixed_point/stack/struct.StackDepth.html"><code>StackDepth</code></a> of its entry on the stack
(if any).</p>
<p>Therefore, when we are about to start solving some (canonical) goal G, we can
detect a cycle by checking in the <a href="recursive/./search_graph.html">search graph</a> to see whether G has an associated
<a href="https://rust-lang.github.io/chalk/chalk_recursive/fixed_point/stack/struct.StackDepth.html"><code>StackDepth</code></a>. If so, it must be on the stack already (and we can set the
<a href="https://rust-lang.github.io/chalk/chalk_recursive/fixed_point/stack/struct.StackEntry.html#structfield.cycle"><code>cycle</code></a> field to true...but I get ahead of myself, read the next chapters
to learn more about that).</p>
<h1><a class="header" href="#inductive-cycles" id="inductive-cycles">Inductive cycles</a></h1>
<p>Recursive solving without cycles is easy. Solving with cycles is rather more
complicated. Before we get into the details of the implementation,
let's talk a bit about what behavior we actually <em>expect</em> in the face
of possible cycles.</p>
<h2><a class="header" href="#inductive-cycles-1" id="inductive-cycles-1">Inductive cycles</a></h2>
<p>By default, Rust trait solving is <strong>inductive</strong>. What that means is that, roughly
speaking, you have to prove something is true without any cycles (i.e., you
can't say &quot;it's true because it's true&quot;!).</p>
<p>For our purpose, a &quot;cycle&quot; means that, in the course of proving some canonical
goal G, we had to prove that same goal G again.</p>
<p>Consider this Rust program:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait A { }
impl&lt;T: A&gt; A for Vec&lt;T&gt; { }
impl A for u32 { }
<span class="boring">}
</span></code></pre></pre>
<p>Whether or not we hit a cycle will depend on the goal we are trying
to solve. If for example we are trying to prove <code>Implemented(Vec&lt;u32&gt;: A)</code>,
then we don't hit any cycle:</p>
<ul>
<li><code>Implemented(Vec&lt;u32&gt;: A) :- Implemented(u32: A)</code> // from the first impl
<ul>
<li><code>Implemented(u32: A)</code> // from the second impl</li>
</ul>
</li>
</ul>
<p>But what if we are trying to prove <code>Implemented(?X: A)</code>? This is a bit
more interesting. Because we don't know what <code>?X</code> is, both impls are
actually potentially applicable, so we wind up with two ways to
prove our goal. We will try them out one after the other.</p>
<p>One possible execution might be:</p>
<ul>
<li>Prove <code>Implemented(?X: A)</code>
<ul>
<li>we find the program clause <code>forall&lt;T&gt; { Implemented(Vec&lt;T&gt;: A) :- Implemented(T: A) }</code> from the first impl
<ul>
<li>we create the variable <code>?Y</code> to represent <code>T</code> and unify <code>?X = Vec&lt;?Y&gt;</code>.</li>
<li>after unification, we have the subgoal <code>Implemented(?Y: A)</code>
<ul>
<li>when we go to recursively prove this impl, however, we find that it is already on the stack</li>
<li>this is because the <a href="recursive/../canonical_queries.html">canonical form</a> of <code>Implemented(?X: A)</code> and <code>Implemented(?Y: A)</code> is the same</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#what-happens-if-we-treat-inductive-cycles-as-errors" id="what-happens-if-we-treat-inductive-cycles-as-errors">What happens if we treat inductive cycles as errors?</a></h2>
<p>So, what do we do when we hit an inductive cycle? Given that we told you that an
inductive proof cannot contain cycles, you might imagine that we can just treat
such a cycle as an error. But this won't give us the correct result.</p>
<p>Consider our previous example. If we just treat that cycle as an error, then we
will conclude that the impl for <code>Vec&lt;T&gt;</code> doesn't apply to <code>?X: A</code>, and we'll
proceed to try the impl for <code>u32</code>. This will let us reason that <code>?X: A</code> is
provable if <code>?X = u32</code>. This is, in fact, correct: <code>?X = u32</code> <em>is</em> a possible
answer. The problem is, it's not the only one!</p>
<p>In fact, <code>Implemented(?X: A)</code> has an <strong>infinite</strong> number of answers. It is true
for <code>?X = u32</code>. It is true for <code>?X = Vec&lt;u32&gt;</code>. It is also true for
<code>Vec&lt;Vec&lt;u32&gt;&gt;</code> and <code>Vec&lt;Vec&lt;Vec&lt;u32&gt;&gt;&gt;</code> and so on.</p>
<p>Given this, the correct result for our query is actually &quot;ambiguous&quot; -- in
particular, there is no unique substitution that we can give that would make the
query provable.</p>
<h2><a class="header" href="#how-we-solve-cycles-loop-and-try-again" id="how-we-solve-cycles-loop-and-try-again">How we solve cycles: loop and try again</a></h2>
<p>The way we actually handle cycles is by iterating until we reach a fixed point
(or ambiguity). We start out by assuming that all cycles are errors and we try
to find some solution S. If we succeed, then we can do a loop and iterate again
-- this time, for each cycle, we assume the result is S. This may yield some new
solution, S1. The key point here is that we now have <strong>two possible solutions</strong>
to the same goal, S and S1. This implies two possibilities:</p>
<ul>
<li>If S == S1, then in fact there is a unique solution, so we can return <code>Provable(S)</code>.</li>
<li>If S != S1, then we know there are two solutions, which means that there is
not one unique solution, and hence the correct result is <strong>ambiguous</strong>,
and in fact we can just stop and return right now.</li>
</ul>
<p>This technique is very similar to the traditional Prolog technique of handling
cycles, which is called <strong>tabling</strong>. The difference between our approach and
tabling is that we are always looking for a unique solution, whereas Prolog
(like the <a href="recursive/../engine.html">SLG solver</a>) tries to enumerate all solutions (i.e., in Prolog,
solving a goal is not a function but an iterator that yields solutions, and
hence it would yield up S first, and then S1, and then any further answers we
might get).</p>
<p>Intuitively, what is happening here is that we're building bigger and bigger
&quot;proof trees&quot; (i.e., trees of impl applications). In the first iteration, where
we assumed that all recursive calls were errors, we would find exactly one
solution, <code>u32: A</code> -- this is the root tree. In the next iteration, we can use
this result to build a tree for <code>Vec&lt;u32&gt;: A</code> and so forth.</p>
<h2><a class="header" href="#inductive-cycles-with-no-base-case" id="inductive-cycles-with-no-base-case">Inductive cycles with no base case</a></h2>
<p>It is interesting to look at what happens without the base case. Consider this
program:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait B { }
impl&lt;T: B&gt; B for Vec&lt;T&gt; { }
<span class="boring">}
</span></code></pre></pre>
<p>In this case, there is no base case -- this means that in fact there are no
solutions at all to the query <code>?X: B</code>. The reason is that the only type that
could match would be a type of infinite size like <code>Vec&lt;Vec&lt;Vec&lt;...&gt;&gt;&gt;: B</code>, where
the chain of <code>Vec</code> never terminates.</p>
<p>In our solver, this will work out just fine. We will wind up recursing
and encountering a cycle. This will be treated as an error in the first
iteration -- and then, at the end, we'll still have an error. This means
that we've reached a fixed point, and we can stop.</p>
<h2><a class="header" href="#inductive-cycles-when-do-we-ever-terminate" id="inductive-cycles-when-do-we-ever-terminate">Inductive cycles: when do we ever terminate</a></h2>
<p>You might be wondering whether there are any examples of inductive cycles that
actually terminate successfully and without ambiguity. In fact, there are very
few, but you can construct an example like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait C { }
impl&lt;T: C + D&gt; C for Vec&lt;T&gt; { }
impl C for u32 { }

trait D { }
<span class="boring">}
</span></code></pre></pre>
<p>In this case, the only valid result of <code>Implemented(?X: C)</code> is <code>?X = u32</code>. It can't
be <code>Vec&lt;u32&gt;</code> because <code>Implemented(u32: D)</code> is not true.</p>
<p>How does this work out with the recursive solver? In the first iteration,
we wind up with <code>?X = u32</code>, but we do encounter a cycle:</p>
<ul>
<li>proving <code>Implemented(?X: C)</code> has two possibilities...
<ul>
<li><code>?X = Vec&lt;?Y&gt;</code> and <code>Implemented(?Y: C)</code>, which is a cycle (error, at least in this iteration)</li>
<li><code>?X = u32</code>, succeeds</li>
</ul>
</li>
</ul>
<p>So then we try the next iteration:</p>
<ul>
<li>proving <code>Implemented(?X: C)</code> has two possibilities...
<ul>
<li><code>?X = Vec&lt;?Y&gt;</code> and <code>Implemented(?Y: C)</code>, which is a cycle, so we use our previous result of <code>?Y = u32</code>
<ul>
<li>we then have to prove <code>Implemented(u32: D)</code>, which fails</li>
</ul>
</li>
<li><code>?X = u32</code>, succeeds</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#the-search-graph-and-caching" id="the-search-graph-and-caching">The search graph and caching</a></h1>
<p>So now we have a good idea of <a href="recursive/./inductive_cycles.html">what behavior we expect from cycles</a>, or
at least inductive cycles (we'll talk about <a href="recursive/./coinduction.html">coinduction</a> later). But how do we
actually implement this? That's where the <a href="https://rust-lang.github.io/chalk/chalk_recursive/fixed_point/search_graph/struct.SearchGraph.html"><code>SearchGraph</code></a> comes into play.</p>
<p>The role of the <a href="https://rust-lang.github.io/chalk/chalk_recursive/fixed_point/search_graph/struct.SearchGraph.html"><code>SearchGraph</code></a> is to store information about each goal that we
are currently solving. Typically, these are goals on the stack -- but other
times, they are goals that are no longer on the stack, but whose results
(because of a cycle) were dependent on something that is still on the stack.
We'll work through some examples to make it all clear.</p>
<h2><a class="header" href="#structure-of-the-search-graph" id="structure-of-the-search-graph">Structure of the search graph</a></h2>
<p>The search graph consists of nodes, each of which is assigned an index called a
<a href="https://rust-lang.github.io/chalk/chalk_recursive/fixed_point/search_graph/struct.DepthFirstNumber.html"><code>DepthFirstNumber</code></a>. The name of this index alludes to the fact that, as we try
to prove a given goal, we are implicitly performing a &quot;depth-first search&quot; over
a graph of subgoals, and the index in the search graph is similar to a pre-order
index on the resulting tree.</p>
<h3><a class="header" href="#example-search-graph" id="example-search-graph">Example search graph</a></h3>
<p>Consider this example trait plus impls:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait A { }
impl&lt;T: A, U: A&gt; A for Result&lt;T, U&gt; { }
impl A for u32 { }
impl A for i32 { }
impl A for f32 { }
<span class="boring">}
</span></code></pre></pre>
<p>If we consider the full set of goals/subgoals that are involved in proving <code>Implemented(Result&lt;u32, i32&gt;: A)</code>, 
it would look like this:</p>
<pre class="mermaid">graph TD
  G1[&quot;Implemented(Result&amp;lt;u32, i32&amp;gt;: A)&lt;br&gt;Pre-order number: 0&lt;br&gt;DepthFirstNumber: 0&quot;]
  G2[&quot;Implemented(u32: A)&lt;br&gt;Pre-order number: 1&lt;br&gt;DepthFirstNumber: 1&quot;]
  G3[&quot;Implemented(i32: A)&lt;br&gt;Pre-order number: 2&lt;br&gt;DepthFirstNumber: 1&quot;]
  G1 --&gt; G2
  G1 --&gt; G3
</pre>
<p>The graph also shows a possible set of pre-order numbers, as well as the
<a href="https://rust-lang.github.io/chalk/chalk_recursive/fixed_point/search_graph/struct.DepthFirstNumber.html"><code>DepthFirstNumber</code></a> that would be used in the search graph. You can see that
they start to diverge. Pre-order numbers uniquely identify each goal in the
graph. In contrast, after we finish proving <code>Implemented(u32: A)</code>, we remove
that node the graph, and hence its <a href="https://rust-lang.github.io/chalk/chalk_recursive/fixed_point/search_graph/struct.DepthFirstNumber.html"><code>DepthFirstNumber</code></a> is re-used.</p>
<h2><a class="header" href="#goal-lifecycle" id="goal-lifecycle">Goal lifecycle</a></h2>
<p>Every goal that we prove in the recursive solver goes through the following states:</p>
<pre class="mermaid">graph TD
  NewlyCreated[&quot;Newly created&quot;]
  OnStack[&quot;On stack and in the search graph&quot;]
  InGraph[&quot;Popped from stack but retained in search graph&quot;]
  ProcessingComplete[&quot;Processing complete&quot;]
  InCache[&quot;Stored in the cache&quot;]
  NewlyCreated --&gt; OnStack
  OnStack -- Explore all program clauses for the goal --&gt; ProcessingComplete
  ProcessingComplete -- If node is a participant in a cycle --&gt; InGraph
  InGraph -- On next iteration --&gt; OnStack
  ProcessingComplete -- If not part of a cycle or when fixed-point is reached --&gt; InCache
</pre>
<p>At first, we create the goal and push it onto the stack, and we also add it to
the search graph. We then explore each of the relevant program clauses to try and
find the solution(s) to the goal. Along the way we update the overall solution:</p>
<ul>
<li>If there are no valid solutions, then the result is an error.</li>
<li>If there is exactly one solution, then we remember it as the unique solution.</li>
<li>If there are multiple distinct solutions, the result is &quot;ambiguous&quot;.</li>
</ul>
<p>While we are doing this solving, we also track what other goals this goal winds
up depending on. In particular, we are looking to see whether it winds up as a
participant in a cycle -- that is, if it depends on any goals further up the
goal stack.</p>
<p>If, when we're done with all program clauses, the goal never participated in any
cycles, then we have reached our final solution. We can take that result and put
it into the cache. The next time we look for a solution to this goal, we'll
check that cache and return the result.</p>
<p>But otherwise, if the goal <em>was</em> a participant in a cycle, then we have to
iterate, as described in the <a href="recursive/./inductive_cycles.html">section on cycles</a>. In that
case, we keep the goal in the search graph, but we remove it from the stack.
This allows the search graph to serve as a kind of &quot;interim cache&quot;. If, as we
continue to search through the other nodes that remain on the stack, we have to
solve this same goal again, we will find it in the search cache and re-use the
result.</p>
<p>For goals that are participants in a cycle, when the cycle reaches its
fixed-point (i.e., the top-most node has stopped changing), we go through and
take all the results for all the subgoals (which are still present in the search
graph) and move them all into the &quot;final cache&quot;.</p>
<p>In other words, any result that is present in the <em>search graph</em> can be
considered an &quot;interim cache&quot;, with a result that is still being determined and
may be dependent on other goals on the stack. Once the goal is completely
processed, it is moved to the cache field where others can use it.</p>
<h2><a class="header" href="#processing-a-single-goal-a-flow-chart" id="processing-a-single-goal-a-flow-chart">Processing a single goal, a flow chart</a></h2>
<p>Whenever we are asked to solve a goal, these are the steps we take:</p>
<pre class="mermaid">graph TD
  GoalInGraph[&quot;Goal in search graph?&quot;]
  FlagAsHead[&quot;If goal is on stack,&lt;br&gt;flag as head of cycle.&quot;]
  ReturnCurrentResult[&quot;Return result from&lt;br&gt;search graph.&quot;]
  PushOnStack[&quot;Push goal on stack,&lt;br&gt;add to the search graph with index `G`,&lt;br&gt;initial result is error&quot;]
  ProcessEachClause[&quot;Process each program clause in turn,&lt;br&gt;computing result,&lt;br&gt;and tracking `Minimums`&quot;]
  IsCycleParticipant[&quot;Is G dependent on&lt;br&gt;goal lower in stack?&quot;]
  StoreInCache[&quot;Move results `G..` &lt;br&gt;from search graph to cache&quot;]
  PopFromCacheNotGraph[&quot;Pop goal from stack&lt;br&gt;but leave in search graph&quot;]
  CompareResult[&quot;Did result change from&lt;br&gt;what is stored in search graph?&quot;]
  UpdateSearchGraph[&quot;Update stored result&lt;br&gt;in search graph&quot;]
  ClearPreviousIteration[&quot;Clear search graph nodes `G+1..`&lt;br&gt;from previous iteration&quot;]

  GoalInGraph -- Yes --&gt; FlagAsHead
  FlagAsHead --&gt; ReturnCurrentResult
  GoalInGraph -- No, not in the graph --&gt; PushOnStack
  PushOnStack --&gt; ProcessEachClause
  ProcessEachClause -- Is head of cycle --&gt; CompareResult
  ProcessEachClause -- Not head of cycle --&gt; IsCycleParticipant
  CompareResult -- No, fixed-point reached --&gt; IsCycleParticipant
  CompareResult -- Yes, result changed --&gt; UpdateSearchGraph
  UpdateSearchGraph --&gt; ClearPreviousIteration
  ClearPreviousIteration --&gt; ProcessEachClause
  IsCycleParticipant -- No --&gt; StoreInCache
  IsCycleParticipant -- Yes --&gt; PopFromCacheNotGraph
</pre>
<h2><a class="header" href="#starting-to-prove-a-goal" id="starting-to-prove-a-goal">Starting to prove a goal</a></h2>
<p>The first thing we do when proving some goal G is to check the search graph to
see if there is already a node for this goal.</p>
<h3><a class="header" href="#if-there-is-a-node-for-g" id="if-there-is-a-node-for-g">If there is a node for G</a></h3>
<p>If there is a node for G, that indicates that there is some sort of cycle
involved in the graph. For now, we will defer this case, and come back to it
after we've explained what happens without cycles.</p>
<h3><a class="header" href="#if-there-is-no-node-for-g-pushing-a-new-goal-onto-the-stack" id="if-there-is-no-node-for-g-pushing-a-new-goal-onto-the-stack">If there is no node for G: pushing a new goal onto the stack</a></h3>
<p>If there is no node for G in the graph, then we have a new subgoal to add
to the graph. We will first push a new entry onto the <a href="recursive/./stack.html">stack</a>, yielding some new
stack depth <code>d</code>. Then we create a new <a href="https://rust-lang.github.io/chalk/chalk_recursive/fixed_point/search_graph/struct.Node.html"><code>Node</code></a> in the search graph. It will be
assigned the next available <a href="https://rust-lang.github.io/chalk/chalk_recursive/fixed_point/search_graph/struct.DepthFirstNumber.html"><code>DepthFirstNumber</code></a>. The search graph node contains a field
<a href="https://rust-lang.github.io/chalk/chalk_recursive/fixed_point/search_graph/struct.Node.html#structfield.stack_depth"><code>stack_depth</code></a> that will be set to <code>Some(d)</code>, where <code>d</code> is the depth of the
node on the stack.</p>
<p>The search graph node also stores the &quot;current solution&quot; for the given goal. As
described in the search on <a href="recursive/./inductive_cycles.html">inductive cycles</a>, this solution starts out
as an error but may be gradually widened as we iterate, if we find solutions.</p>
<h2><a class="header" href="#tracking-dependencies" id="tracking-dependencies">Tracking dependencies</a></h2>
<p>The way that we track dependencies is through a structure called the
<a href="https://rust-lang.github.io/chalk/chalk_recursive/fixed_point/struct.Minimums.html"><code>Minimums</code></a>. The name comes from the idea that it is tracking the minimum
<a href="https://rust-lang.github.io/chalk/chalk_recursive/fixed_point/search_graph/struct.DepthFirstNumber.html"><code>DepthFirstNumber</code></a> of any goal whose result we depended on. The minimum for a
goal G1 starts out as G1, since its result depends on itself, but if it winds up
recursively processing some goal G2 that is on the stack, then the minimum will
be adjusted to G2.</p>
<p>Along with the interim solution, the search graph node for a given goal also
stores the <a href="https://rust-lang.github.io/chalk/chalk_recursive/fixed_point/struct.Minimums.html"><code>Minimums</code></a> that resulted from computing that interim solution
(i.e., what goals did that solution depend on). If some goal G1 winds up
recursively invoking some goal G2 that is in the search graph but <em>not</em> present
on the stack, then we update the current <a href="https://rust-lang.github.io/chalk/chalk_recursive/fixed_point/struct.Minimums.html"><code>Minimums</code></a> with the values stored in
the search graph.</p>
<h2><a class="header" href="#removing-nodes-from-the-graph" id="removing-nodes-from-the-graph">Removing nodes from the graph</a></h2>
<p>Once we complete the processing for a node, it needs to be removed from the
processing stack. But we wish to leave it in the graph if it is dependent on
something else that is already on the stack. We do that just by checking the
<a href="https://rust-lang.github.io/chalk/chalk_recursive/fixed_point/struct.Minimums.html"><code>Minimums</code></a> value to see if it is less than the current goal.</p>
<h1><a class="header" href="#coinduction-1" id="coinduction-1">Coinduction</a></h1>
<p>This sub-chapter is meant to describe the current handling of coinductive goals in the recursive solver rather than providing an extensive overview over the theoretical backgrounds and ideas.
It follows the description in <a href="https://github.com/rust-lang/chalk/issues/399#issuecomment-643420016">this GitHub comment</a> and the Zulip topic linked there.
In general, coinductive cycles can arise for well-formedness checking and autotraits.
Therefore, correctly handling coinductive cycles is necessary to model the Rust trait system in its entirety.</p>
<h2><a class="header" href="#general-idea" id="general-idea">General Idea</a></h2>
<p>Coinductive cycles can be handled the same way as inductive cycles described <a href="recursive/./inductive_cycles.html">before</a>.
The only difference is the start value for coinductive goals.
Whereas inductive goals start with a negative result and are iterated until a least fixed-point is found, coinductive goals start with a positive result (i.e. a unique solution with identity substitution).
This negative result is then iterated until a greatest fixed-point is reached.</p>
<h2><a class="header" href="#mixed-co-inductive-and-inductive-cycles" id="mixed-co-inductive-and-inductive-cycles">Mixed co-inductive and inductive Cycles</a></h2>
<p>As described above, the handling of inductive and coindutive cycles differs only in the start value from which the computation begins.
Thus, it might seem reasonable to have mixed inductive and coinductive cycles as all goals inside these cycles would be handled the same way anyway.
Unfortunately, this is not possible for the kind of logic that Chalk is based on (i.e. essentially an extension of co-LP for Hereditary Harrop clauses, cf. <a href="https://link.springer.com/chapter/10.1007%2F978-3-540-73420-8_42">this paper</a>).</p>
<p>There is fundamental difference between results for inductive cycles and results for coinductive cycles of goals.
An inductive goal is provable if and only if there exists a proof for it consisting of a finite chain of derivations from axioms that are members of the least-fixed point of the underlying logic program.
On the other hand, coinductive goals are provable if there exists an at most infinite derivation starting from the axioms that proves it (this includes in particular all finite derivations).
This infinite derivation is then part of the greatest fixed-point of the logic program.
As infinite derivations are not feasible to compute, it is enough to show that such a derivation contains no contradiction.</p>
<p>A simple example <code>X :- X.</code> (with <code>X</code> a free variable) is thus not provable by inductive reasoning (the least solution/lfp for this is the empty solution, a failure) but it is provable by coinductive reasoning (the greatest solution/gfp is the universe, i.e. all values).</p>
<p>This difference between inductive and coinductive results becomes a problem when combined in a single cycle.
Consider a coinductive goal <code>CG</code> and an inductive goal <code>IG</code>. Now consider the simplest possible mixed cycle:</p>
<pre><code class="language-notrust">CG :- IG
IG :- CG
</code></pre>
<p>It is apparent, that there can not exist a solution for <code>IG</code> as the cyclic dependency prevents a finite proof derivation.
In contrast to that, <code>CG</code> could potentially be provable as the derivation <em><code>CG</code> if <code>IG</code> if <code>CG</code> if <code>IG</code> ...</em> is infinite and based only on the two axioms.
As a result, <code>CG</code> would hold whereas <code>IG</code> would not hold, creating a contradiction.</p>
<p>The simplest solution to this problem, proposed by Simon et al. in <a href="https://link.springer.com/chapter/10.1007%2F978-3-540-73420-8_42">their paper about co-LP</a>, is to disallow mixed inductive and coinductive cycles.
This approach is also used by Chalk.</p>
<h2><a class="header" href="#prevention-of-invalid-results" id="prevention-of-invalid-results">Prevention of Invalid Results</a></h2>
<p>The problem of invalid results propagated outside of the coinductive cycle is also described in the <a href="recursive/../engine/logic/coinduction.html">Coinduction chapter</a> for the SLG solver alongside the rather complex handling used with it.
Whereas the SLG solver introduces <a href="recursive/../engine/logic/coinduction.html#nikos-proposed-solution">special constructs</a> to handle coinduction, it is sufficient for the recursive solver to use the same logic for inductive and coinductive cycles.
The following is a description of how this works in more detail.</p>
<h3><a class="header" href="#the-problem-1" id="the-problem-1">The Problem</a></h3>
<p>The problem arises if a solution that is purely based on the positive starting value for the coinductive cycle is cached (or tabled in logic programming terms) and as such propagated to other goals that are possibly reliant on this. An example where all clause goals are assumedly coinductive may look like this (cf. the test case <code>coinduction::coinductive_unsound1</code>):</p>
<pre><code class="language-notrust">C :- C1.
C :- C2.
C1 :- C2, C3.
C2 :- C1.
</code></pre>
<p>The following is a computation to find out whether there exists a type that implements <code>C</code>.
Here the implementation of <code>C</code> may be proved by either showing that the type implements <code>C1</code> or <code>C2</code>.</p>
<ul>
<li>Start proving <code>C</code> by trying to prove <code>C1</code>:
<ul>
<li>For <code>C1</code> try to prove <code>C2</code> and <code>C3</code>:
<ul>
<li>Start with <code>C2</code>. For <code>C2</code> we need to prove <code>C1</code>:
<ul>
<li>This is a (coinductive) cycle. Assume that <code>C1</code> holds, i.e. use the positive start value.</li>
</ul>
</li>
<li>Based on this <code>C2</code> also holds. If this case is not handled specifically, the solution for <code>C2</code> is cached without a reference to the solution for <code>C1</code> on which it depends.</li>
<li>Now try to prove <code>C3</code>:
<ul>
<li>Find that there is no way do so from the given axioms.</li>
</ul>
</li>
<li>Thus, there exists no solution for <code>C3</code> and the computation fails. This valid result is cached and lifted back up.</li>
</ul>
</li>
<li>Due to the failure of <code>C3</code> there is also no solution for <code>C1</code>. This failure is also cached correctly and lifted back up. The cached solution for <code>C2</code> has now become invalid as it depends on a positive result for <code>C1</code>.</li>
</ul>
</li>
<li>As a result of the failure for <code>C1</code>, <code>C</code> can not be proved from <code>C1</code>. Try proving <code>C</code> from <code>C2</code> instead:
<ul>
<li>Find the cached result that <code>C2</code> has a solution and lift it back up.</li>
</ul>
</li>
<li>Due to the solution for <code>C2</code>, <code>C</code> is also proved with the same solution.</li>
<li>Stop with this positive but invalid result for <code>C</code>.</li>
</ul>
<h3><a class="header" href="#the-solution" id="the-solution">The Solution</a></h3>
<p>The above example should make it evident that the caching of found solutions in coinductive cycles can lead to invalid results and should therefore be prevented.
This can be achieved by delaying the caching of all results inside the coinductive cycle until it is clear whether the start of the cycle (i.e. <code>C1</code> in the example above) is provable (cf. the handling of inductive cycles <a href="recursive/./inductive_cycles.html">before</a>).
If the start of the cycle can be proven by the results of the cycle and related subgoals then the assumption about it was correct and thus all results for goals inside the cycle are also valid.
If, however, the start of the cycle can not be proved, i.e. the initial assumption was false, then a subset of the found solutions for the coinductive cycle may be invalid (i.e. the solution for <code>C2</code> in the example).</p>
<p>To remove such invalid results, the cycle is restarted with a negative result for the cycle start.
With this approach, it is possible to remove all invalid result that would otherwise depend on the disproved cycle assumption.
To allow for the cycle to be restarted correctly, all nodes in the search graph after the cycle start are deleted.</p>
<p>With this procedure, the example is handled as follows:</p>
<ul>
<li>Start proving <code>C</code> with <code>C1</code>:
<ul>
<li>For <code>C1</code> prove <code>C2</code> and <code>C3</code>:
<ul>
<li>For <code>C2</code> prove <code>C1</code>:
<ul>
<li>This is a coinductive cycle. Assume that <code>C1</code> holds.</li>
</ul>
</li>
<li>Thus <code>C2</code> also holds. Delay the caching of the result about <code>C2</code>.</li>
<li>There is no way to prove <code>C3</code>. Cache this result and lift the failure up.</li>
</ul>
</li>
<li>Due to the failure of <code>C3</code> there is also no solution for <code>C1</code>. Set <code>C1</code> to a negative result and restart the cycle.
<ul>
<li>For <code>C2</code> prove <code>C1</code>:
<ul>
<li><code>C1</code> has now a negative result.</li>
</ul>
</li>
<li>Thus, <code>C2</code> also has a negative result which is not yet cached.</li>
<li>Find the already cached negative result for <code>C3</code>.</li>
</ul>
</li>
<li>Nothing changed regarding <code>C1</code> (this would indicate a negative cycle which is currently  not allowed) and the negative result for <code>C1</code> and <code>C2</code> are cached. Lift the negative result for <code>C1</code> back up.</li>
</ul>
</li>
<li>Start proving <code>C</code> with <code>C2</code>:
<ul>
<li>Find negative cached result for <code>C2</code>. Lift the result back up.</li>
</ul>
</li>
<li>Neither <code>C1</code> nor <code>C2</code> have a positive result. Stop with the valid disproof of <code>C</code>.</li>
</ul>
<h1><a class="header" href="#glossary-and-terminology" id="glossary-and-terminology">Glossary and terminology</a></h1>
<p>This is a glossary of terminology (possibly) used in the chalk crate.</p>
<h2><a class="header" href="#notation-1" id="notation-1">Notation</a></h2>
<h3><a class="header" href="#basic-notation" id="basic-notation">Basic notation</a></h3>
<table><thead><tr><th>Notation</th><th>Meaning</th></tr></thead><tbody>
<tr><td><code>?0</code></td><td><a href="./types/rust_types.html#inference-variables">Type inference variable</a></td></tr>
<tr><td><code>^0</code>, <code>^1.0</code></td><td><a href="./types/rust_types.html#bound-variables">Bound variable</a>; bound in a <a href="glossary.html#debruijn-index"><code>forall</code></a></td></tr>
<tr><td><code>!0</code>, <code>!1.0</code></td><td><a href="./types/rust_types.html#placeholders">Placeholder</a></td></tr>
<tr><td><code>A :- B</code></td><td><a href="./clauses/goals_and_clauses.html">Clause</a>; A is true if B is true</td></tr>
</tbody></table>
<h3><a class="header" href="#rules" id="rules">Rules</a></h3>
<ul>
<li><code>forall&lt;T&gt; { (Vec&lt;T&gt;: Clone) :- (T: Clone)</code>: for every <code>T</code>, <code>Vec&lt;T&gt;</code>
implements <code>Clone</code> if <code>T</code> implements <code>Clone</code></li>
</ul>
<h3><a class="header" href="#queries" id="queries">Queries</a></h3>
<ul>
<li><code>Vec&lt;i32&gt;: Clone</code>: does <code>Vec&lt;i32&gt;</code> implement <code>Clone</code>?</li>
<li><code>exists&lt;T&gt; { Vec&lt;T&gt;: Clone }</code>: does there exist a <code>T</code> such that <code>Vec&lt;T&gt;</code>
implements <code>Clone</code>?</li>
</ul>
<h2><a class="header" href="#binary-connective" id="binary-connective">Binary connective</a></h2>
<p>There are sixteen logical connectives on two boolean variables. The most
interesting in this context are listed below. There is also a truth table given
which encodes the possible results of the operations like this</p>
<pre><code class="language-notrust">f(false, false) f(false, true) f(true, false) f(true, true).
</code></pre>
<p>As a shorthand the resulting truth table is encoded with <code>true = 1</code> and <code>false = 0</code>.</p>
<table><thead><tr><th>Truth table</th><th>Operator symbol</th><th>Common name</th></tr></thead><tbody>
<tr><td>0001</td><td>&amp;&amp;</td><td>Conjunction; and</td></tr>
<tr><td>1001</td><td>&lt;=&gt;</td><td>Equivalence; if and only if; iff</td></tr>
<tr><td>1101</td><td>=&gt;</td><td>Implication; if ... then</td></tr>
</tbody></table>
<h2><a class="header" href="#binder" id="binder">Binder</a></h2>
<p>A binder is an expression that binds a literal to a certain expression.
Examples for binders:</p>
<ul>
<li>The universal quantifier <code>forall(a)</code> states that a certain condition holds for
all allowed values for <code>a</code>.</li>
<li>A function definition <code>f(x) = a * x</code> is a binder for the variable <code>x</code> whereas
<code>a</code> is a free variable.</li>
<li>A sum <code>\sum_n x_n</code> binds the index variable <code>n</code>.</li>
</ul>
<h2><a class="header" href="#canonical-form" id="canonical-form">Canonical Form</a></h2>
<p>A formula in canonical form has the property that its De Bruijn indices are
minimized. For example when the formula <code>forall&lt;0, 1&gt; { 0: A &amp;&amp; 1: B }</code> is
processed, both &quot;branches&quot; <code>0: A</code> and <code>1: B</code> are processed individually. The
first branch would be in canonical form, the second branch not since the
occurring De Bruijn index <code>1</code> could be replaced with <code>0</code>.</p>
<h2><a class="header" href="#clause" id="clause">Clause</a></h2>
<p>A clause is the disjunction of several expressions. For example the clause
<code>condition_1 || condition_2 || ...</code> states that at least one of the conditions
holds.</p>
<p>There are two notable special cases of clauses. A <em>Horn clause</em> has at most one
positive literal. A <em>Definite clause</em> has exactly one positive literal.</p>
<p><em>Horn clauses</em> can be written in the form <code>A || !B || !C || ...</code> with <code>A</code> being
the optional positive literal. Due to the equivalence <code>(P =&gt; Q) &lt;=&gt; (!P || Q)</code>
the clause can be expressed as <code>B &amp;&amp; C &amp;&amp; ... =&gt; A</code> which means that A is true
if <code>B</code>, <code>C</code>, etc. are all true. All rules in chalk are in this form. For example</p>
<pre><code class="language-rust ignore">struct A&lt;T&gt; {}
impl&lt;T&gt; B for A&lt;T&gt; where T: C + D {}
</code></pre>
<p>is expressed as the <em>Horn clause</em> <code>(T: C) &amp;&amp; (T: D) =&gt; (A&lt;T&gt;: B)</code>. This formula
has to hold for all values of <code>T</code>. The second example</p>
<pre><code class="language-rust ignore">struct A {}
impl B for A {}
impl C for A {}
</code></pre>
<p>is expressed as the <em>Horn clause</em> <code>(A: B) &amp;&amp; (A: C)</code>. Note the missing
consequence.</p>
<h2><a class="header" href="#de-bruijn-index" id="de-bruijn-index">De Bruijn Index</a></h2>
<p>De Bruijn indices numerate literals that are bound in an unambiguous way. The
literal is given the number of its binder. The indices start at zero from the
innermost binder increasing from the inside out.</p>
<p>Given the example <code>forall&lt;T&gt; { exists&lt;U&gt; { T: Foo&lt;Item=U&gt; } }</code> the
literal names <code>U</code> and <code>T</code> are replaced with <code>0</code> and <code>1</code> respectively and the names are erased from the binders: <code>forall&lt;_&gt; { exists&lt;_&gt; { 1: Foo&lt;Item=0&gt; } }</code>.</p>
<p>As another example, in <code>forall&lt;X, Y&gt; { forall &lt;Z&gt; { X } }</code>, <code>X</code> is represented
as <code>^1.0</code>. The <code>1</code> represents the De Bruijn index of the variable and the <code>0</code>
represents the index in that scope: <code>X</code> is bound in the second scope counting
from where it is referenced, and it is the first variable bound in that scope.</p>
<h2><a class="header" href="#formula" id="formula">Formula</a></h2>
<p>A formula is a logical expression consisting of literals and constants connected
by logical operators.</p>
<h2><a class="header" href="#goal" id="goal">Goal</a></h2>
<p>With a set of type variables, given types, traits and impls, a goal specifies a
problem which is solved by finding types for the type variables that satisfy the
formula. For example the goal <code>exists&lt;T&gt; { T: u32 }</code> can be solved with <code>T = u32</code>.</p>
<h2><a class="header" href="#literal" id="literal">Literal</a></h2>
<p>A literal is an atomic element of a formula together with the constants <code>true</code>
and <code>false</code>. It is equivalent to a variable in an algebraic expressions. Note
that literals are <em>not</em> the same as the type variables used in specifying a
goal.</p>
<h2><a class="header" href="#normal-form" id="normal-form">Normal form</a></h2>
<p>To say that a statement is in a certain <em>normal form</em> means that the pattern in
which the subformulas are arranged fulfill certain rules. The individual patterns
have different advantages for their manipulation.</p>
<h3><a class="header" href="#conjunctive-normal-form-cnf" id="conjunctive-normal-form-cnf">Conjunctive normal form (CNF)</a></h3>
<p>A formula in CNF is a conjunction of disjunctions. For example <code>(x1 || x2 || x3) &amp;&amp; (x4 || x5 || x6)</code> is in CNF.</p>
<h3><a class="header" href="#disjunctive-normal-form-dnf" id="disjunctive-normal-form-dnf">Disjunctive normal form (DNF)</a></h3>
<p>A formula in DNF is a disjunction of conjunctions. For example <code>(x1 &amp;&amp; x2 &amp;&amp; x3) || (x4 &amp;&amp; x5 &amp;&amp; x6)</code> is in DNF.</p>
<h3><a class="header" href="#negation-normal-form-nnf" id="negation-normal-form-nnf">Negation normal form (NNF)</a></h3>
<p>A formula in NNF consists only of literals, the connectives <code>&amp;&amp;</code> and <code>||</code> and
<code>true</code> and <code>false</code>.</p>
<h3><a class="header" href="#prenex-normal-form-pnf" id="prenex-normal-form-pnf">Prenex normal form (PNF)</a></h3>
<p>All quantifiers are on the highest level of a formula and do not occur inside
the subformulas of the expression.</p>
<ul>
<li><code>forall(x). exists(y). forall(z). P(x) &amp;&amp; P(y) =&gt; P(z)</code> is in PNF.</li>
<li><code>(exists(x). P(x)) =&gt; exists(y). P(y) &amp;&amp; forall(z). P(z)</code> is <em>not</em> in PNF.</li>
</ul>
<h2><a class="header" href="#normalization" id="normalization">Normalization</a></h2>
<p>Normalization is the process of converting an associated type to a concrete
type. In the case of an iterator this would mean that the associated <code>Item</code> type
is replaced with something more meaningful with respect to the individual
context (e.g. <code>u32</code>).</p>
<h2><a class="header" href="#projection" id="projection">Projection</a></h2>
<p>Projection is the reference to a field or (in the context of Rust) to a type
from another type.</p>
<h2><a class="header" href="#satisfiability" id="satisfiability">Satisfiability</a></h2>
<p>A formula is satisfiable iff there is a valuation for the atoms inside the
formula that makes it true.</p>
<h2><a class="header" href="#unification" id="unification">Unification</a></h2>
<p>Unification is the process of solving a formula. That means unification finds
values for all the free literals of the formula that satisfy it. In the context
of chalk the values refer to types.</p>
<h2><a class="header" href="#universe" id="universe">Universe</a></h2>
<p>A universe sets the scope in which a particular variable name is bound. (See
<em>Binder</em>.) A universe can encapsulate other universes. A universe can
be contained by only one parent universe. Universes have therefore a tree-like
structure. A universe can access the variable names of itself and the parent
universes but not of the sibling universes.</p>
<h2><a class="header" href="#well-formed" id="well-formed">Well-formed</a></h2>
<p>A formula is well-formed if it is constructed according to a predefined set of
syntactic rules.</p>
<p>In the context of the Rust type system this means that basic rules for type
construction have to be met. Two examples: 1) Given a struct definition</p>
<pre><code class="language-rust ignore">struct HashSet&lt;T: Hash&gt;
</code></pre>
<p>then a type <code>HashSet&lt;i32&gt;</code> is well-formed since <code>i32</code> implements <code>Hash</code>. A type
<code>HashSet&lt;NoHash&gt;</code> with a type <code>NoHash</code> that does not implement the <code>Hash</code> trait
is not well-formed.</p>
<ol start="2">
<li>If a trait demands by its definition the implementation of further traits
for a certain type then these secondary traits have to be implemented as well.
If a type <code>Foo</code> implements <code>trait Eq: PartialEq</code> then this type has to implement
<code>trait PartialEq</code> as well. If it does not, then the type <code>Foo: Eq</code> is not well
formed according to Rust type building rules.</li>
</ol>
<h2><a class="header" href="#quantifier" id="quantifier">Quantifier</a></h2>
<h3><a class="header" href="#existential-quantifier" id="existential-quantifier">Existential quantifier</a></h3>
<p>A formula with the existential quantifier <code>exists(x). P(x)</code> is satisfiable if
and only if there exists at least one value for all possible values of x which
satisfies the subformula <code>P(x)</code>.</p>
<p>In the context of chalk, the existential quantifier usually demands the
existence of exactly one instance (i.e. type) that satisfies the formula (i.e.
type constraints). More than one instance means that the result is ambiguous.</p>
<h3><a class="header" href="#universal-quantifier" id="universal-quantifier">Universal quantifier</a></h3>
<p>A formula with the universal quantifier <code>forall(x). P(x)</code> is satisfiable
if and only if the subformula <code>P(x)</code> is true for all possible values for x.</p>
<h3><a class="header" href="#helpful-equivalences" id="helpful-equivalences">Helpful equivalences</a></h3>
<ul>
<li><code>not(forall(x). P(x)) &lt;=&gt; exists(x). not(P(x))</code></li>
<li><code>not(exists(x). P(x)) &lt;=&gt; forall(x). not(P(x))</code></li>
</ul>
<h2><a class="header" href="#skolemization" id="skolemization">Skolemization</a></h2>
<p>Skolemization is a technique of transferring a logical formula with existential
quantifiers to a statement without them. The resulting statement is in general
not equivalent to the original statement but equisatisfiable.</p>
<h2><a class="header" href="#validity" id="validity">Validity</a></h2>
<p>An argument (<em>premise</em> therefore <em>conclusion</em>) is valid iff there is no
valuation which makes the premise true and the conclusion false.</p>
<p>Valid: <code>A &amp;&amp; B therefore A || B</code>. Invalid: <code>A || B therefore A &amp;&amp; B</code> because the
valuation <code>A = true, B = false</code> makes the premise true and the conclusion false.</p>
<h2><a class="header" href="#valuation" id="valuation">Valuation</a></h2>
<p>A valuation is an assignment of values to all variables inside a logical
formula.</p>
<h2><a class="header" href="#fixed-points" id="fixed-points">Fixed-Points</a></h2>
<p>A fixed-point of a function <code>f</code> is a value <code>x</code> for which <code>f(x)=x</code>.
Similarly a pre-fixed-point is defined as <code>x ≤ f(x)</code>, whereas for a post-fixed-point it holds that <code>f(x) ≤ x</code>.</p>
<p>A least fixed-point (lfp) of <code>f</code> is the fixed-point <code>x</code> of <code>f</code> for which all other fixed-points <code>y</code> are greater or equal (i.e. if <code>f(y)=y</code> then <code>x ≤ y</code>).
Similarly, a greatest fixed-point (gfp) is greater or equal than all other fixed-points.
If <code>f</code> is a function on sets, the least fixed-point is defined as the intersection of all pre-fixed-points, which are then defined as sets <code>x</code> for which <code>x ⊆ f(x)</code>.
The greatest fixed-point is in this case the union of all post-fixed-points, respectively.</p>
<p>This simple definition of lfp and gfp can also be lifted to general lattices.
The results for Chalk goals form such a lattice and, thus, every solver for such goals tries to find such fixed-points.</p>
<h1><a class="header" href="#bibliography" id="bibliography">Bibliography</a></h1>
<p>If you'd like to read more background material, here are some
recommended texts and papers:</p>
<h2><a class="header" href="#blog-posts" id="blog-posts">Blog Posts</a></h2>
<ul>
<li><a href="https://smallcultfollowing.com/babysteps/blog/2017/01/26/lowering-rust-traits-to-logic/">Lowering Rust traits to logic</a></li>
<li><a href="https://smallcultfollowing.com/babysteps/blog/2017/03/25/unification-in-chalk-part-1/">Unification in Chalk, part 1</a></li>
<li><a href="https://smallcultfollowing.com/babysteps/blog/2017/04/23/unification-in-chalk-part-2/">Unification in Chalk, part 2</a></li>
<li><a href="https://aturon.github.io/blog/2017/04/24/negative-chalk/">Negative reasoning in Chalk</a></li>
<li><a href="https://smallcultfollowing.com/babysteps/blog/2017/05/25/query-structure-in-chalk/">Query structure in chalk</a></li>
<li><a href="https://smallcultfollowing.com/babysteps/blog/2017/09/12/tabling-handling-cyclic-queries-in-chalk/">Cyclic queries in chalk</a></li>
<li><a href="https://smallcultfollowing.com/babysteps/blog/2018/01/31/an-on-demand-slg-solver-for-chalk/">An on-demand SLG solver for chalk</a></li>
</ul>
<h2><a class="header" href="#papers" id="papers">Papers</a></h2>
<p><a name="pphhf"></a></p>
<p><a href="https://dl.acm.org/citation.cfm?id=868380">&quot;A proof procedure for the logic of Hereditary Harrop formulas&quot;</a>,
by Gopalan Nadathur. This paper covers the basics of universes,
environments, and Lambda Prolog-style proof search. Quite readable.</p>
<p><a name="slg"></a> </p>
<p><a href="https://dl.acm.org/citation.cfm?id=651202">&quot;A new formulation of tabled resolution with delay&quot;</a>, by
Theresa Swift. This paper gives a kind of abstract treatment of the
SLG formulation that is the basis for our on-demand solver.</p>
<h2><a class="header" href="#books" id="books">Books</a></h2>
<ul>
<li>&quot;Introduction to Formal Logic&quot;, Peter Smith</li>
<li>&quot;Handbook of Practical Logic and Automated Reasoning&quot;, John Harrison</li>
<li>&quot;Types and Programming Languages&quot;, Benjamin C. Pierce</li>
<li><a href="https://www.amazon.com/Programming-Higher-Order-Logic-Dale-Miller/dp/052187940X">Programming with Higher-order Logic</a>, by Dale Miller and Gopalan
Nadathur, covers the key concepts of Lambda prolog. Although it's a
slim little volume, it's the kind of book where you learn something
new every time you open it.</li>
</ul>
<h2><a class="header" href="#incomplete-chapters" id="incomplete-chapters">Incomplete chapters</a></h2>
<p>Some topics yet to be written:</p>
<ul>
<li>Elaborate on the proof procedure</li>
<li>SLG solving – introduce negative reasoning</li>
<li>Go over how trait impls are selected and checked</li>
<li>Add a section on higher-ranked trait bounds</li>
</ul>
<h1><a class="header" href="#publishing-chalk" id="publishing-chalk">Publishing Chalk</a></h1>
<p><strong>Note: this is mostly only useful for maintainers</strong></p>
<p>The following crates get published to crates.io:</p>
<ul>
<li><code>chalk-derive</code></li>
<li><code>chalk-engine</code></li>
<li><code>chalk-ir</code></li>
<li><code>chalk-recursive</code></li>
<li><code>chalk-solve</code></li>
</ul>
<p>The following crates get versioned without publishing:</p>
<ul>
<li><code>chalk-parse</code></li>
<li><code>chalk-integration</code></li>
<li><code>chalk</code> (root directory)</li>
</ul>
<h2><a class="header" href="#release-automation" id="release-automation">Release Automation</a></h2>
<p>Releases are fully automated. Once a week (Sunday at midnight UTC) a GitHub
Actions job is executed which generates the changelog, bumps crate versions, and
publishes the crates. If there have not been any changes since the last version,
the release is skipped. However, if the job is manually triggered then the
release will be published even if there are no changes.</p>
<p>The release pipeline is located in <a href="https://github.com/rust-lang/chalk/blob/master/.github/workflows/publish.yml"><code>publish.yml</code></a>.</p>
<h3><a class="header" href="#changelog-generation" id="changelog-generation">Changelog Generation</a></h3>
<p>The changelog is generated using <a href="https://www.npmjs.com/package/auto-changelog"><code>auto-changelog</code></a> and is stored in
<a href="https://github.com/rust-lang/chalk/blob/master/RELEASES.md"><code>RELEASES.md</code></a>. The template used for the changelog is in
<a href="https://github.com/rust-lang/chalk/blob/master/releases-template.hbs"><code>releases-template.hbs</code></a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="mermaid.min.js"></script>
        
        <script type="text/javascript" src="mermaid-init.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
