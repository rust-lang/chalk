searchState.loadedDescShard("chalk_ir", 0, "Defines the IR for types and logical predicates.\nAbstract data types, i.e., structs, unions, or …\nThe id for an Abstract Data Type (i.e. structs, unions and …\nAn “alias” type represents some form of type alias, …\nProves <strong>equality</strong> between an alias and a type.\nType is equal to an alias.\nAn alias, which is a trait indirection such as a …\nList of goals that all should hold.\nThe resulting substitution after solving a goal.\nan array type like <code>[T; N]</code>\nConvert a value to a list of parameters.\nThe id for the associated type member of a trait. The …\nan associated type like <code>Iterator::Item</code>; see <code>AssociatedType</code> …\nIndicates that the <code>value</code> is universally quantified over <code>N</code> …\n<code>IntoIterator</code> for binders.\nIdentifies a particular bound variable within a binder. …\nReferences the binding at the given depth. The index is a […\nBound var (e.g. a parameter).\nSee TyKind::BoundVar.\nIndicates something that cannot be proven to be true or …\nWraps a “canonicalized item”. Items are canonicalized …\nA variable kind with universe index.\nList of interned elements.\nId for a specific clause.\nSpecifies how important an implication is.\nA closure.\nId for Rust closures.\nUsed to activate the “compatible modality” rules. …\nConcrete constant value.\nConcrete constant, whose value is known (as opposed to …\nConstants.\nConstant argument\nConstant data, containing the constant’s type and value.\nA constant value, not necessarily concrete.\nCombines a substitution (<code>subst</code>) with a set of region …\nA constraint on lifetimes.\nList of interned elements.\nb &lt;: a\nA coroutine.\nId for Rust coroutines.\nA coroutine witness.\na &lt;: b\nReferences the binder at the given depth. The index is a de\nA “domain goal” is a goal that is directly about Rust, …\nA “domain goal” indicates some base sort of goal that …\nUsed to indicate that a given type is in a downstream …\nA “dyn” type is a trait object type created via the “…\nA “DynTy” represents a trait object (<code>dyn Trait</code>). Trait …\nThe set of assumptions we’ve made so far, and the …\nEquality goal: tries to prove that two values are equal.\nMake two things equal; the rules for doing so are well …\nAn erased lifetime, used by rustc to improve caching when …\nContains the error value\nThis can be used to represent an error, e.g. during name …\nA lifetime that resulted from some error\nExistential quantifier <code>Exists</code>.\nMany of our internal operations (e.g., unification) are an …\nA combination of <code>Fallible</code> and <code>Floundered</code>.\nDifferent kinds of float types.\nIndicates that the complete set of program clauses for …\nFloundered. See <code>chalk_ir::Floundered</code>.\na function definition\nFunction definition id.\nfor&lt;’a…’z&gt; X – all binders are instantiated at …\nA function signature.\nA wrapper for the substs on a Fn.\nUniversal quantifier <code>ForAll</code>.\nforeign types\nId for foreign types.\nChecks whether a type or trait ref can be derived from the …\nTrue if the trait ref can be derived from in-scope where …\nA function type such as <code>for&lt;&#39;a&gt; fn(&amp;&#39;a u32)</code>. Note that “…\nA generic argument, see <code>GenericArgData</code> for more …\nGeneric arguments data.\nA general goal; this is the full range of questions you …\nA general goal; this is the full range of questions you …\nList of interned elements.\nDoes the type contain a ConstValue with an InferenceVar\nDoes the type contain a ConstValue Placeholder\nDoes the type contain an unevaluated const projection\nDoes the type contain an error\nTrue when the type contains free names local to a …\nTrue when the type has free lifetimes related to a local …\nDoes the type contain any free lifetimes\nDoes the type contain any form of projection\nTrue when the type contains an erased lifetime\nDoes the type contain an error lifetime\nDoes the type contain a lifetime with an InferenceVar\nTrue when the type contains lifetimes that will be …\nDoes the type contain a lifetime with a Placeholder\nDoes the type contain an InferenceVar\nDoes the type contain an opaque type\nDoes the type contain a Placeholder TyKind\nDoes the type contain a projection of an associated type\nHigh priority, the solver should prioritize this.\nSimple goal that is true if the where clause is true.\nInnermost index.\nThe id for an impl.\nType implements a trait.\nA goal that holds given some clauses (like an …\nA goal with an environment to solve it in.\nA type, lifetime or constant whose value is being inferred.\nInference variable defined in the current inference …\nConstant whose value is being inferred.\nLifetime whose value is being inferred.\nDifferent signed int types.\na == b\nTrue if a type and its input types are fully visible, …\nTrue if a type is considered to have been “defined” by …\nTrue if a type is <em>not</em> considered to have been “defined”…\nA Rust lifetime.\nLifetime argument\nLifetime data, including what kind of lifetime it is and …\nLifetime outlives, which for <code>&#39;a: &#39;b</code> checks that the …\nOne lifetime outlives another.\nOutlives constraint <code>&#39;a: &#39;b</code>, indicating that the value of <code>&#39;a</code>…\nUsed to dictate when trait impls are allowed in the …\nLow priority, this implication has lower chance to be …\nMutable\nWhether a type is mutable or not.\nthe never type <code>!</code>\nIndicates that the attempted operation has “no solution…\nNo solution. See <code>chalk_ir::NoSolution</code>.\nProves that the given type alias <strong>normalizes</strong> to the given …\nTrue if the alias type can be normalized to some other type\nImmutable\nNegation: the inner goal should not hold.\nOne level higher than the innermost index.\nUsed to indicate that a trait is object safe.\nContains the success value\nSuccess\nAn opaque type.\nAn opaque type <code>opaque type T&lt;..&gt;: Trait = HiddenTy</code>.\nId for an opaque type.\na placeholder for opaque types like <code>impl Trait</code>\nLifetime on phantom data.\ninstantiated from a universally quantified type, e.g., from\nLifetime on some yet-unknown placeholder.\nLifetime on some yet-unknown placeholder.\nIndex of an universally quantified parameter in the …\nA program clause is a logic expression used to describe a …\nContains the data for a program clause.\nRepresents one clause of the form <code>consequence :- conditions</code>…\nList of interned elements.\nAn associated type projection.\nA projection <code>&lt;P0 as TraitName&lt;P1..Pn&gt;&gt;::AssocItem&lt;Pn+1..Pm&gt;</code>…\nIntroduces a binding at depth 0, shifting other bindings up\nA where clause that can contain <code>forall&lt;&gt;</code> or <code>exists&lt;&gt;</code> …\nList of interned elements.\nKinds of quantifiers in the logic, such as <code>forall</code> and …\nRoot universe index (0).\na raw pointer type like <code>*const T</code> or <code>*mut T</code>\na reference type like <code>&amp;T</code> or <code>&amp;mut T</code>\nUsed to activate the “reveal mode”, in which opaque (…\nDoes the type contain placeholders or inference variables …\nSafe\nWhether a function is safe or not.\nTypes of scalar values.\na scalar type like <code>bool</code> or <code>u32</code>\na slice type like <code>[T]</code>\nStatic lifetime\nthe string primitive type\nAn extension trait to anything that can be represented as …\nList of interned elements.\nSubtype goal: tries to prove that <code>a</code> is a subtype of <code>b</code>\nMake one thing a subtype of another; the rules for doing …\nUtility for converting a list of all the binders into scope\nA predicate which is true when some trait ref is …\nA predicate which enables deriving everything which should …\nThe id of a trait definition; could be used to load the …\nA trait reference describes the relationship between a …\na tuple of the given arity\nA Rust type. The actual type data is stored in <code>TyKind</code>.\nType argument\nA predicate which is true when some type is well-formed. …\nA predicate which enables deriving everything which should …\nContains the data for a Ty\nType data, which holds the actual type information.\nRepresents some extra knowledge we may have about the type …\nContains flags indicating various properties of a Ty\nType outlives, which for <code>T: &#39;a</code> checks that the type <code>T</code> …\nType outlives a lifetime.\nType outlives constraint <code>T: &#39;a</code>, indicating that the type <code>T</code> …\nA “universe canonical” value. This is a wrapper around …\nDifferent unsigned int types.\nLogic to decide the Variance for a given subst\nAn universe index is how a universally quantified …\nMaps the universes found in the <code>u_canonicalize</code> result (the …\nUnsafe\nThe “kind” of variable. Type, lifetime or constant.\nList of interned elements.\nVariance\nList of interned elements.\nUninhabited (empty) type, used in combination with …\nChecks whether a type or trait ref is well-formed.\nTrue if the type or trait ref is well-formed.\nWhere clauses that can be written by a Rust programmer.\nA value with an associated variable kind.\nAdds (an iterator of) clauses to the environment.\nReturns <code>Some(adt_id)</code> if this is an ADT, <code>None</code> otherwise\nGets the variances for the substitution of a adt\nGet a flags value with all known bits set.\nCreates a single goal that only holds if a list of goals …\nApply the substitution to a value.\nApply the substitution to a value.\nRepresent the current <code>Fn</code> as if it was wrapped in <code>Binders</code>\nConvert the current value to parameters.\nConverts <code>&amp;Binders&lt;T&gt;</code> to <code>Binders&lt;&amp;T&gt;</code>. Produces new <code>Binders</code> …\nReturns a slice containing the elements.\nReturns a slice containing the elements.\nReturns a slice containing the elements.\nReturns a slice containing the elements.\nReturns a slice containing the elements.\nReturns a slice containing the elements.\nReturns a slice containing the elements.\nReturns a slice containing the elements.\nAsserts that this is a constant argument.\nAsserts that this is a lifetime argument.\nAsserts that this is a type argument.\nThe id for the associated type member.\nIndex into the list of parameters.\nIndex into the sequence.\nIndex into the sequence.\nIndex into the sequence.\nIndex into the sequence.\nIndex into the sequence.\nIndex into the sequence.\nIndex into the sequence.\nIndex into the sequence.\nThe binders that quantify over the value.\nThe binders that quantify over the value.\nThe kind/universe of the variable.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nIf this is a <code>TyKind::BoundVar(d)</code>, returns <code>Some(d)</code> else <code>None</code>…\nIf this is a <code>ConstData::BoundVar(d)</code>, returns <code>Some(d)</code> else …\nIf this is a <code>Lifetime::BoundVar(d)</code>, returns <code>Some(d)</code> else …\nTrue if this variable is bound within the <code>amount</code> innermost …\nThe unknown self type.\nWhether one universe can “see” another.\nThe wrapped <code>Canonical</code>.\nUpcasts, to avoid writing out wrapper types.\nThe clauses in the environment.\nConverts a <code>Binders&lt;&amp;T&gt;</code> to a <code>Binders&lt;T&gt;</code> by cloning <code>T</code>.\nTakes a goal <code>G</code> and turns it into <code>compatible { G }</code>.\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nCompute type flags for a TyKind\ncompute type flags for Lifetime\nCompute type flags for GenericArg\nCompute type flags for aliases\nCompute type flags for Substitution\nThe condition goals that should hold.\nThe consequence of the clause, which holds if the …\nChecks whether two concrete constants are equal.\nReturns the constant if it is one, <code>None</code> otherwise.\nThe lifetime constraints that should be proven.\nRegion constraints that constrain the substitution.\nList of constraints that are part of the answer.\nWhether all set bits in a source flags value are also set …\nFast matching check for zippable values.\nThe counter for the universe index, starts with 0.\nGets the underlying type data.\nGets the constant data from the interner.\nGets the lifetime data.\nGets the underlying data.\nGet the program clause data.\nGets the interned goal data.\nDebruijn index, which identifies the binder.\nDebug impls for types.\nShow debug output for the application type.\nShow debug output for the projection type.\nShow debug output for the opaque type.\nShow debug output for the program clause implication.\nShow debug output for <code>Goals</code>.\nShow debug output for the substitution.\nDelayed subgoals, used when the solver answered with an …\nDepth of the De Bruijn index, counting from 0 starting with\nThe intersection of a source flags value with the …\nDisplay the canonicalized item.\nGet a flags value with all bits unset.\nWraps the given value in a binder without variables, i.e. …\nCreate an empty sequence.\nCreate an empty sequence.\nCreate an empty sequence.\nCreate an empty sequence.\nCreate an empty sequence.\nCreate an empty sequence.\nCreate an empty sequence.\nCreate an empty sequence.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nTransforms the inner value according to the given …\nType flags\nGets the variances for the substitution of a fn def\nTraits for transforming bits of IR.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a sequence from a single element.\nCreate a sequence from a single element.\nCreate a sequence from a single element.\nCreate a sequence from a single element.\nCreate a sequence from a single element.\nCreate a sequence from a single element.\nCreate a sequence from a single element.\nCreates a list of canonical variable kinds from a single …\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nCreates a <code>FromEnv</code> constraint using this type.\nConstruct a <code>FromEnv</code> using this trait ref.\nTries to create a sequence using an iterator of …\nTries to create a sequence using an iterator of …\nTries to create a sequence using an iterator of …\nTries to create a sequence using an iterator of …\nTries to create a sequence using an iterator of …\nTries to create a sequence using an iterator of …\nTries to create a sequence using an iterator of …\nTries to create a list of canonical variable kinds using …\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nCreate a sequence from elements\nCreate a sequence from elements\nCreate a sequence from elements\nCreate a sequence from elements\nCreate a sequence from elements\nCreate a sequence from elements\nCreate a sequence from elements\nCreates a list of canonical variable kinds using an …\nGet a flags value with the bits of a flag with the given …\nThis turns two levels of binders (<code>for&lt;A&gt; for&lt;B&gt;</code>) into one …\nTrue if any of the clauses in the environment have a …\nCreates a <code>Substitution</code> containing bound vars such that …\nIndex <em>in</em> the universe.\nCreate an implication goal that holds if the predicates …\nGets the underlying index value.\nIndex within the binder.\nReturn the index of the bound variable, but only if it is …\nReturn the index of the bound variable, but only if it is …\nIf this is a <code>TyKind::InferenceVar(d)</code>, returns <code>Some(d)</code> else …\nIf this is a <code>ConstData::InferenceVar(d)</code>, returns <code>Some(d)</code> …\nIf this is a <code>Lifetime::InferenceVar(d)</code>, returns <code>Some(d)</code> …\nHelper method for debugging <code>GenericArgData</code>.\nHelper method for debugging variable kinds.\nLists generic arguments that are inputs to this domain …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nCasts the type data to a type.\nWraps the constant data in a <code>Const</code>.\nWrap the lifetime data in a lifetime.\nCreate an interned type.\nCreate an interned type for this alias.\nIntern the program clause data.\nCreate an interned goal.\nGets the interned type.\nGets the interned constant.\nGets the interned value.\nGets the interned value.\nGet the interned program clause.\nGets the interned goal.\nGet the interned elements.\nGet the interned elements.\nGet the interned elements.\nGet the interned elements.\nGet the interned elements.\nGet the interned elements.\nGet the interned elements.\nGet the interned elements.\nThe interned constant.\nEncapsulates the concrete representation of core types …\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRepresent the current <code>Fn</code> as if it was wrapped in <code>Binders</code>\nChange the implication into an application holding a …\nChange the program clause data into a <code>FromEnv</code> program …\nChange the clause into a <code>FromEnv</code> clause.\nAs with <code>WhereClause::into_from_env_goal</code>, but mapped over …\nCreates a domain goal <code>FromEnv(T)</code> where <code>T</code> is this type.\nSame as <code>into_well_formed_goal</code> but with the <code>FromEnv</code> …\nConvert <code>Implemented(...)</code> into <code>FromEnv(...)</code>, but leave other\nAs with <code>WhereClause::into_from_env_goal</code>, but mapped over …\nSkips the binder and returns the “bound” value as well …\nAs with <code>WhereClause::into_well_formed_goal</code>, but for a …\nTurn a where clause into the WF version of it i.e.:\nAs with <code>WhereClause::into_well_formed_goal</code>, but for a …\nConverts <code>Covariant</code> into <code>Contravariant</code> and vice-versa. …\nReturns true if this is an <code>Alias</code>.\nWhether all known bits in this flags value are set.\nWhether all bits in this flags value are unset.\nCheck whether this is an empty sequence.\nCheck whether this is an empty sequence.\nCheck whether this is an empty sequence.\nCheck whether this is an empty sequence.\nCheck whether this is an empty sequence.\nCheck whether this is an empty sequence.\nCheck whether this is an empty sequence.\nCheck whether this is an empty sequence.\nReturns true if this is a <code>FloatTy</code>.\nReturns true if this is a <code>BoundVar</code> or an <code>InferenceVar</code> of …\nA substitution is an <strong>identity substitution</strong> if it looks …\nReturns true if this is an <code>IntTy</code> or <code>UintTy</code>.\nChecks whether the universe canonical value is a trivial …\nTrue if this goal is “trivially true” – i.e., no …\nChecks whether the generic argument is a type.\nYield a set of contained flags values.\nGet an iterator over the elements of the sequence.\nGet an iterator over the elements of the sequence.\nGet an iterator over the elements of the sequence.\nGet an iterator over the elements of the sequence.\nGet an iterator over the elements of the sequence.\nGet an iterator over the elements of the sequence.\nGet an iterator over the elements of the sequence.\nGet an iterator over the elements of the sequence.\nYield a set of contained named flags values.\nGets the underlying type kind.\nThe associated variable kind.\nThe kind\nThe associated variable kind.\nReturns the number of binders.\nGet the length of the sequence.\nGet the length of the sequence.\nGet the length of the sequence.\nGet the length of the sequence.\nGet the length of the sequence.\nGet the length of the sequence.\nGet the length of the sequence.\nGet the length of the sequence.\nReturns the lifetime if it is one, <code>None</code> otherwise.\nLifetime of the <code>DynTy</code>.\nThe lifetime which the type must outlive.\nMaps the goal without touching the environment.\nMaps the value in <code>WithKind</code>.\nMaps the binders by applying a function.\nMaps a function taking <code>WithKind&lt;I, &amp;T&gt;</code> over <code>&amp;WithKind&lt;I, T&gt;</code>…\nMaps a function taking <code>Binders&lt;&amp;T&gt;</code> over <code>&amp;Binders&lt;T&gt;</code>.\nTrue if this type contains “bound” types/lifetimes, …\nTrue if this const is a “bound” const, and hence needs …\nTrue if this lifetime is a “bound” lifetime, and hence …\nTakes a goal <code>G</code> and turns it into <code>not { G }</code>.\nCreates a new environment.\nCreates a new environment/goal pair.\nCreates a new universe map.\nCreates a type from <code>TyKind</code>.\nCreates a new bound variable.\nCreates a new de Bruijn index with a given depth.\nCreate a <code>Const</code> using something that can be cast to const …\nCreate a lifetime from lifetime data (or something that …\nConstructs a generic argument using <code>GenericArgData</code>.\nCreates a <code>WithKind</code> from a variable kind and a value.\nCreate new binders.\nCreate a new program clause using <code>ProgramClauseData</code>.\nCreate a new goal using <code>GoalData</code>.\nIncreases the index counter.\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nNumber of canonical universes.\nThe id for the opaque type.\nThe relative priority of the implication.\nCreate a goal using a <code>forall</code> or <code>exists</code> quantifier.\nThe intersection of a source flags value with the …\nRoot universe index (0).\nGets the type parameters of the <code>Self</code> type in this trait …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nUpdate this index in place by shifting it “in” through …\nUpdate in place by shifting out from <code>amount</code> binders.\nAdjusts the debruijn index (see <code>DebruijnIndex::shifted_in</code>).\nReturns the resulting index when this value is moved into …\nAdjusts the debruijn index (see <code>DebruijnIndex::shifted_in</code>).\nAdds <code>outer_binder</code> levels to the <code>self</code> index. Intuitively, …\nAdjusts the debruijn index (see <code>DebruijnIndex::shifted_in</code>).\nReturns the resulting index when this value is moved out …\nAdjusts the debruijn index (see <code>DebruijnIndex::shifted_in</code>).\nSubtracts <code>outer_binder</code> levels from the <code>self</code> index. …\nSkips the binder and returns the “bound” value. This …\nExtract the value, ignoring the variable kind.\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe substitution that is being constrained.\nThe substitution result.\nSubstitute <code>parameters</code> for the variables introduced by these\nThe substitution for the projection.\nThe substitution for the opaque type.\nThe substitution, containing both the <code>Self</code> type and the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nWraps the bound variable in a constant.\nWraps the inference variable in a constant.\nWrap the placeholder index in a constant.\nConverts the binders in scope to references to those …\nConverts the binders at the specified depth to references …\nWrap the bound variable in a lifetime.\nWraps the inference variable in a lifetime.\nWrap the placeholder instance in a lifetime.\nCasts the bound variable to a type.\nWraps the inference variable in a type.\nCreate an interned type.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nIf the underlying where clause is a <code>TraitRef</code>, returns its …\nIf where clause is a <code>TraitRef</code>, returns its trait id.\nIf the underlying where clause is a <code>TraitRef</code>, returns its …\nThe trait id.\nCreates an identity substitution.\nUnwraps a <code>ControlFlow</code> or propagates its <code>Break</code> value. This …\nReturns the type if it is one, <code>None</code> otherwise.\nType that holds the constant.\nThe type which must outlive the given lifetime.\nGets all type parameters in this trait ref, including <code>Self</code>.\nGets an iterator of all type parameters.\nIndex <em>of</em> the universe.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nA reverse map – for each universe Ux that appears in …\nThe number of universes that have been collapsed.\nThe wrapped value.\nThe value being quantified over.\nThe value of the constant.\nThe wrapped value.\nThe value being quantified over.\nThe item that is canonicalized.\nTraits for visiting bits of IR.\nCreates a WF-constraint for this type.\nConstruct a <code>WellFormed</code> using this trait ref.\nDisplays the substitution in the form <code>&lt; P0, .. Pn &gt;</code>, or (if\nReturns a “Debuggable” type that prints like …\nReturns a “Debuggable” type that prints like …\nCreates a fresh binders that contains a single type …\nTrue if the binder identified by this index is within the …\n<code>a.xform(b)</code> combines the variance of a context with the …\nTraits for “zipping” types, walking through two …\nThe <code>Cast</code> trait is used to make annoying upcasts between …\nThe “helper” trait for <code>cast</code> that actually implements …\nAn iterator that casts each element to some other type.\nAn iterator adapter that casts each element we are …\nCast a value to type <code>U</code> using <code>CastTo</code>.\nCast a value to type <code>T</code>.\nCast each element in this iterator.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA fast check to see whether two things could ever possibly …\nChecks whether <code>self</code> and <code>other</code> could possibly match.\nWraps debug output in angle brackets (<code>&lt;&gt;</code>).\nHelper struct for displaying canonicalized items.\nWrapper to allow forwarding to <code>Display::fmt</code>, <code>Debug::fmt</code>, …\nHelper struct for showing debug output for <code>GenericArgData</code>.\nHelper struct for showing debug output for <code>Goals</code>.\nHelper struct for showing debug output for opaque types.\nHelper struct for showing debug output for program clause …\nHelper struct for showing debug output for projection …\nTrait ref with associated separator used for debug output.\nHelper struct for showing debug output for the …\nHelper struct for showing debug output for substitutions.\nHelper struct for showing debug output for application …\nHelper struct for showing debug output for <code>VariableKinds</code>.\nShow debug output for the <code>SeperatorTraitRef</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe separator used for displaying the <code>TraitRef</code>.\nThe <code>TraitRef</code> itself.\nThe type this folder returns when folding fails. This is …\nA “folder” is a transformer that can be used to make a …\nSubstitution used during folding\nApplies the given <code>TypeFolder</code> to a value, producing a …\nA “folder” is a transformer that can be used to make a …\nFor types where “fold” invokes a callback on the …\nCreates a <code>dyn</code> value from this folder. Unfortunately, this …\nCreates a <code>dyn</code> value from this folder. Unfortunately, this …\nThis module contains impls of <code>TypeFoldable</code> for those types …\nThis module contains “rote and uninteresting” impls of …\nTop-level callback: invoked for each <code>Const&lt;I&gt;</code> that is …\nAs with <code>fold_free_placeholder_ty</code>, but for constants.\nAs with <code>fold_free_placeholder_ty</code>, but for lifetimes.\nInvoked for each occurrence of a placeholder type; these …\nAs <code>fold_free_var_ty</code>, but for constants.\nAs <code>fold_free_var_ty</code>, but for lifetimes.\nInvoked for <code>TyKind::BoundVar</code> instances that are not bound …\nInvoked for every goal. By default, recursively folds the …\nAs with <code>fold_inference_ty</code>, but for constants.\nAs with <code>fold_inference_ty</code>, but for lifetimes.\nInvoked for each occurrence of a inference type; these are …\nTop-level callback: invoked for each <code>Lifetime&lt;I&gt;</code> that is …\nInvoked for every program clause. By default, recursively …\nTop-level callback: invoked for each <code>Ty&lt;I&gt;</code> that is …\nA convenient alternative to <code>try_fold_with</code> for use with …\nIf overridden to return true, we will panic when a free …\nIf overridden to return true, we will panic when a free …\nIf overridden to return true, then folding will panic if a …\nIf overridden to return true, then folding will panic if a …\nIf overridden to return true, inference variables will …\nIf overridden to return true, inference variables will …\nSubroutines to help implementers of <code>TypeFoldable</code> avoid …\nGets the interner that is being folded from.\nGets the interner that is being folded from.\nValues to substitute. A reference to a free variable with …\nShifting of debruijn indices\nA convenient alternative to <code>try_super_fold_with</code> for use …\nTop-level callback: invoked for each <code>Const&lt;I&gt;</code> that is …\nAs with <code>try_fold_free_placeholder_ty</code>, but for constants.\nAs with <code>try_fold_free_placeholder_ty</code>, but for lifetimes.\nInvoked for each occurrence of a placeholder type; these …\nAs <code>try_fold_free_var_ty</code>, but for constants.\nAs <code>try_fold_free_var_ty</code>, but for lifetimes.\nInvoked for <code>TyKind::BoundVar</code> instances that are not bound …\nInvoked for every goal. By default, recursively folds the …\nAs with <code>try_fold_inference_ty</code>, but for constants.\nAs with <code>try_fold_inference_ty</code>, but for lifetimes.\nInvoked for each occurrence of a inference type; these are …\nTop-level callback: invoked for each <code>Lifetime&lt;I&gt;</code> that is …\nInvoked for every program clause. By default, recursively …\nTop-level callback: invoked for each <code>Ty&lt;I&gt;</code> that is …\nApply the given folder <code>folder</code> to <code>self</code>; <code>binders</code> is the …\nRecursively folds the value.\nTakes ownership of a <code>Vec</code> that is being mapped in place, …\nMaps a <code>Box&lt;T&gt;</code> to a <code>Box&lt;U&gt;</code>, reusing the underlying storage …\nMaps a <code>Vec&lt;T&gt;</code> to a <code>Vec&lt;U&gt;</code>, reusing the underlying storage …\nConverts back into a <code>Vec</code> once the map is complete.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA shifter that reduces debruijn indices – in other …\nMethods for converting debruijn indices to move values …\nA folder that adjusts debruijn indices by a certain amount.\nGiven a reference to a free variable at depth <code>depth</code> …\nGiven a free variable at <code>depth</code>, shifts that depth to `depth\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nShifts this term in one level of binders.\nShifts a term valid at <code>outer_binder</code> so that it is valid at …\nShifts this term out one level of binders.\nShifts a term valid at the innermost binder so that it is …\nSubstitution used during folding\nApplies the substitution by folding\nsee <code>fold_free_var_ty</code>\nsee <code>fold_free_var_ty</code>\nWe are eliminating one binder, but binders outside of that …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nValues to substitute. A reference to a free variable with …\nThe core “id” type used for trait-ids and the like.\nRepresentation of function ABI (e.g. calling convention).\nImplemented by types that have an associated interner …\nRepresentation of identifiers.\nThe ID type for ADTs\n“Interned” representation of a list of variable kinds …\n“Interned” representation of an evaluated const value. …\n“Interned” representation of const expressions. In …\n“Interned” representation of a list of region …\n“Interned” representation of a “generic parameter”…\n“Interned” representation of a “goal”.  In normal …\n“Interned” representation of a list of goals.  In …\n“Interned” representation of lifetimes.  In normal …\n“Interned” representation of a “program clause”.  …\n“Interned” representation of a list of program …\n“Interned” representation of a list of quantified …\n“Interned” representation of a “substitution”.  In …\n“Interned” representation of types.  In normal user …\n“Interned” representation of a list of variable kinds. …\n“Interned” representation of a list of …\nA “interner” encapsulates the concrete representation …\nThe interner associated with the type.\nLookup the slice of <code>CanonicalVariableKind</code> that was …\nLookup the <code>ConstData</code> that was interned to create a …\nDetermine whether two concrete const values are equal.\nLookup the slice of <code>Constraint</code> that was interned to create …\nPrints the debug representation of a type-kind-id. Returns …\nPrints the debug representation of an alias. To get good …\nPrints the debug representation of a type-kind-id. Returns …\nPrints the debug representation of an parameter kinds list …\nPrints the debug representation of a closure id. Returns …\nPrints the debug representation of a const. Returns <code>None</code> …\nPrints the debug representation of a Constraints. Returns …\nPrints the debug representation of an alias. Returns <code>None</code> …\nPrints the debug representation of a function-def-id. …\nPrints the debug representation of a foreign-def-id. …\nPrints the debug representation of an parameter. Returns …\nPrints the debug representation of an goal. Returns <code>None</code> …\nPrints the debug representation of a list of goals. …\nPrints the debug representation of a lifetime. Returns <code>None</code>…\nPrints the debug representation of an OpaqueTy. Returns …\nPrints the debug representation of an opaque type. Returns …\nPrints the debug representation of a ProgramClause. …\nPrints the debug representation of a …\nPrints the debug representation of a ProgramClauses. …\nPrints the debug representation of a ProjectionTy. Returns …\nPrints the debug representation of a …\nPrints the debug representation of a SeparatorTraitRef. …\nPrints the debug representation of a Substitution. Returns …\nPrints the debug representation of a type-kind-id. Returns …\nPrints the debug representation of a type. Returns <code>None</code> to …\nPrints the debug representation of a parameter kinds list. …\nPrints the debug representation of a parameter kinds list, …\nPrints the debug representation of a Variances. Returns …\nLookup the <code>LifetimeData</code> that was interned to create a …\nLookup the <code>GoalData</code> that was interned to create a …\nLookup the <code>GoalsData</code> that was interned to create a …\nCreate “interned” variable kinds with universe index …\nCreate an “interned” const from <code>const</code>. This is not …\nCreate “interned” constraints from <code>data</code>. This is not …\nCreate an “interned” parameter from <code>data</code>. This is not …\nCreate an “interned” parameter kinds from <code>data</code>. This …\nCreate an “interned” goal from <code>data</code>. This is not …\nCreate an “interned” goals from <code>data</code>. This is not …\nCreate an “interned” lifetime from <code>lifetime</code>. This is …\nCreate an “interned” program clause from <code>data</code>. This is …\nCreate an “interned” program clauses from <code>data</code>. This …\nCreate an “interned” quantified where clauses from <code>data</code>…\nCreate an “interned” substitution from <code>data</code>. This is …\nCreate an “interned” type from <code>ty</code>. This is not normally\nCreate “interned” variances from <code>data</code>. This is not …\nLookup the <code>LifetimeData</code> that was interned to create a …\nLookup the <code>ProgramClauseData</code> that was interned to create a …\nLookup the <code>ProgramClauseData</code> that was interned to create a …\nLookup the slice of <code>QuantifiedWhereClause</code> that was …\nLookup the <code>SubstitutionData</code> that was interned to create a …\nLookup the <code>TyKind</code> from an interned type.\nLookup the slice of <code>VariableKinds</code> that was interned to …\nLookup the slice of <code>Variance</code> that was interned to create a …\nThe “break type” of the visitor, often <code>()</code>. It …\nFor types where “visit” invokes a callback on the …\nApplies the given <code>visitor</code> to a value, producing a visited …\nA “visitor” recursively folds some term – that is, …\nCreates a <code>dyn</code> value from this visitor. Unfortunately, this …\nThis module contains impls of <code>TypeVisitable</code> for those …\nThis module contains “rote and uninteresting” impls of …\nIf overridden to return true, we will panic when a free …\nIf overridden to return true, then visiting will panic if a\nIf overridden to return true, inference variables will …\nGets the visitor’s interner.\nRecursively visits the type contents.\nTop-level callback: invoked for each <code>Const&lt;I&gt;</code> that is …\nInvoked for each domain goal.\nInvoked for each occurrence of a placeholder type; these …\nInvoked for <code>BoundVar</code> instances that are not bound within …\nInvoked for every goal. By default, recursively visits the …\nInvoked for each occurrence of a inference type; these are …\nTop-level callback: invoked for each <code>Lifetime&lt;I&gt;</code> that is …\nInvoked for every program clause. By default, recursively …\nTop-level callback: invoked for each <code>Ty&lt;I&gt;</code> that is …\nInvoked for each where clause.\nApply the given visitor <code>visitor</code> to <code>self</code>; <code>binders</code> is the …\nTypeVisitor helpers\nConvenience function to visit all the items in the …\nTypeVisitor extensions.\nReturns the argument unchanged.\nCheck whether there are free (non-bound) variables.\nCalls <code>U::from(self)</code>.\nThe <code>Zip</code> trait walks two values, invoking the <code>Zipper</code> …\nWhen we zip types, we basically traverse the structure, …\nGenerates a Zip impl that requires the two values be …\nRetrieves the interner from the underlying zipper object\nRetrieves the <code>UnificationDatabase</code> from the underlying …\nZips two values appearing beneath binders.\nIndicates that the two consts <code>a</code> and <code>b</code> were found in …\nIndicates that the two lifetimes <code>a</code> and <code>b</code> were found in …\nZips two substs\nIndicates that the two types <code>a</code> and <code>b</code> were found in …\nUses the zipper to walk through two values, ensuring that …")