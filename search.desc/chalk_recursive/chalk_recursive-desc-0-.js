searchState.loadedDescShard("chalk_recursive", 0, "The “cache” stores results for goals that we have …\nThe wrapped <code>Canonical</code>.\nThe number of universes that have been collapsed.\nThe <code>minimums</code> struct is used while solving to track whether …\nThe “cache” stores results for goals that we have …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe maximum size for goals.\nThe “search graph” stores “in-progress results” …\nAttempt to solve a goal that has been fully broken down …\nSolves a canonical goal. The substitution returned in the …\nThe “cache” stores results for goals that we have …\nReturns the argument unchanged.\nReturns the argument unchanged.\nRecord a cache result.\nRecord a cache result.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe “search graph” stores in-progress goals that are …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInsert a new search node in the tree. The node will be in …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhile this node is on the stack, this field will be set to …\nRemoves all nodes with a depth-first-number greater than or\nClears all nodes with a depth-first number greater than or …\nThis is <code>Some(X)</code> if we are actively exploring this node, or …\nThe data we actively keep for each goal on the stack.\nWas this a coinductive goal?\nInitially false, set to true when some subgoal depends on …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTrue iff there exist at least one coinductive goal and one …\nA <code>Fulfill</code> is where we actually break down complex goals, …\nWhen refuting a goal, there’s no impact on inference …\nA goal that must be resolved\nWhen proving a leaf goal, we record the free variables …\nFor “positive” goals, we flatten all the way out to …\nFor “negative” goals, we don’t flatten in <em>this</em> …\nTrying to prove some goal led to a the substitution <code>subst</code>; …\nRecord that a goal has been processed that can neither be …\nLifetime constraints that must be fulfilled for a solution …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe remaining goals to prove or refute\nCreate obligations for the given goal in the given …\nTry to fulfill all pending obligations and build the …\nUnifies <code>a</code> and <code>b</code> in the given environment.\nA Solver is the basic context in which you can propose …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe <code>solve_iteration</code> method – implemented for any type …\nHelper methods for <code>solve_iteration</code>, private to this module.\nSee whether we can solve a goal by implication on any of …\nExecutes one iteration of the recursive solver, computing …")