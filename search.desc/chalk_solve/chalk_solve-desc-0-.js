searchState.loadedDescShard("chalk_solve", 0, "Trait representing access to a database of rust types.\nReturns the datum for the ADT with the given id.\nRetrieves a struct’s original name. No uniqueness …\nReturns the representation for the ADT definition with the …\nReturns the siza and alignment of the ADT definition with …\nRetrieves the name of an associated type. No uniqueness …\nReturns the datum for the associated type with the given …\nReturns the <code>AssociatedTyValue</code> with the given id.\nGets the substitution for the closure when used as a …\nGets the inputs and output for a given closure id and …\nGets the <code>ClosureKind</code> for a given closure and substitution.\nGets the upvars as a <code>Ty</code> for a given closure id and …\nReturns the coroutine datum for the coroutine with the …\nReturns the coroutine witness datum for the coroutine with …\nReturns any “custom program clauses” that do not …\nReturns the datum for the fn definition with the given id.\nRetrieves the name of a function definition. No uniqueness …\nReturns the “hidden type” corresponding with the …\nReturns the datum for the impl with the given id.\nReturns true if there is an explicit impl of the auto trait\nReturns a list of potentially relevant impls for a given …\nCheck if a trait is object safe\nReturns the impls that require coherence checking. This is …\nProvides wrappers over <code>RustIrDatabase</code> which record used …\nReturns the <code>OpaqueTyDatum</code> with the given id.\nRetrieves the name of an opaque type. No uniqueness …\nCalculates program clauses from an env. This is intended …\nContains the definition for the “Rust IR” – this is …\nReturns the datum for the definition with the given id.\nRetrieves a trait’s original name. No uniqueness …\nReturns id of a trait lang item, if found\nThis gets rid of free variables in a type by replacing …\nExamine <code>T</code> and push clauses that may be relevant to proving …\nGiven some goal <code>goal</code> that must be proven, along with its …\nReturns a set of program clauses that could possibly match …\nFIXME(#505) update comments for ADTs For auto-traits, we …\nLeak auto traits for opaque types, just like …\nAdds clauses to allow normalizing possible downstream …\nGenerate program clauses from the associated-type values …\nThe “clause builder” is a useful tool for building up …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAccesses the placeholders for the current list of …\nExecutes <code>op</code> with the <code>binders</code> in-scope; <code>op</code> is invoked with …\nPush a single binder, for a lifetime, at the end of the …\nPush a single binder, for a type, at the end of the binder …\nPushes a clause <code>forall&lt;..&gt; { consequence :- conditions }</code> …\nPushes a clause …\nPushes a “fact” <code>forall&lt;..&gt; { consequence }</code> into the …\nPushes a “fact” <code>forall&lt;..&gt; { consequence }</code> into the …\nAccesses the placeholders for the current list of …\nLike <code>add_builtin_program_clauses</code>, but for …\nFor well known traits we have special hard-coded impls, …\nReturns type of the last field of the input struct, which …\nGiven a trait ref <code>T0: Trait</code> and a list of types <code>U0..Un</code>, …\nAdd implicit impls of the coroutine trait, i.e., add a …\nHandles clauses for FnOnce/FnMut/Fn. If <code>self_ty</code> is a …\nAdd implicit impl for the <code>Pointee</code> trait for all types\nAdd implicit impl for the <code>Tuple</code> trait for all tuples\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIf the self type <code>S</code> of an <code>Implemented</code> goal is a <code>dyn trait</code> …\nWhen proving a <code>FromEnv</code> goal, we elaborate all <code>FromEnv</code> goals\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nTrait for lowering a given piece of rust-ir source (e.g., …\nGenerates the “fully visible” program clauses for an …\nGenerates the “implied bounds” clauses for an …\nGenerates the “well-formed” program clauses for an …\nGenerate <code>Implemented</code> and <code>Normalize</code> clauses for <code>dyn Trait</code> …\nStores the specialization priorities for a set of impls. …\nImpls with higher priority take precedence over impls with …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nStore the priority of an impl (used during construction). …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstructs a new <code>CoherenceSolver</code>.\nLookup the priority of an impl in the set (panics if impl …\nA goal G has coinductive semantics if proving G is allowed …\nLike a BoundVar, but with the debrujin index inverted so …\nWriter state which persists across multiple writes.\nMap from the DefIds we’ve encountered to a u32 alias id …\nWriter logic for <code>where</code> clauses and other bounds.\nDisplays a set of bounds, all targeting <code>Self</code>, as just the …\nDisplays a trait with its parameters and a single …\nDisplays a type with its parameters - something like …\nWriter logic for simple IDs\nThe inverted debrujin index. Corresponds roughly to an …\nWriter logic for top level items.\nMap from each name to the next unused u32 alias id.\n<code>RenderAsRust</code> trait and related utils.\nProcesses a name given by an <code>Interner</code> debug method into …\nPersistent state passed down between writers.\nContains a <code>LoggingIrDatabase</code> which returns stub versions …\nWriter logic for types.\nRender utilities which don’t belong anywhere else.\nThe index within the debrujin index. Corresponds to …\nWrites out each item recorded by a <code>LoggingRustIrDatabase</code>.\nWrites stubs for items which were referenced by name, but …\nUsed in <code>AdtDatum</code> and <code>TraitDatum</code> to write n flags from a …\nDisplays <code>RenderAsRust</code> data.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nWriter state for a single write call, persistent only as …\nLike a BoundVar, but with the debrujin index inverted so …\nWriter state which persists across multiple writes.\nAdds a level of debrujin index, and possibly a “Self” …\nAdds parameter remapping.\nMap from the DefIds we’ve encountered to a u32 alias id …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInverts the debrujin index so as to create a canonical …\nThe inverted debrujin index. Corresponds roughly to an …\nMap from each name to the next unused u32 alias id.\nThe index within the debrujin index. Corresponds to …\nReturns a new version of self containing a wrapped …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nProcesses a name given by an <code>Interner</code> debug method into …\nCreates a goal that ensures all of the goals from the <code>goals</code>\nReturns the database within the goal builder.\nLike <code>GoalBuilder::forall</code>, but for a <code>exists&lt;Q0..Qn&gt; { G }</code> …\nGiven a bound value <code>binders</code> like <code>&lt;P0..Pn&gt; V</code>, creates a …\nReturns the argument unchanged.\nCreates a goal <code>clauses =&gt; goal</code>. The clauses are given as …\nReturns the interner within the goal builder.\nCalls <code>U::from(self)</code>.\nA combined helper functon for the various methods to …\nGiven a value <code>value</code> with variables in it, replaces those …\nMake permanent the changes made since the snapshot was …\nGiven the binders from a canonicalized value C, returns a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new inference table, pre-populated with …\nFinds the root inference var for the given variable.\nVariant on <code>instantiate_in</code> that takes a <code>Binders&lt;T&gt;</code>.\nVariant on <code>instantiate</code> that takes a <code>Canonical&lt;T&gt;</code>.\nInstantiates <code>arg</code> with fresh existential variables in the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts <code>value</code> into a “negation” value – meaning one …\nAs <code>negated_instantiated</code>, but canonicalizes before …\nThe associated variable kind.\nCreate an empty inference table with no variables.\nCreates and returns a fresh universe that is distinct from …\nCreates a new inference variable and returns its index. The\nIf type <code>leaf</code> is a free inference variable, and that …\nRestore the table to the state it had when the snapshot …\nTakes a “snapshot” of the current state of the …\nGiven an unbound variable, returns its universe.\nThe free existential variables, along with the universes …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe canonicalized result.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe <code>UCollector</code> is a “no-op” in terms of the value, but …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe canonicalized result.\nA map between the universes in <code>quantified</code> and the original …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGeneralizes all but the first\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRelate <code>a</code>, <code>b</code> such that if <code>variance = Covariant</code>, <code>a</code> is a …\nPushes a goal of <code>a</code> being a subtype of <code>b</code>.\nThe main entry point for the <code>Unifier</code> type and really the …\nRelate an alias like <code>&lt;T as Trait&gt;::Item</code> or <code>impl Trait</code> with …\nRelate <code>a</code>, <code>b</code> with the variance such that if …\nUnify an inference variable <code>var</code> with some non-inference …\nUnify a general inference variable with a specific …\nUnify two inference variables\nWrapper around <code>chalk_ir::InferenceVar</code> for coherence …\nThe value of an inference variable. We start out as <code>Unbound</code>…\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert this inference variable into a const. When using …\nConvert this inference variable into a lifetime. When …\nSame as <code>to_ty_with_kind</code>, but the kind is set to …\nConvert this inference variable into a type. When using …\nRun an action with a tracing log subscriber. The logging …\nWraps another <code>RustIrDatabase</code> (<code>DB</code>) and records which …\nWraps a <code>RustIrDatabase</code>, and, when dropped, writes out all …\nReturns the coroutine witness datum for the coroutine with …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCollects the identifiers needed to resolve all the names …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nInformation about the size and alignment of an ADT.\nRepresents an alias equality bound on e.g. a type or type …\nRepresents an associated type declaration found inside of …\nEncodes the parts of <code>AssociatedTyDatum</code> where the parameters\nRepresents the <em>value</em> of an associated type that is assigned\nIdentifier for an “associated type value” found in …\nIndicates the “most permissive” Fn-like trait that the …\nRepresents a coroutine type.\nThe nested types for a coroutine. This always appears …\nThe coroutine witness data. Each <code>CoroutineId</code> has both a …\nThe coroutine witness types, together with existentially …\nA rust intermediate representation (rust_ir) of a function …\nRepresents the bounds on a <code>FnDefDatum</code>, including the …\nRepresents the inputs and outputs on a <code>FnDefDatum</code>. This is …\nThe trait <code>FnOnce&lt;Args&gt;</code> - the generic argument <code>Args</code> is …\nAn inline bound, e.g. <code>: Foo&lt;K&gt;</code> in …\nRepresents the bounds for an <code>impl Trait</code> type.\nRepresents a trait bound on e.g. a type or type parameter. …\nA rust intermediate representation (rust_ir) of a Trait …\nA list of the traits that are “well known” to chalk, …\nUtility function that converts from a list of generic …\nTypes of the function’s arguments\nAssociated type being defined.\nAn “auto trait” is one that is “automatically …\nThe binders that quantify over the value.\nThese binders represent the <code>P0...Pm</code> variables.  The binders\nThe type bound to when revealed.\nBounds on the associated type itself.\nTrait bounds for the opaque type. These are bounds that …\nReturns the associated ty’s bounds applied to the …\n“Flags” indicate special kinds of traits, like auto …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nA fundamental trait is a trait where adding an impl for an …\nThe ID of this associated type\nImpl in which this associated type value is found.  You …\nThis binder is identical to the <code>input_output</code> binder in …\nAll of the nested types for this coroutine. The <code>Binder</code> …\nInputs and outputs defined on a function These are needed …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nApplies the <code>InlineBound</code> to <code>self_ty</code> and lowers to a …\nName of this associated type.\nIndicates that chalk cannot list all of the …\nThe placeholder <code>!T</code> that corresponds to the opaque type <code>T</code>.\nDoes not include trait parameters.\nThe coroutine resume type - a value of this type is …\nReturn type of the function\nThe coroutine return type - a value of this type is …\nGiven <code>impl&lt;T: Clone&gt; Clone for Vec&lt;T&gt; { ... }</code>, generate:\nGiven the following type definition: <code>struct Foo&lt;T: Eq&gt; { }</code>…\nGiven the following function definition: …\nGiven the following trait declaration: …\nFor each associated type, we define the “projection …\nGiven the following trait:\nGiven <code>opaque type T&lt;U&gt;: A + B = HiddenTy where U: C;</code>, we …\nThe trait this associated type is defined in.\nType that we normalize to. The X in <code>type Foo&lt;&#39;a&gt; = X</code>.\nIndicate that a trait is defined upstream (in a …\nThe upvars stored by the coroutine. These represent types …\nAdditional binders declared on the associated type itself, …\nIf this is a well-known trait, which one? If <code>None</code>, this is …\nGives access to the where clauses of the trait, quantified …\nWhere clauses defined on the function\nWhere clauses defined on the trait:\nWhere clauses that must hold for the projection to be …\nWhere clauses that inform well-formedness conditions for …\nThe coroutine yield type - a value of this type is …\nThe goal may be provable in multiple ways, but regardless …\nThe existential variables <em>must</em> have the given values if …\nWhen a goal holds ambiguously (e.g., because there are …\nA (possible) solution for a proposed goal.\nFinds the solution to “goals”, or trait queries – …\nThere are multiple plausible values for the existentials, …\nThe goal indeed holds, and there is a unique value for all …\nThere’s no useful information to feed back to type …\nThere are multiple candidate solutions, which may or may …\nExtract a constrained substitution from this solution, …\nDetermine whether this solution contains type information …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nA convenience method for when one doesn’t need the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nView this solution purely in terms of type inference …\nAttempts to solve the given goal, which must be in …\nAttempts to solve the given goal, which must be in …\nAttempts to solve the given goal, which must be in …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n“Truncation” (called “abstraction” in the papers …\nMethods for splitting up the projections for associated …\nGiven the full set of parameters for an associated type …\nGiven the full set of parameters (or binders) for an …\nGiven the full set of parameters (or binders) for an …\nGiven a projection of an associated type, split the type …\nGiven a projection <code>&lt;P0 as Trait&lt;P1..Pn&gt;&gt;::Item&lt;Pn..Pm&gt;</code>, …\nGiven a projection <code>&lt;P0 as Trait&lt;P1..Pn&gt;&gt;::Item&lt;Pn..Pm&gt;</code>, …\nDefines methods to compute well-formedness goals for …\nVerify constraints a CoerceUnsized impl. Rules for …\nAssociated type values are special because they can be …\nVerify constraints on a Copy implementation. Copy impl is …\nVerify constraints of a DispatchFromDyn impl.\nVerifies constraints on a Drop implementation Drop …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates the conditions that an impl (and its contents of …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstructs a new <code>WfSolver</code>.\nComputes a goal to prove Sized constraints on a struct …\nVerify builtin rules for well-known traits")